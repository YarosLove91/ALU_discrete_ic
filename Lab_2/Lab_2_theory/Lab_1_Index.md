- [1. Цели и ход работы](#1-цели-и-ход-работы)
- [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
  - [2.1 Сумматоры](#21-сумматоры)
    - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
    - [2.1.2 Сумматоры с параллельным ускоренным переносом CLA](#212-сумматоры-с-параллельным-ускоренным-переносом-cla)
  - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
    - [2.2.1 Теоретические сведения  ](#221-теоретические-сведения--)
    - [2.2.1 Функциональные модули АЛУ](#221-функциональные-модули-алу)
      - [2.2.1.1 Входные регистры](#2211-входные-регистры)
      - [2.2.1.2 Управляющий модуль (декодер операций)](#2212-управляющий-модуль-декодер-операций)
      - [2.2.1.3 Арифметический блок](#2213-арифметический-блок)
      - [2.2.1.4 Логический блок](#2214-логический-блок)
      - [2.2.1.5 Блок сдвигов (шифратор/дешифратор сдвигов)](#2215-блок-сдвигов-шифратордешифратор-сдвигов)
      - [2.2.1.6 Схема генерации и распространения переноса (Carry Lookahead Generator)](#2216-схема-генерации-и-распространения-переноса-carry-lookahead-generator)
      - [2.2.1.7 Схема флагов состояния (статусный регистр)](#2217-схема-флагов-состояния-статусный-регистр)
      - [2.2.1.8 Выходной регистр (или шина результата)](#2218-выходной-регистр-или-шина-результата)
      - [2.2.1.9 Мультиплексоры и линии выбора](#2219-мультиплексоры-и-линии-выбора)
    - [2.2.2 Пример АЛУ 74181](#222-пример-алу-74181)
  - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
    - [2.3.1 Микросхема 4-разрядного ускоренного переноса — 74182](#231-микросхема-4-разрядного-ускоренного-переноса--74182)
    - [2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#232-микросхема-32-разрядного-ускоренного-переноса---74882)
- [3 Сведения о лабораторном оборудовании](#3-сведения-о-лабораторном-оборудовании)
  - [3.1 Микросхема 4-разрядного АЛУ — 74181](#31-микросхема-4-разрядного-алу--74181)
  - [3.2 Микросхема 4-разрядного ускоренного переноса — 74182](#32-микросхема-4-разрядного-ускоренного-переноса--74182)
    - [3.3 Микросхема 32-разрядного ускоренного переноса - 74882](#33-микросхема-32-разрядного-ускоренного-переноса---74882)


## 1. Цели и ход работы 
Целью данной лабораторной работы является изучение и экспериментальное исследование арифметико-логических устройств (АЛУ) и блоков ускоренного переноса (CLA), их структуры, принципов работы и способов организации многобитных вычислений.

## 2. Цифровые операционные устройства
Операционные устройства (ОУ) выполняют операции преобразования информационных сообщений, которые по функциональному назначению могут быть данными, адресами и (в особых исполнениях) командами.  
Неизбежным является оперативное сохранение сообщений при их подготовке к обработке, в процессе обработки и по получению и применению результата обработки.  
Последовательность переходов между этапами подготовки, сохранения и преобразования данных определяется сигналами устройств управления.  

К цифровым операционным устройствам относятся __сумматоры__ (сумматоры-вычитетели) и __арифметико-логические устройства__.  

### 2.1 Сумматоры
Сумматоры — это цифровые операционные устройства, предназначенные для выполнения операции сложения двоичных чисел. Они являются фундаментальными элементами арифметико-логических устройств современных процессоров, цифровых сигнальных процессоров (DSP) и вычислительных ядер. Схемотехнически сумматоры представляют собой комбинационные логические схемы, которые реализуют булевы функции сложения по модулю два (сложение без учета переноса) и операции переноса разряда.

Алгоритм двоичного сложения является базовой арифметической операцией, на которой строится работа всех цифровых вычислительных систем. Принцип сложения двоичных чисел аналогичен сложению десятичных чисел, но с учётом особенностей двоичной системы счисления, где допустимы только два значения: 0 и 1.

Для сложения двух одноразрядных двоичных чисел $A$ и $B$ с учётом входного переноса $C_{in}$ используется следующая таблица истинности:

| $A$ | $B$ | $C_{in}$ | Сумма $(S)$| Перенос $(C_{out})$ |
| - | - | -------- | --------- | ------------------- |
| 0 | 0 | 0        | 0         | 0                   |
| 0 | 0 | 1        | 1         | 0                   |
| 0 | 1 | 0        | 1         | 0                   |
| 0 | 1 | 1        | 0         | 1                   |
| 1 | 0 | 0        | 1         | 0                   |
| 1 | 0 | 1        | 0         | 1                   |
| 1 | 1 | 0        | 0         | 1                   |
| 1 | 1 | 1        | 1         | 1                   |

Отсюда формируются логические выражения:

Сумма:

$S = A ⊕ B ⊕ C_{in}$

Перенос:

$C_{out} = (A ⋅ B) + (C_{in} ⋅ (A ⊕ B))$

*Классификация сумматоров*

Сумматоры можно классифицировать по нескольким признакам, исходя из особенностей их построения и схемных решений. Основные типы классификации следующие:

1. По числу входных разрядов:
   - __Одноразрядные:__
      - Полусумматоры (складывают два числа без учёта переноса);
      - Полные сумматоры (складывают два числа с учётом входного переноса).

   - __Многоразрядные:__
        Сложение выполняется по алгоритму последовательного или ускоренного переноса.

2. По способу переноса:
   - __Сумматоры с последовательным переносом (Ripple Carry Adder, RCA)__:
     Перенос передаётся последовательно от младшего разряда к старшему. Простая структура, но большая задержка при увеличении разрядности.
   - __Сумматоры с ускоренным переносом (Carry Look-Ahead Adder, CLA):__
     Переносы вычисляются заранее с использованием функций генерации и распространения переноса. Существенно меньшая задержка по сравнению с RCA.
   - __Сумматоры с прогнозированием переноса (Carry Select Adder, CSA):__
     Число разбивается на блоки, и сложение в блоках выполняется параллельно для двух вариантов переноса (0 и 1), после чего выбирается правильный результат. Компромисс между быстродействием и сложностью схемы.
   - __Сумматоры с сщхранением переносом (Carry Skip Adder, CSA):__
     Используют специальные схемы пропуска переноса через группы разрядов, что сокращает задержку.
   - __Иерархические (многоуровневые) сумматоры:__
     Строятся с применением многоуровневых схем ускоренного переноса. Хорошо масштабируются для больших разрядностей (например, 32, 64 и более бит).

3. По скорости работы:
   - __Медленные__ (например, RCA) — линейная зависимость задержки от разрядности.
   - __Ускоренные__ (CLA, CSA, CSA) — задержка растёт логарифмически или квазилогарифмически от числа разрядов.


#### 2.1.1 Сумматоры с последовательным переносом
Сумматоры с последовательным переносом представляют собой наиболее простую и базовую реализацию многоразрядных сумматоров в цифровой логике. Они получили широкое распространение в схемах малой и средней разрядности, где важны минимальные затраты по логическим элементам и простота проектирования.

*Структура и принцип работы*

Многоразрядный сумматор с последовательным переносом строится из цепочки полных сумматоров, где каждый следующий сумматор принимает на вход перенос из предыдущего разряда. Это создаёт линейную зависимость времени задержки по числу разрядов.

![alt text](/Lab_2/Lab_2_theory/Images/screnshots/RCA.png)

Рисунок 1 - Сумматор с последовательным переносом

Рисунок 1 иллюстрирует структуру многоразрядного сумматора с последовательным переносом, где:

$A_{i}$, $B_{i}$ — биты слагаемых чисел в i-м разряде,  
$С_{i}$ — перенос, поступающий с предыдущего разряда,  
$S_{i}$ — сумма в текущем разряде,  
$C_{i+1}$  — перенос на следующий разряд.

На схеме показано, как несколько однобитовых сумматоров соединены последовательно. Каждый блок в схеме — это однобитовый полный сумматор (Full Adder). 

Формально, для i-го разряда суммирование определяется следующими логическими выражениями:

$S = A_{i} ⊕ B_{i} ⊕ C_{i}$  
$C_{i} = (A_{i} ⋅ B_{i}) + (C_{in} ⋅ (A_{i} ⊕ B_{i}))$  

где:

⊕ — операция исключающего ИЛИ (XOR),

⋅ — логическое И (AND),

$+$ — логическое ИЛИ (OR).

Сигнал переноса передаётся последовательно от одного сумматора к другому:
- Первый сумматор принимает начальный перенос $C_{0}$ = 0.
- Каждый следующий сумматор использует выходной перенос предыдущего как свой входной.

Таким образом, сигнал переноса "протекает" по цепочке от младшего разряда к старшему.  Именно задержка распространения переноса $C_{i+1}$ по цепочке полных сумматоров и определяет суммарное время отклика всего сумматора. Каждый перенос должен быть вычислен до того, как следующий разряд сможет начать работу, что и образует последовательный характер выполнения сложения.

*Преимущества и недостатки*

Преимущества:  
- Простейшая архитектура, хорошо поддающаяся ручному и автоматизированному преобразованию;  
- Минимальные аппаратные затраты;  
- Хорошо подходит для реализации в программируемых логических интегральных схемах (ПЛИС) с ограниченными ресурсами.  

Недостатки:  
- Линейная задержка при увеличении разрядности;  
- Неэффективность при работе на высоких частотах и больших разрядностях;  
- Склонность к накоплению ошибок тайминга при длинных цепочках переноса.

#### 2.1.2 Сумматоры с параллельным ускоренным переносом CLA

Сумматоры с ускоренным переносом были разработаны как ответ на главный недостаток RCA — последовательную задержку переноса. Архитектура CLA позволяет вычислять переносы параллельно для всех разрядов, что существенно ускоряет процесс сложения и уменьшает общую задержку схемы до логарифмической зависимости от разрядности.

![alt text](/Lab_2/Lab_2_theory/Images/screnshots/СLA.png)

Рисунок 2 - Сумматор с параллельным ускоренным переносом

*Структура и принцип работы*

Суть ускоренного суммирования заключается в том, чтобы заранее вычислить сигналы переноса на основе входных битов, а не ждать их распространения по цепочке. Для этого вводятся две ключевые логические функции:

- Сигнал генерации переноса $G_i$ (Generate):  
  $G_i = A_i \cdot B_i$
  Этот сигнал означает, что текущая пара битов $A_i$ и $B_i$ непосредственно генерирует перенос, независимо от переноса с предыдущего разряда.

- Сигнал распространения переноса $P_i$ (Propagate):  
  $P_i = A_i \oplus B_i$
  Этот сигнал указывает на то, что разряд $i$ пропускает перенос, если он поступает от младшего разряда.

Общий сигнал переноса для разряда $i+1$ может быть выражен через сигналы $G_i$, $P_i$ и входной перенос $C_i$:

$C_{i+1} = G_i + (P_i \cdot C_i)$

Это рекурсивное выражение позволяет построить полную схему переноса, избегая последовательного распространения.

Для 4-разрядного CLA выражения будут следующими:

- $C_1 = G_0 + P_0 \cdot C_0$
- $C_2 = G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot C_0$
- $C_3 = G_2 + P_2 \cdot G_1 + P_2 \cdot P_1 \cdot G_0 + P_2 \cdot P_1 \cdot P_0 \cdot C_0$
- $C_4 = G_3 + P_3 \cdot G_2 + P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot G_0 + P_3 \cdot P_2 \cdot P_1 \cdot P_0 \cdot C_0$

Таким образом, каждый перенос вычисляется параллельно, без необходимости дожидаться результата предыдущего разряда.

Сумма для каждого разряда $S_i$ находится по стандартной формуле:

$S_i = P_i \oplus C_i = (A_i \oplus B_i) \oplus C_i$


<!-- Как эти сигналы P & G порождаются ??  -->
<!-- Зачем P & G нужны ?  -->
https://www.righto.com/2017/03/inside-vintage-74181-alu-chip-how-it.html#:~:text=Creating%20P%20and%20G%20with%20an%20arbitrary%20Boolean%20function

*Преимущества и недостатки*

Преимущества:

- Существенно более высокая скорость по сравнению с RCA, особенно на больших разрядностях;  
- Параллельная обработка переносов сокращает путь задержки;  
- Хорошо масштабируется для процессоров с 32, 64 и более битами данных.  

Недостатки:

- Увеличение числа логических элементов и более сложная логическая схема;  
- Повышенное потребление энергии;  
- Большая площадь кристалла при реализации в интегральных схемах (ASIC).  
  
### 2.2 Арифметико - логическое устройство  
#### 2.2.1 Теоретические сведения  <!--  Где теоретическое описание ? -->

Арифметико-логическое устройство (АЛУ) представляет собой ключевой компонент вычислительных систем, предназначенный для выполнения логических и арифметических операций с данными. Арифметико-логические устройства выполняют арифметические и логические преобразования над словами, называемыми операндами. Операндами могут быть двоичные числа разных форм представления. 

Элементарные арифметические и логические операции реализуются с помощью комбинационных схем на логических элементах. Например, сложение выполняется сумматорами, а сдвиги – регистрами сдвига. Более сложные операции (умножение, деление) реализуются программно или микропрограммно путем последовательного выполнения элементарных операций.

Для работы с числовыми данными в АЛУ используются:
- Сумматоры – для сложения и вычитания;
- Регистры сдвига – для перемещения битов;
- Регистры счёта – для накопления значений при арифметических операциях;
- Компараторы – для сравнения значений.
  
По своей структуре АЛУ относится к классу комбинационных схем, поскольку не содержит элементов памяти. Это означает, что его выходные сигналы зависят исключительно от текущего состояния входных данных. Время выполнения каждой операции определяется характеристиками используемых электронных компонентов, типом выполняемой логической функции и видом АЛУ.

__Классификация АЛУ__

Существуют разные виды АЛУ по организации обработки данных:

- По способу обработки данных во времени:
    - Последовательные АЛУ – выполняют операции поэтапно, что снижает скорость, но экономит аппаратные ресурсы.
    - Параллельные АЛУ – обрабатывают несколько битов одновременно, ускоряя вычисления.
- По форме представления данных:
    - С фиксированной запятой.
    - С плавающей запятой.
- По архитектуре:
    - Многофункциональные АЛУ – выполняют все операции в одном блоке, что уменьшает затраты на оборудование, но снижает скорость обработки.
    - Блочные АЛУ – каждая операция выполняется в отдельном блоке, что увеличивает производительность и упрощает параллельную обработку.
- По организации временного цикла:
    - Синхронные АЛУ – работают в фиксированные тактовые интервалы.
    - Асинхронные АЛУ – начинают новую операцию сразу после завершения предыдущей, что уменьшает задержки, но усложняет схемотехнику.

#### 2.2.1 Функциональные модули АЛУ
##### 2.2.1.1 Входные регистры

*Назначение:* 

Хранят операнды (входные данные) перед выполнением операции. Обычно обозначаются как $A$ и $B$. Эти регистры могут быть доступны через мультиплексоры, чтобы обеспечивать гибкость в выборе источников данных (например, из регистрового файла, шины данных или постоянных значений).

*Особенности:*
-  Количество разрядов входных регистров соответствует разрядности АЛУ (например, 8, 16, 32 или 64 бита).
- Входные регистры управляются сигналами синхронизации (тактовыми импульсами) и сигналами разрешения загрузки (load enable), поступающими от управляющего блока процессора.
- В некоторых архитектурах регистры могут использоваться как входы-выходы (IO), позволяя не только загружать данные, но и считывать их обратно (например, для отладки или повторного использования).

##### 2.2.1.2 Управляющий модуль (декодер операций)

*Назначение:*

Интерпретирует управляющие сигналы, полученные от блока управления ЦП, и выбирает соответствующую операцию, активируя нужные блоки внутри АЛУ.

*Функции:*
- Декодирование сигнала операции (например, 4-битного кода — 16 возможных операций).
- Управление мультиплексорами выбора функции.
- Формирование управляющих сигналов для:
  - Арифметического блока
  - Логического блока
  - Сдвигового блока
  - Схемы флагов

##### 2.2.1.3 Арифметический блок

*Назначение:* 
В арифметическом режиме АЛУ рассматривает входные данные как двоичные числа. Операции выполняются с учётом переноса между разрядами, что позволяет реализовать математические функции, такие как сложение и вычитание.

*Функции:*
- Сложение (ADD): реализуется через сумматор, чаще всего — ускоренный (например, CLA)
    
    Формула для i-го бита:

    $S_i = A_i + B_i + C_{i-1}$
 
    где, $C_{i-1}$ — перенос из предыдущего разряда.

- Вычитание (SUB): через сложение инверсии второго операнда с единицей (дополнительный код).
  
  $A - B = A + (\lnot B + 1)$

- Инкремент/декремент: прибавление или вычитание единицы.
- Операции с переносом: включение внешнего или внутреннего сигнала переноса.

*Особенности*
- Операции требуют сложения с учётом переноса между разрядами, что замедляет процесс по сравнению с логическими функциями, но необходимо для корректных вычислений;
- Арифметические операции влияют на флаги переполнения, знака, нуля и переноса в процессорных архитектурах;
- Комплексность реализации: требуется цепь переноса (carry chain), которая может быть реализована либо последовательно, либо с ускорением.

##### 2.2.1.4 Логический блок

*Назначение:* 

В логическом режиме АЛУ воспринимает входные данные не как числа, а как набор битов. Операции выполняются над каждым разрядом по отдельности, без учёта переноса между ними.

*Функции:*
- логическое И (AND): результат бита будет 1, только если оба соответствующих входных бита равны 1.  
  
    $S_i = A_i \land B_i$

- логическое ИЛИ (OR): результат будет 1, если хотя бы один из битов равен 1.

    $S_i = A_i \lor B_i$
 
- исключающее ИЛИ (XOR): результат будет 1, если биты на входах различаются.
    
    $S_i = A_i \oplus B_i$
 
- Инверсия (NOT): побитово меняет все 0 на 1 и наоборот.
    
   $S_i = \lnot A_i$
 
Кроме базовых логических операций, современные АЛУ  поддерживают комбинации:
- НЕ-И (NAND): инверсия результата AND;
- НЕ-ИЛИ (NOR): инверсия результата OR;
- эквиваленция (XNOR) — инверсия XOR; результат 1, если биты совпадают.

*Особенности*:
- Отсутствие переноса и переполнения, поскольку операции выполняются независимо по битам;  
- Параллелизм операций: каждая пара битов обрабатывается одновременно, что обеспечивает высокую скорость операций;  
- Побитовые операции применяются для реализации мультиплексоров, дешифраторов, флагов состояния и сложных управляющих схем.

##### 2.2.1.5 Блок сдвигов (шифратор/дешифратор сдвигов)

*Назначение:* 

Выполняет сдвиги или циклические вращения битов.

*Типы сдвигов:*
- Логический сдвиг влево/вправо: заполнение нулями.
- Арифметический сдвиг: сохранение знака (бит знака остаётся постоянным).
- Циклический сдвиг (rotate): перенос крайних битов с одного конца на другой.
- Сдвиг с переносом: перенос выходит в флаг, используется в криптографии и умножении.

*Особенности:*
- Используются мультиплексоры, маски и триггерные схемы.
- Часто реализуется отдельной микросхемой (например, в классических компьютерах), но может быть встроен в АЛУ.

##### 2.2.1.6 Схема генерации и распространения переноса (Carry Lookahead Generator)

*Назначение:* 

Обеспечивает быстрое вычисление переносов при сложении, устраняя необходимость последовательного распространения сигнала.

*Функции:*
- Вычисляет сигналы $G_i$ и $P_i$.
- Формирует $C_{i+1}$ напрямую, например:
  
  $C_1 = G_0 + P_0 \cdot C_0$
  $C_2 = G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot C_0$
- Повышает производительность многобитных операций.

##### 2.2.1.7 Схема флагов состояния (статусный регистр)

*Назначение:* 

Регистрирует и сохраняет информацию о результатах последней операции для последующего использования в логике управления (например, условные переходы).

*Основные флаги:*
- Zero (нулевой результат),
- Sign (знак результата),
- Carry (перенос или заём),
- Overflow (переполнение),
- Parity (чётность/нечётность).

*Применение:*
- Используются для принятия решений в условных переходах, циклах, обработке исключений.

##### 2.2.1.8 Выходной регистр (или шина результата)

*Назначение:*

Хранит результат выполнения операции до его передачи в регистровый файл, память или другую часть системы.

*Особенности:*
- Может иметь буферизацию (триггеры, защита от изменения при следующей тактовой операции);
- Часто подключён к внутренней или общей шине данных процессора.

##### 2.2.1.9 Мультиплексоры и линии выбора

*Назначение:*

Обеспечивают маршрутизацию данных и управляющих сигналов внутри АЛУ.

*Функция:*
- Выбор операнда из нескольких возможных источников;
- Выбор результата из арифметического, логического или сдвигового блоков;
- Коммутация внутренних шин.

#### 2.2.2 Пример АЛУ 74181
Микросхема 74181 представляет собой 4-разрядное арифметико-логическое устройство (АЛУ), способное выполнять 16 логических и 16 арифметических операций над двумя 4-битными словами. 

Ключевой особенностью 74181 является использование схемы ускоренного переноса (carry-lookahead).

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74181.png?raw=true)
Рисунок 3 - АЛУ 74181

Назначение входов/выходов микросхемы: 
- $A_{0} - A_{3}$ и $B_{0} - B_{3}$ - четырёхразрядные двоичные суммируемые операнды; 
- $S_{0} - S_{3}$ - четыре входа выбора позволяют выбрать одну из 16 возможных функций, в зависимости от состояния сигнала на линии $M$ (Mode Control) ($M = 0$ - арифметические операции над прямым кодом операндов $А$ и $В$ при $С = 1$; $M = 1$ - логические операции над прямым кодом операндов); 
- $F_{0} - F_{3}$ - 4-битный результат выбранной операции; 
- $P$, $G$ - выходы подключения к блоку ускоренного переноса при каскадировании; 
- $(А = В)$ = бинарный признак равенства операндов в операции сравнения; 
- $C_{n}$ (Carry In), $C_{n+4}$ - входной и выходной признаки переноса. Если операция даёт перенос, то он появляется на выходе $C_{n+4}$. Этот перенос можно передавать в следующую микросхему, если нужно работать с числами больше 4 бит;
- $G$, $P$ - сигналы генерации и распространения переноса

*Таблица команд*
| Код $S$  | Арифметическая операция $(M=0,\ C_{0}=1)$          | Арифметическая операция $(M=0,\ C_{0}=0)$          | Логическая операция $(M=1)$              |
|----------|----------------------------------------------------|----------------------------------------------------|-------------------------------------------|
| 0000     | $A$                                                | $A + 1$                                            | $\lnot A$                                  |
| 0001     | $A \lor B$                                         | $\lnot (A \lor B)$                                | $\text{NOT}(A \lor B)$                     |
| 0010     | $A \lor \lnot B$                                   | $\lnot A \land B$                                 | $\lnot A \lor B$                           |
| 0011     | $0$                                                | $0$                                               | $0$                                       |
| 0100     | $A + (A \land \lnot B)$                            | $\lnot (A \land B)$                               | $\text{NOT}(A \land B)$                    |
| 0101     | $(A \land B) + (A \lor B)$                         | $\lnot B$                                         | $\lnot B$                                  |
| 0110     | $A - B - 1$                                        | $A - B$                                           | $A \oplus B$                               |
| 0111     | $(A \land \lnot B) - 1$                            | $A \land \lnot B$                                 | $A \land \lnot B$                          |
| 1000     | $A + (A \land B)$                                  | $\lnot A \lor B$                                  | $\lnot A \lor B$                           |
| 1001     | $A + B$                                            | $A + B + 1$                                       | $\lnot (A \oplus B)$                       |
| 1010     | $(A \land B) + (A \lor \lnot B)$                   | $B$                                               | $B$                                       |
| 1011     | $(A \land B) - 1$                                  | $A \land B$                                       | $A \land B$                                |
| 1100     | $A + A$                                            | $A + A + 1$                                       | $1$                                       |
| 1101     | $A + (A \lor B)$                                   | $A \lor \lnot B$                                  | $A \lor \lnot B$                           |
| 1110     | $A + (A \lor \lnot B)$                             | $A \lor B$                                        | $A \lor B$                                 |
| 1111     | $A - 1$                                            | $A$                                               | $A$                                       |

Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​


### 2.3 Способы повышения разрядности цифровых операционных устройства
Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​

#### 2.3.1 Микросхема 4-разрядного ускоренного переноса — 74182

Микросхема 74182 представляет собой логический блок ускоренного (look-ahead) переноса, предназначенный для совместной работы с несколькими 4-разрядными арифметико-логическими устройствами (в частности, с микросхемами 74181). В отличие от АЛУ, 74182 не выполняет арифметических или логических операций самостоятельно, а обеспечивает быструю и согласованную обработку сигналов переноса между несколькими АЛУ-блоками, входящими в состав более широких вычислительных устройств.

Основное назначение микросхемы 74182 заключается в устранении задержек, возникающих при последовательной передаче переноса между каскадированными 74181. Используя логическую комбинацию входных сигналов генерации и распространения переноса от нескольких АЛУ-блоков, 74182 формирует выходные сигналы переноса для каждого последующего 4-битного блока. Это позволяет существенно сократить общее время выполнения арифметических операций, особенно при работе с 8-битными, 16-битными и более широкими шинами данных.

Микросхема 74182 поддерживает каскадирование до четырёх 4-разрядных блоков 74181, эффективно обеспечивая ускоренный перенос между ними. При этом начальный перенос (например, при сложении с переносом) подаётся на вход микросхемы, а выходные сигналы $C_1$, $C_2$, $C_3$,$C_4$  направляются соответственно на входы переноса блоков 74181 старших разрядов. Это исключает необходимость последовательного распространения переноса от одного блока к другому, которое увеличивало бы задержку пропорционально числу каскадов.

Назначение входов/выходов микросхемы:

- $P_0 – P_3$ — входы распространения переноса от четырёх 4-разрядных ALU-блоков (обычно 74181); определяют, может ли каждый блок пропустить входной перенос на следующий.
- $G_0 – G_3$ — входы генерации переноса от тех же ALU-блоков; сигнализируют, что соответствующий блок обязательно сгенерирует перенос независимо от входного переноса.
- $C_n$ — входной перенос в младший блок; задаёт начальный перенос всей группы (например, при сложении с учётом начального переноса).
- $C_1 – C_3$ — выходы переноса для подачи на входы переноса соответствующих 74181, отвечающих за старшие биты.
- $C_4$ — окончательный выходной перенос всей каскадированной ALU; может быть использован в качестве флага переполнения или входа следующей группы ALU.
- $PG$ (Propagate Group) — групповой сигнал распространения переноса, указывающий, может ли вся каскадированная группа 74181 передать входной перенос вперёд без его генерации.
- $GG$ (Generate Group) — групповой сигнал генерации переноса, свидетельствующий о том, что в пределах каскада перенос обязательно будет сгенерирован, независимо от входного переноса.

![alt](/Lab_2/Lab_2_theory/Images/screnshots/АЛУ_74181_74182.png)
Рисунок 4 - Каскадирование АЛУ 74181 за чсет CLA 74182

#### 2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882

Микросхема 74882 — это специализированный блок ускоренного переноса, предназначенный для использования в составе высокоразрядных АЛУ. Она не является самостоятельным АЛУ, как 74181, а служит в качестве расширителя CLA-схемы, обеспечивая обработку переноса между группами по 4 бита, в общей сложности — до 32 разрядов.

Использование 74882 позволяет значительно сократить время выполнения операций сложения и вычитания за счёт параллельной обработки переносов между группами разрядов. Это особенно важно в системах, требующих высокой производительности, таких как процессоры и цифровые сигнальные процессоры.

Назначение входов/выходов микросхемы:
- $P_{0} – P_{7}$ – входы распространения переноса от восьми 4-битных арифметических блоков (например, от микросхем 74181); указывают, способен ли каждый блок передать перенос дальше при его наличии.
- $G_{0} – G_{7}$ – входы генерации переноса от тех же восьми 4-битных блоков; сигнализируют о том, что соответствующий блок обязательно создаёт перенос независимо от входного значения переноса.
- $C_{n}$ – вход переноса в первый (младший) 4-битный блок; используется как начальный перенос в цепи.
- $C_{1} – C_{7}$ – выходы переноса для последующих 4-битных блоков; формируют сигналы переноса, поступающие на следующий каскад микросхем 74181.

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/CLA_74882.png)

## 3 Сведения о лабораторном оборудовании
### 3.1 Микросхема 4-разрядного АЛУ — 74181

*Алгоритм работы*
1. В симуляторе Digital откройте или собрите проект стенда с микросхемой 74181.
2. Установите значения операндов $A$ и $B$, переключив соответствующие входы ($A_{3} – A_{0}, B_{3} – B_{0}$) в интерфейсе симулятора.
3. Задате код операции, переключив тетраду входов $S_3 – $S-0$ согласно таблице функций и установите вход $M$ для выбора типа операции ($M = 0$ — арифметика, $M = 1$ — логика).
4. Активируйте входной перенос $C_{0}$ (обычно устанавливается в 1 для операций сложения).
5. Проанализируйте результат на выходах $F_{3} – F_{0}$, а также сигналы состояния ($C_{4}$, $P$, $G$, $A$ $=$ $B$).      |

*Пример*

Рассмотрим выполнение арифметической операции сложения двух четырёхразрядных чисел. Пусть $A = 0101 (5), B = 0011 (3)$.
На входы микросхемы в симуляторе устанавливаются:

$A_{3} = 0, A-{2} = 1, A_{1} = 0, A_{0} = 1$

$B_{3} = 0, B_{2} = 0, B_{1} = 1, B_{0} = 1$
 
Для операции сложения с учётом переноса выбирается код $S_{3} – S_{0} = 0001$ (см. Таблицу команд).

Устанавливается:

$M = 0$ (арифметическая операция)

$C_{0} = 1$  (входной перенос)

В результате на выходе:

$F_{3} – F_{0} = 1001 (9)$, 

так как 5 + 3 + 1 = 9

$C_{4} = 0$ (переполнения нет).

![alt](/Lab_2/Lab_2_theory/Images/screnshots/example_74181.png)
Рисунок 5 - Пример работу АЛУ 74181

### 3.2 Микросхема 4-разрядного ускоренного переноса — 74182

*Алгоритм работы*

1. В симуляторе Digital откройте или соберите схему, включающую две микросхемы 74181 и одну микросхему 74182, соединённые по каскадной схеме для реализации 8-битной ALU с ускоренным переносом.

2. Подайте на входы $A$ и $B$ два восьмиразрядных операнда. Разделите их на две тетрады:
   - Младшие биты ($A_0$–$A_3$, $B_0$–$B_3$) подключите к первой 74181.
   - Старшие биты ($A_4$–$A_7$, $B_4$–$B_7$) — ко второй 74181.

3. Установите управляющий код операции с помощью сигналов $S_3$–$S_0$, подключённых параллельно к обеим микросхемам 74181. Установите значение сигнала $M$:
   - $M = 0$ — арифметическая операция;
   - $M = 1$ — логическая операция.

4. Установите начальный входной перенос $C_0 = 1$, подав его на вход микросхемы 74182.

5. Подключите сигналы $P$ и $G$ от каждой из 74181 к соответствующим входам $P_0$, $P_1$, $G_0$, $G_1$ микросхемы 74182.

6. Получите выходные сигналы переноса $C_1$, $C_2$ и т. д. с 74182:
   - $C_1$ подключите к входу переноса второй (старшей) 74181.
   - $C_4$ (итоговый перенос всей ALU) используйте по необходимости.

7. Проанализируйте результат:
   - На выходах $F_3$–$F_0$ первой и $F_3$–$F_0$ второй 74181 (итоговый 8-битный результат).
   - По сигналам переноса $C_4$, а также $P$ и $G$ при необходимости для последующего каскадирования.

*Пример*

Рассмотрим выполнение операции сложения двух 8-битных чисел:  
$A = 01010101$ (85), $B = 00110011$ (51), входной перенос $C_0 = 1$.

Разделим операнды на младшие и старшие тетрады и подадим в симулятор:

Для первой (младшей) 74181:

$A_3 = 0$, $A_2 = 1$, $A_1 = 0$, $A_0 = 1$ → $A_{\text{low}} = 0101$

$B_3 = 0$, $B_2 = 0$, $B_1 = 1$, $B_0 = 1$ → $B_{\text{low}} = 0011$

Для второй (старшей) 74181:

$A_7 = 0$, $A_6 = 1$, $A_5 = 0$, $A_4 = 1$ → $A_{\text{high}} = 0101$

$B_7 = 0$, $B_6 = 0$, $B_5 = 1$, $B_4 = 1$ → $B_{\text{high}} = 0011$

Управляющие сигналы:

$S_3$–$S_0 = 0001$ (код сложения)  
$M = 0$ (арифметическая операция)  
$C_0 = 1$ (начальный перенос)

Микросхема 74182 получает:

- $G_0$, $P_0$ от первой 74181  
- $G_1$, $P_1$ от второй 74181  
- $C_0 = 1$ (входной перенос)

На основании этих данных 74182 рассчитывает и подаёт:

- $C_1$ → на вход переноса второй 74181  
- $C_4$ → итоговый перенос всей 8-битной ALU

Результат:

- Первая 74181: $F = 0101 + 0011 + 1 = 1001$ → $F_3$–$F_0 = 1001$
- Вторая 74181 с учётом переноса: $F = 0101 + 0011 + 1 = 1001$ → $F_7$–$F_4 = 1001$

**Итоговый результат:**

$F_7$–$F_0 = 10011001$ (в двоичной форме) = **153** (в десятичной форме)

$C_4 = 0$ — переполнения нет.

![alt] 
Рисунок 6 — Пример работы 4-разрядного ускоренного переноса — 74182

#### 3.3 Микросхема 32-разрядного ускоренного переноса - 74882

*Алгоритм работы*

1. В симуляторе Digital откройте схему, включающую 4 микросхемы 74181 и одну 74882.
2. Установите значения операндов A и B для каждой микросхемы, переключив соответствующие входы ($A_{3} – A_{0}, B_{3} – B_{0}$) в интерфейсе симулятора.
3. Получите сигналы $G$ и $P$ с каждой  ALU 74181 и подайте их на 74882.
4. Активируйте входной перенос $C_{0}$.
5. Проанализируйте выходы $C_{1} – C_{4}$, которые подаются на следующие по старшинству микросхемы.

Пример микросхемы  32-разрядного ускоренного переноса - 74882.
![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/CLA_74882_ALU-32.png?raw=true)

На русунке:

- $PG$ (Group Propagate) – групповой сигнал распространения переноса; означает, что весь 32-битный блок способен передать входной перенос от начала до конца без генерации своего.

- $GG$ (Group Generate) – групповой сигнал генерации переноса; означает, что весь 32-битный блок сам формирует перенос независимо от входного сигнала $C_{n}$.

*Пример*

Устанавливается значения входных сигналов $G_{7} – G_{0}$ и $P_{7} – P_{0}$ на основе результатов работы 74181. Ввод $C_{0} = 1$ инициирует вычисление всех Cn.Выходы $C_{1} – C_{4}$ подаются в $C_{0}$ следующих микросхем.

<!-- Это придется адаптировать под нашу лабу. Пока не читал -->

<!--

## 4. Описание Verilator

[Lab2_2](./theory/verilator/Lab2.2.md)

## 4.1 Описание работы виртуального стенда 8 разрядного АЛУ на виртуальной плате DE10-Lite (+ листинг код Verilog)

[ALU_8b](./theory/virtual_fpga_boards-stand_ALU_8b/README.md)

## 4.2 Описание работы виртуальный стенд 16 разрядного АЛУ на виртуальной плате DE2-115 (+ листинг код Verilog)

[ALU_16b](./theory/virtual_fpga_boards-stand_ALU_16b/README.md)

-->