- [1. Цели и ход работы](#1-цели-и-ход-работы)
- [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
  - [2.1 Сумматоры](#21-сумматоры)
    - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
    - [2.1.2 Сумматоры с параллельным ускоренным переносом CLA](#212-сумматоры-с-параллельным-ускоренным-переносом-cla)
  - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
    - [2.2.1 Теоретические сведения  ](#221-теоретические-сведения--)
    - [2.2.1 Функциональные модули АЛУ](#221-функциональные-модули-алу)
      - [2.2.1.1 Входные регистры](#2211-входные-регистры)
      - [2.2.1.2 Управляющий модуль (декодер операций)](#2212-управляющий-модуль-декодер-операций)
      - [2.2.1.3 Арифметический блок](#2213-арифметический-блок)
      - [2.2.1.4 Логический блок](#2214-логический-блок)
      - [2.2.1.5 Блок сдвигов (шифратор/дешифратор сдвигов)](#2215-блок-сдвигов-шифратордешифратор-сдвигов)
      - [2.2.1.6 Схема генерации и распространения переноса (Carry Lookahead Generator)](#2216-схема-генерации-и-распространения-переноса-carry-lookahead-generator)
      - [2.2.1.7 Схема флагов состояния (статусный регистр)](#2217-схема-флагов-состояния-статусный-регистр)
      - [2.2.1.8 Выходной регистр (или шина результата)](#2218-выходной-регистр-или-шина-результата)
      - [2.2.1.9 Мультиплексоры и линии выбора](#2219-мультиплексоры-и-линии-выбора)
    - [2.2.2 Пример АЛУ 74181](#222-пример-алу-74181)
  - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
    - [2.3.1 Микросхема 4-разрядного ускоренного переноса — 74182](#231-микросхема-4-разрядного-ускоренного-переноса--74182)
    - [2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#232-микросхема-32-разрядного-ускоренного-переноса---74882)
- [3 Сведения о лабораторном оборудовании](#3-сведения-о-лабораторном-оборудовании)
  - [3.1 Микросхема 4-разрядного АЛУ — 74181](#31-микросхема-4-разрядного-алу--74181)
  - [3.2 Микросхема 4-разрядного ускоренного переноса — 74182](#32-микросхема-4-разрядного-ускоренного-переноса--74182)
    - [3.3 Микросхема 32-разрядного ускоренного переноса - 74882](#33-микросхема-32-разрядного-ускоренного-переноса---74882)
- [4. Описание Verilator](#4-описание-verilator)
  - [4.1 Описание Verilator](#41-описание-verilator)
    - [4.1.1 Достоинства Verilator](#411-достоинства-verilator)
      - [4.1.1.1 Скорость](#4111-скорость)
      - [4.1.1.2 Качество кода](#4112-качество-кода)
      - [4.1.1.3 Стоимость](#4113-стоимость)
    - [4.1.2 Начало работы](#412-начало-работы)
    - [4.1.3 Создание DUT](#413-создание-dut)
    - [4.1.4 Преобразование SystemVerilog в C++](#414-преобразование-systemverilog-в-c)
      - [4.1.4.1 Верификация с помощью Verilator](#4141-верификация-с-помощью-verilator)
      - [4.1.4.2 Результаты преобразования](#4142-результаты-преобразования)
    - [4.1.5 Разработка базового тестбенча для Verilator](#415-разработка-базового-тестбенча-для-verilator)
      - [4.1.5.1 Пример тестбенча на C++](#4151-пример-тестбенча-на-c)
      - [4.1.5.2 Сборка исполняемого файла симуляции](#4152-сборка-исполняемого-файла-симуляции)
      - [4.1.5.2 Запуск тестбенча](#4152-запуск-тестбенча)
      - [4.1.5.3 Просмотр временных диаграмм Verilator](#4153-просмотр-временных-диаграмм-verilator)
      - [4.1.6 Наблюдения](#416-наблюдения)
  - [4.2. Основы верификации SystemVerilog с использованием C++](#42-основы-верификации-systemverilog-с-использованием-c)
    - [4.2.1 Использование Make](#421-использование-make)
    - [4.2.2 Случайные начальные значения](#422-случайные-начальные-значения)
    - [4.2.3 Сброс DUT](#423-сброс-dut)
    - [4.2.4 Базовая верификация](#424-базовая-верификация)
      - [4.2.4.1 Счётчик фронтов тактового сигнала](#4241-счётчик-фронтов-тактового-сигнала)
      - [4.2.4.2 Примитивные стимулы и проверки для DUT](#4242-примитивные-стимулы-и-проверки-для-dut)
    - [4.2.5 Мониторинг сигналов утверждений (assertions)](#425-мониторинг-сигналов-утверждений-assertions)
    - [4.2.6 Генерация случайного valid сигнала](#426-генерация-случайного-valid-сигнала)
    - [4.2.7 Готовый тестбенч](#427-готовый-тестбенч)
  - [4.3. Традиционный пример верефикации](#43-традиционный-пример-верефикации)
    - [4.3.1 Создание typedef ```operation_t``` доступным в тестбенче на C++](#431-создание-typedef-operation_t-доступным-в-тестбенче-на-c)
    - [4.3.2 Пример традиционной (временной) верификации](#432-пример-традиционной-временной-верификации)
      - [4.3.2.1 Временные стимулы](#4321-временные-стимулы)
      - [4.3.2.2 Проверка результатов по времени](#4322-проверка-результатов-по-времени)
    - [4.3.3 Подведение временных итогов](#433-подведение-временных-итогов)
- [4.4. Современный транзакционный (UVM) стиль тестбенча на C++](#44-современный-транзакционный-uvm-стиль-тестбенча-на-c)
  - [4.4.1 Определение транзакционного тестбенча?](#441-определение-транзакционного-тестбенча)
    - [4.4.2 Рандомизированные транзакционные (в UVM стиле) тестбенчи на чистом C++ с Verilator](#442-рандомизированные-транзакционные-в-uvm-стиле-тестбенчи-на-чистом-c-с-verilator)
    - [4.4.3 Базовая блок-схема транзакционного тестбенча](#443-базовая-блок-схема-транзакционного-тестбенча)
      - [4.4.3.1 Транзакция и элемент транзакции](#4431-транзакция-и-элемент-транзакции)
      - [4.4.3.2 Генератор транзакций](#4432-генератор-транзакций)
      - [4.4.3.3 Драйвер](#4433-драйвер)
      - [4.4.3.4 Интерфейс](#4434-интерфейс)
      - [4.4.3.5 Монитор](#4435-монитор)
      - [4.4.3.6 Табло](#4436-табло)
    - [4.4.4 Структура и компоненты транзакционного тестбенча для АЛУ](#444-структура-и-компоненты-транзакционного-тестбенча-для-алу)
      - [4.4.4.1 Элемент транзакции AluInTx](#4441-элемент-транзакции-aluintx)
      - [4.4.4.2 Генератор элементов транзакции rndAluInTx](#4442-генератор-элементов-транзакции-rndaluintx)
      - [4.4.4.3 Драйвер интерфейса ввода AluInDrv](#4443-драйвер-интерфейса-ввода-aluindrv)
      - [4.4.4.4 Монитор входного интерфейса AluInMon](#4444-монитор-входного-интерфейса-aluinmon)
      - [4.4.4.5 Элемент транзакции AluOutTx](#4445-элемент-транзакции-aluouttx)
      - [4.4.4.6 Монитор выходного интерфейса AluOutMon](#4446-монитор-выходного-интерфейса-aluoutmon)
      - [4.4.4.7 Табло AluScb](#4447-табло-aluscb)
    - [4.4.5 Сборфункционала воедино](#445-сборфункционала-воедино)
    - [4.4.6 Симуляция](#446-симуляция)
    - [4.4.7 Плохие результаты АЛУ](#447-плохие-результаты-алу)
    - [4.4.8 Неожиданный out\_valid в АЛУ](#448-неожиданный-out_valid-в-алу)
    - [4.4.9 Графическое представление](#449-графическое-представление)
- [5. Описание работы виртуального стенда 8 разрядного АЛУ на виртуальной плате DE10-Lite](#5-описание-работы-виртуального-стенда-8-разрядного-алу-на-виртуальной-плате-de10-lite)
  - [5.1 Описание проекта](#51-описание-проекта)
  - [5.2 Основные возможности](#52-основные-возможности)
  - [5.3 Требования](#53-требования)
    - [5.3.1 Для графического клиента](#531-для-графического-клиента)
    - [5.3.2 Для Verilog сервера](#532-для-verilog-сервера)
  - [5.4 Установка](#54-установка)
  - [5.5 Использование](#55-использование)
- [5.6 Запуск через Makefile](#56-запуск-через-makefile)
- [5.7 Запуск графического клиента](#57-запуск-графического-клиента)
- [5.8 Файл конфигурации](#58-файл-конфигурации)
- [5.9 Запуск сервера](#59-запуск-сервера)
  - [5.9.1 Функционал графического интерфейса](#591-функционал-графического-интерфейса)
  - [5.9.2 Makefile](#592-makefile)
  - [5.9.3 Таблица сигналов](#593-таблица-сигналов)
- [6. Описание работы виртуальный стенд 16 разрядного АЛУ на виртуальной плате DE2-115 (+ листинг код Verilog)](#6-описание-работы-виртуальный-стенд-16-разрядного-алу-на-виртуальной-плате-de2-115--листинг-код-verilog)
  - [6.1 Описание проекта](#61-описание-проекта)
  - [6.2 Основные возможности](#62-основные-возможности)
  - [6.3 Требования](#63-требования)
    - [6.3.1 Для графического клиента](#631-для-графического-клиента)
    - [6.3.2 Для сервера](#632-для-сервера)
  - [6.4 Установка](#64-установка)
  - [6.5 Использование](#65-использование)
  - [6.6  Запуск через Makefile](#66--запуск-через-makefile)
  - [6.7 Запуск графического клиента](#67-запуск-графического-клиента)
  - [6.8 Файл конфигурации](#68-файл-конфигурации)
  - [6.9 Запуск сервера](#69-запуск-сервера)
    - [6.9.1 Функционал графического интерфейса](#691-функционал-графического-интерфейса)
    - [6.9.2 Makefile](#692-makefile)
  - [6.10 Таблица сигналов](#610-таблица-сигналов)


## 1. Цели и ход работы 
Целью данной лабораторной работы является изучение и экспериментальное исследование арифметико-логических устройств (АЛУ) и блоков ускоренного переноса (CLA), их структуры, принципов работы и способов организации многобитных вычислений.

## 2. Цифровые операционные устройства
Операционные устройства (ОУ) выполняют операции преобразования информационных сообщений, которые по функциональному назначению могут быть данными, адресами и (в особых исполнениях) командами.  
Неизбежным является оперативное сохранение сообщений при их подготовке к обработке, в процессе обработки и по получению и применению результата обработки.  
Последовательность переходов между этапами подготовки, сохранения и преобразования данных определяется сигналами устройств управления.  

К цифровым операционным устройствам относятся __сумматоры__ (сумматоры-вычитетели) и __арифметико-логические устройства__.  

### 2.1 Сумматоры
Сумматоры — это цифровые операционные устройства, предназначенные для выполнения операции сложения двоичных чисел. Они являются фундаментальными элементами арифметико-логических устройств современных процессоров, цифровых сигнальных процессоров (DSP) и вычислительных ядер. Схемотехнически сумматоры представляют собой комбинационные логические схемы, которые реализуют булевы функции сложения по модулю два (сложение без учета переноса) и операции переноса разряда.

Алгоритм двоичного сложения является базовой арифметической операцией, на которой строится работа всех цифровых вычислительных систем. Принцип сложения двоичных чисел аналогичен сложению десятичных чисел, но с учётом особенностей двоичной системы счисления, где допустимы только два значения: 0 и 1.

Для сложения двух одноразрядных двоичных чисел $A$ и $B$ с учётом входного переноса $C_{in}$ используется следующая таблица истинности:

| $A$ | $B$ | $C_{in}$ | Сумма $(S)$| Перенос $(C_{out})$ |
| - | - | -------- | --------- | ------------------- |
| 0 | 0 | 0        | 0         | 0                   |
| 0 | 0 | 1        | 1         | 0                   |
| 0 | 1 | 0        | 1         | 0                   |
| 0 | 1 | 1        | 0         | 1                   |
| 1 | 0 | 0        | 1         | 0                   |
| 1 | 0 | 1        | 0         | 1                   |
| 1 | 1 | 0        | 0         | 1                   |
| 1 | 1 | 1        | 1         | 1                   |

Отсюда формируются логические выражения:

Сумма:

$S = A ⊕ B ⊕ C_{in}$

Перенос:

$C_{out} = (A ⋅ B) + (C_{in} ⋅ (A ⊕ B))$

*Классификация сумматоров*

Сумматоры можно классифицировать по нескольким признакам, исходя из особенностей их построения и схемных решений. Основные типы классификации следующие:

1. По числу входных разрядов:
   - __Одноразрядные:__
      - Полусумматоры (складывают два числа без учёта переноса);
      - Полные сумматоры (складывают два числа с учётом входного переноса).

   - __Многоразрядные:__
        Сложение выполняется по алгоритму последовательного или ускоренного переноса.

2. По способу переноса:
   - __Сумматоры с последовательным переносом (Ripple Carry Adder, RCA)__:
     Перенос передаётся последовательно от младшего разряда к старшему. Простая структура, но большая задержка при увеличении разрядности.
   - __Сумматоры с ускоренным переносом (Carry Look-Ahead Adder, CLA):__
     Переносы вычисляются заранее с использованием функций генерации и распространения переноса. Существенно меньшая задержка по сравнению с RCA.
   - __Сумматоры с прогнозированием переноса (Carry Select Adder, CSA):__
     Число разбивается на блоки, и сложение в блоках выполняется параллельно для двух вариантов переноса (0 и 1), после чего выбирается правильный результат. Компромисс между быстродействием и сложностью схемы.
   - __Сумматоры с сщхранением переносом (Carry Skip Adder, CSA):__
     Используют специальные схемы пропуска переноса через группы разрядов, что сокращает задержку.
   - __Иерархические (многоуровневые) сумматоры:__
     Строятся с применением многоуровневых схем ускоренного переноса. Хорошо масштабируются для больших разрядностей (например, 32, 64 и более бит).

3. По скорости работы:
   - __Медленные__ (например, RCA) — линейная зависимость задержки от разрядности.
   - __Ускоренные__ (CLA, CSA, CSA) — задержка растёт логарифмически или квазилогарифмически от числа разрядов.


#### 2.1.1 Сумматоры с последовательным переносом
Сумматоры с последовательным переносом представляют собой наиболее простую и базовую реализацию многоразрядных сумматоров в цифровой логике. Они получили широкое распространение в схемах малой и средней разрядности, где важны минимальные затраты по логическим элементам и простота проектирования.

*Структура и принцип работы*

Многоразрядный сумматор с последовательным переносом строится из цепочки полных сумматоров, где каждый следующий сумматор принимает на вход перенос из предыдущего разряда. Это создаёт линейную зависимость времени задержки по числу разрядов.

![alt text](/Lab_2/Lab_2_theory/Images/screnshots/RCA.png)

Рисунок 1 - Сумматор с последовательным переносом

Рисунок 1 иллюстрирует структуру многоразрядного сумматора с последовательным переносом, где:

$A_{i}$, $B_{i}$ — биты слагаемых чисел в i-м разряде,  
$С_{i}$ — перенос, поступающий с предыдущего разряда,  
$S_{i}$ — сумма в текущем разряде,  
$C_{i+1}$  — перенос на следующий разряд.

На схеме показано, как несколько однобитовых сумматоров соединены последовательно. Каждый блок в схеме — это однобитовый полный сумматор (Full Adder). 

Формально, для i-го разряда суммирование определяется следующими логическими выражениями:

$S = A_{i} ⊕ B_{i} ⊕ C_{i}$  
$C_{i} = (A_{i} ⋅ B_{i}) + (C_{in} ⋅ (A_{i} ⊕ B_{i}))$  

где:

⊕ — операция исключающего ИЛИ (XOR),

⋅ — логическое И (AND),

$+$ — логическое ИЛИ (OR).

Сигнал переноса передаётся последовательно от одного сумматора к другому:
- Первый сумматор принимает начальный перенос $C_{0}$ = 0.
- Каждый следующий сумматор использует выходной перенос предыдущего как свой входной.

Таким образом, сигнал переноса "протекает" по цепочке от младшего разряда к старшему.  Именно задержка распространения переноса $C_{i+1}$ по цепочке полных сумматоров и определяет суммарное время отклика всего сумматора. Каждый перенос должен быть вычислен до того, как следующий разряд сможет начать работу, что и образует последовательный характер выполнения сложения.

*Преимущества и недостатки*

Преимущества:  
- Простейшая архитектура, хорошо поддающаяся ручному и автоматизированному преобразованию;  
- Минимальные аппаратные затраты;  
- Хорошо подходит для реализации в программируемых логических интегральных схемах (ПЛИС) с ограниченными ресурсами.  

Недостатки:  
- Линейная задержка при увеличении разрядности;  
- Неэффективность при работе на высоких частотах и больших разрядностях;  
- Склонность к накоплению ошибок тайминга при длинных цепочках переноса.

#### 2.1.2 Сумматоры с параллельным ускоренным переносом CLA

Сумматоры с ускоренным переносом были разработаны как ответ на главный недостаток RCA — последовательную задержку переноса. Архитектура CLA позволяет вычислять переносы параллельно для всех разрядов, что существенно ускоряет процесс сложения и уменьшает общую задержку схемы до логарифмической зависимости от разрядности.

![alt text](/Lab_2/Lab_2_theory/Images/screnshots/СLA.png)

Рисунок 2 - Сумматор с параллельным ускоренным переносом

*Структура и принцип работы*

Суть ускоренного суммирования заключается в том, чтобы заранее вычислить сигналы переноса на основе входных битов, а не ждать их распространения по цепочке. Для этого вводятся две ключевые логические функции:

- Сигнал генерации переноса $G_i$ (Generate):  
  $G_i = A_i \cdot B_i$
  Этот сигнал означает, что текущая пара битов $A_i$ и $B_i$ непосредственно генерирует перенос, независимо от переноса с предыдущего разряда.

- Сигнал распространения переноса $P_i$ (Propagate):  
  $P_i = A_i \oplus B_i$
  Этот сигнал указывает на то, что разряд $i$ пропускает перенос, если он поступает от младшего разряда.

Общий сигнал переноса для разряда $i+1$ может быть выражен через сигналы $G_i$, $P_i$ и входной перенос $C_i$:

$C_{i+1} = G_i + (P_i \cdot C_i)$

Это рекурсивное выражение позволяет построить полную схему переноса, избегая последовательного распространения.

Для 4-разрядного CLA выражения будут следующими:

- $C_1 = G_0 + P_0 \cdot C_0$
- $C_2 = G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot C_0$
- $C_3 = G_2 + P_2 \cdot G_1 + P_2 \cdot P_1 \cdot G_0 + P_2 \cdot P_1 \cdot P_0 \cdot C_0$
- $C_4 = G_3 + P_3 \cdot G_2 + P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot G_0 + P_3 \cdot P_2 \cdot P_1 \cdot P_0 \cdot C_0$

Таким образом, каждый перенос вычисляется параллельно, без необходимости дожидаться результата предыдущего разряда.

Сумма для каждого разряда $S_i$ находится по стандартной формуле:

$S_i = P_i \oplus C_i = (A_i \oplus B_i) \oplus C_i$


<!-- Как эти сигналы P & G порождаются ??  -->
<!-- Зачем P & G нужны ?  -->
https://www.righto.com/2017/03/inside-vintage-74181-alu-chip-how-it.html#:~:text=Creating%20P%20and%20G%20with%20an%20arbitrary%20Boolean%20function

*Преимущества и недостатки*

Преимущества:

- Существенно более высокая скорость по сравнению с RCA, особенно на больших разрядностях;  
- Параллельная обработка переносов сокращает путь задержки;  
- Хорошо масштабируется для процессоров с 32, 64 и более битами данных.  

Недостатки:

- Увеличение числа логических элементов и более сложная логическая схема;  
- Повышенное потребление энергии;  
- Большая площадь кристалла при реализации в интегральных схемах (ASIC).  
  
### 2.2 Арифметико - логическое устройство  
#### 2.2.1 Теоретические сведения  <!--  Где теоретическое описание ? -->

Арифметико-логическое устройство (АЛУ) представляет собой ключевой компонент вычислительных систем, предназначенный для выполнения логических и арифметических операций с данными. Арифметико-логические устройства выполняют арифметические и логические преобразования над словами, называемыми операндами. Операндами могут быть двоичные числа разных форм представления. 

Элементарные арифметические и логические операции реализуются с помощью комбинационных схем на логических элементах. Например, сложение выполняется сумматорами, а сдвиги – регистрами сдвига. Более сложные операции (умножение, деление) реализуются программно или микропрограммно путем последовательного выполнения элементарных операций.

Для работы с числовыми данными в АЛУ используются:
- Сумматоры – для сложения и вычитания;
- Регистры сдвига – для перемещения битов;
- Регистры счёта – для накопления значений при арифметических операциях;
- Компараторы – для сравнения значений.
  
По своей структуре АЛУ относится к классу комбинационных схем, поскольку не содержит элементов памяти. Это означает, что его выходные сигналы зависят исключительно от текущего состояния входных данных. Время выполнения каждой операции определяется характеристиками используемых электронных компонентов, типом выполняемой логической функции и видом АЛУ.

__Классификация АЛУ__

Существуют разные виды АЛУ по организации обработки данных:

- По способу обработки данных во времени:
    - Последовательные АЛУ – выполняют операции поэтапно, что снижает скорость, но экономит аппаратные ресурсы.
    - Параллельные АЛУ – обрабатывают несколько битов одновременно, ускоряя вычисления.
- По форме представления данных:
    - С фиксированной запятой.
    - С плавающей запятой.
- По архитектуре:
    - Многофункциональные АЛУ – выполняют все операции в одном блоке, что уменьшает затраты на оборудование, но снижает скорость обработки.
    - Блочные АЛУ – каждая операция выполняется в отдельном блоке, что увеличивает производительность и упрощает параллельную обработку.
- По организации временного цикла:
    - Синхронные АЛУ – работают в фиксированные тактовые интервалы.
    - Асинхронные АЛУ – начинают новую операцию сразу после завершения предыдущей, что уменьшает задержки, но усложняет схемотехнику.

#### 2.2.1 Функциональные модули АЛУ
##### 2.2.1.1 Входные регистры

*Назначение:* 

Хранят операнды (входные данные) перед выполнением операции. Обычно обозначаются как $A$ и $B$. Эти регистры могут быть доступны через мультиплексоры, чтобы обеспечивать гибкость в выборе источников данных (например, из регистрового файла, шины данных или постоянных значений).

*Особенности:*
-  Количество разрядов входных регистров соответствует разрядности АЛУ (например, 8, 16, 32 или 64 бита).
- Входные регистры управляются сигналами синхронизации (тактовыми импульсами) и сигналами разрешения загрузки (load enable), поступающими от управляющего блока процессора.
- В некоторых архитектурах регистры могут использоваться как входы-выходы (IO), позволяя не только загружать данные, но и считывать их обратно (например, для отладки или повторного использования).

##### 2.2.1.2 Управляющий модуль (декодер операций)

*Назначение:*

Интерпретирует управляющие сигналы, полученные от блока управления ЦП, и выбирает соответствующую операцию, активируя нужные блоки внутри АЛУ.

*Функции:*
- Декодирование сигнала операции (например, 4-битного кода — 16 возможных операций).
- Управление мультиплексорами выбора функции.
- Формирование управляющих сигналов для:
  - Арифметического блока
  - Логического блока
  - Сдвигового блока
  - Схемы флагов

##### 2.2.1.3 Арифметический блок

*Назначение:* 
В арифметическом режиме АЛУ рассматривает входные данные как двоичные числа. Операции выполняются с учётом переноса между разрядами, что позволяет реализовать математические функции, такие как сложение и вычитание.

*Функции:*
- Сложение (ADD): реализуется через сумматор, чаще всего — ускоренный (например, CLA)
    
    Формула для i-го бита:

    $S_i = A_i + B_i + C_{i-1}$
 
    где, $C_{i-1}$ — перенос из предыдущего разряда.

- Вычитание (SUB): через сложение инверсии второго операнда с единицей (дополнительный код).
  
  $A - B = A + (\lnot B + 1)$

- Инкремент/декремент: прибавление или вычитание единицы.
- Операции с переносом: включение внешнего или внутреннего сигнала переноса.

*Особенности*
- Операции требуют сложения с учётом переноса между разрядами, что замедляет процесс по сравнению с логическими функциями, но необходимо для корректных вычислений;
- Арифметические операции влияют на флаги переполнения, знака, нуля и переноса в процессорных архитектурах;
- Комплексность реализации: требуется цепь переноса (carry chain), которая может быть реализована либо последовательно, либо с ускорением.

##### 2.2.1.4 Логический блок

*Назначение:* 

В логическом режиме АЛУ воспринимает входные данные не как числа, а как набор битов. Операции выполняются над каждым разрядом по отдельности, без учёта переноса между ними.

*Функции:*
- логическое И (AND): результат бита будет 1, только если оба соответствующих входных бита равны 1.  
  
    $S_i = A_i \land B_i$

- логическое ИЛИ (OR): результат будет 1, если хотя бы один из битов равен 1.

    $S_i = A_i \lor B_i$
 
- исключающее ИЛИ (XOR): результат будет 1, если биты на входах различаются.
    
    $S_i = A_i \oplus B_i$
 
- Инверсия (NOT): побитово меняет все 0 на 1 и наоборот.
    
   $S_i = \lnot A_i$
 
Кроме базовых логических операций, современные АЛУ  поддерживают комбинации:
- НЕ-И (NAND): инверсия результата AND;
- НЕ-ИЛИ (NOR): инверсия результата OR;
- эквиваленция (XNOR) — инверсия XOR; результат 1, если биты совпадают.

*Особенности*:
- Отсутствие переноса и переполнения, поскольку операции выполняются независимо по битам;  
- Параллелизм операций: каждая пара битов обрабатывается одновременно, что обеспечивает высокую скорость операций;  
- Побитовые операции применяются для реализации мультиплексоров, дешифраторов, флагов состояния и сложных управляющих схем.

##### 2.2.1.5 Блок сдвигов (шифратор/дешифратор сдвигов)

*Назначение:* 

Выполняет сдвиги или циклические вращения битов.

*Типы сдвигов:*
- Логический сдвиг влево/вправо: заполнение нулями.
- Арифметический сдвиг: сохранение знака (бит знака остаётся постоянным).
- Циклический сдвиг (rotate): перенос крайних битов с одного конца на другой.
- Сдвиг с переносом: перенос выходит в флаг, используется в криптографии и умножении.

*Особенности:*
- Используются мультиплексоры, маски и триггерные схемы.
- Часто реализуется отдельной микросхемой (например, в классических компьютерах), но может быть встроен в АЛУ.

##### 2.2.1.6 Схема генерации и распространения переноса (Carry Lookahead Generator)

*Назначение:* 

Обеспечивает быстрое вычисление переносов при сложении, устраняя необходимость последовательного распространения сигнала.

*Функции:*
- Вычисляет сигналы $G_i$ и $P_i$.
- Формирует $C_{i+1}$ напрямую, например:
  
  $C_1 = G_0 + P_0 \cdot C_0$
  $C_2 = G_1 + P_1 \cdot G_0 + P_1 \cdot P_0 \cdot C_0$
- Повышает производительность многобитных операций.

##### 2.2.1.7 Схема флагов состояния (статусный регистр)

*Назначение:* 

Регистрирует и сохраняет информацию о результатах последней операции для последующего использования в логике управления (например, условные переходы).

*Основные флаги:*
- Zero (нулевой результат),
- Sign (знак результата),
- Carry (перенос или заём),
- Overflow (переполнение),
- Parity (чётность/нечётность).

*Применение:*
- Используются для принятия решений в условных переходах, циклах, обработке исключений.

##### 2.2.1.8 Выходной регистр (или шина результата)

*Назначение:*

Хранит результат выполнения операции до его передачи в регистровый файл, память или другую часть системы.

*Особенности:*
- Может иметь буферизацию (триггеры, защита от изменения при следующей тактовой операции);
- Часто подключён к внутренней или общей шине данных процессора.

##### 2.2.1.9 Мультиплексоры и линии выбора

*Назначение:*

Обеспечивают маршрутизацию данных и управляющих сигналов внутри АЛУ.

*Функция:*
- Выбор операнда из нескольких возможных источников;
- Выбор результата из арифметического, логического или сдвигового блоков;
- Коммутация внутренних шин.

#### 2.2.2 Пример АЛУ 74181
Микросхема 74181 представляет собой 4-разрядное арифметико-логическое устройство (АЛУ), способное выполнять 16 логических и 16 арифметических операций над двумя 4-битными словами. 

Ключевой особенностью 74181 является использование схемы ускоренного переноса (carry-lookahead).

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74181.png?raw=true)
Рисунок 3 - АЛУ 74181

Назначение входов/выходов микросхемы: 
- $A_{0} - A_{3}$ и $B_{0} - B_{3}$ - четырёхразрядные двоичные суммируемые операнды; 
- $S_{0} - S_{3}$ - четыре входа выбора позволяют выбрать одну из 16 возможных функций, в зависимости от состояния сигнала на линии $M$ (Mode Control) ($M = 0$ - арифметические операции над прямым кодом операндов $А$ и $В$ при $С = 1$; $M = 1$ - логические операции над прямым кодом операндов); 
- $F_{0} - F_{3}$ - 4-битный результат выбранной операции; 
- $P$, $G$ - выходы подключения к блоку ускоренного переноса при каскадировании; 
- $(А = В)$ = бинарный признак равенства операндов в операции сравнения; 
- $C_{n}$ (Carry In), $C_{n+4}$ - входной и выходной признаки переноса. Если операция даёт перенос, то он появляется на выходе $C_{n+4}$. Этот перенос можно передавать в следующую микросхему, если нужно работать с числами больше 4 бит;
- $G$, $P$ - сигналы генерации и распространения переноса

*Таблица команд*
| Код $S$  | Арифметическая операция $(M=0,\ C_{0}=1)$          | Арифметическая операция $(M=0,\ C_{0}=0)$          | Логическая операция $(M=1)$              |
|----------|----------------------------------------------------|----------------------------------------------------|-------------------------------------------|
| 0000     | $A$                                                | $A + 1$                                            | $\lnot A$                                  |
| 0001     | $A \lor B$                                         | $\lnot (A \lor B)$                                | $\text{NOT}(A \lor B)$                     |
| 0010     | $A \lor \lnot B$                                   | $\lnot A \land B$                                 | $\lnot A \lor B$                           |
| 0011     | $0$                                                | $0$                                               | $0$                                       |
| 0100     | $A + (A \land \lnot B)$                            | $\lnot (A \land B)$                               | $\text{NOT}(A \land B)$                    |
| 0101     | $(A \land B) + (A \lor B)$                         | $\lnot B$                                         | $\lnot B$                                  |
| 0110     | $A - B - 1$                                        | $A - B$                                           | $A \oplus B$                               |
| 0111     | $(A \land \lnot B) - 1$                            | $A \land \lnot B$                                 | $A \land \lnot B$                          |
| 1000     | $A + (A \land B)$                                  | $\lnot A \lor B$                                  | $\lnot A \lor B$                           |
| 1001     | $A + B$                                            | $A + B + 1$                                       | $\lnot (A \oplus B)$                       |
| 1010     | $(A \land B) + (A \lor \lnot B)$                   | $B$                                               | $B$                                       |
| 1011     | $(A \land B) - 1$                                  | $A \land B$                                       | $A \land B$                                |
| 1100     | $A + A$                                            | $A + A + 1$                                       | $1$                                       |
| 1101     | $A + (A \lor B)$                                   | $A \lor \lnot B$                                  | $A \lor \lnot B$                           |
| 1110     | $A + (A \lor \lnot B)$                             | $A \lor B$                                        | $A \lor B$                                 |
| 1111     | $A - 1$                                            | $A$                                               | $A$                                       |

Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​


### 2.3 Способы повышения разрядности цифровых операционных устройства
Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​

#### 2.3.1 Микросхема 4-разрядного ускоренного переноса — 74182

Микросхема 74182 представляет собой логический блок ускоренного (look-ahead) переноса, предназначенный для совместной работы с несколькими 4-разрядными арифметико-логическими устройствами (в частности, с микросхемами 74181). В отличие от АЛУ, 74182 не выполняет арифметических или логических операций самостоятельно, а обеспечивает быструю и согласованную обработку сигналов переноса между несколькими АЛУ-блоками, входящими в состав более широких вычислительных устройств.

Основное назначение микросхемы 74182 заключается в устранении задержек, возникающих при последовательной передаче переноса между каскадированными 74181. Используя логическую комбинацию входных сигналов генерации и распространения переноса от нескольких АЛУ-блоков, 74182 формирует выходные сигналы переноса для каждого последующего 4-битного блока. Это позволяет существенно сократить общее время выполнения арифметических операций, особенно при работе с 8-битными, 16-битными и более широкими шинами данных.

Микросхема 74182 поддерживает каскадирование до четырёх 4-разрядных блоков 74181, эффективно обеспечивая ускоренный перенос между ними. При этом начальный перенос (например, при сложении с переносом) подаётся на вход микросхемы, а выходные сигналы $C_1$, $C_2$, $C_3$,$C_4$  направляются соответственно на входы переноса блоков 74181 старших разрядов. Это исключает необходимость последовательного распространения переноса от одного блока к другому, которое увеличивало бы задержку пропорционально числу каскадов.

Назначение входов/выходов микросхемы:

- $P_0 – P_3$ — входы распространения переноса от четырёх 4-разрядных ALU-блоков (обычно 74181); определяют, может ли каждый блок пропустить входной перенос на следующий.
- $G_0 – G_3$ — входы генерации переноса от тех же ALU-блоков; сигнализируют, что соответствующий блок обязательно сгенерирует перенос независимо от входного переноса.
- $C_n$ — входной перенос в младший блок; задаёт начальный перенос всей группы (например, при сложении с учётом начального переноса).
- $C_1 – C_3$ — выходы переноса для подачи на входы переноса соответствующих 74181, отвечающих за старшие биты.
- $C_4$ — окончательный выходной перенос всей каскадированной ALU; может быть использован в качестве флага переполнения или входа следующей группы ALU.
- $PG$ (Propagate Group) — групповой сигнал распространения переноса, указывающий, может ли вся каскадированная группа 74181 передать входной перенос вперёд без его генерации.
- $GG$ (Generate Group) — групповой сигнал генерации переноса, свидетельствующий о том, что в пределах каскада перенос обязательно будет сгенерирован, независимо от входного переноса.

![alt](/Lab_2/Lab_2_theory/Images/screnshots/АЛУ_74181_74182.png)
Рисунок 4 - Каскадирование АЛУ 74181 за cчет CLA 74182

#### 2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882

Микросхема 74882 — это специализированный блок ускоренного переноса, предназначенный для использования в составе высокоразрядных АЛУ. Она не является самостоятельным АЛУ, как 74181, а служит в качестве расширителя CLA-схемы, обеспечивая обработку переноса между группами по 4 бита, в общей сложности — до 32 разрядов.

Использование 74882 позволяет значительно сократить время выполнения операций сложения и вычитания за счёт параллельной обработки переносов между группами разрядов. Это особенно важно в системах, требующих высокой производительности, таких как процессоры и цифровые сигнальные процессоры.

Назначение входов/выходов микросхемы:
- $P_{0} – P_{7}$ – входы распространения переноса от восьми 4-битных арифметических блоков (например, от микросхем 74181); указывают, способен ли каждый блок передать перенос дальше при его наличии.
- $G_{0} – G_{7}$ – входы генерации переноса от тех же восьми 4-битных блоков; сигнализируют о том, что соответствующий блок обязательно создаёт перенос независимо от входного значения переноса.
- $C_{n}$ – вход переноса в первый (младший) 4-битный блок; используется как начальный перенос в цепи.
- $C_{1} – C_{7}$ – выходы переноса для последующих 4-битных блоков; формируют сигналы переноса, поступающие на следующий каскад микросхем 74181.

![alt text](/Lab_2/Lab_2_theory/Images/screnshots/CLA_74882_ALU-32.png)

Рисунок 5 - Каскадирование АЛУ 74181 за cчет CLA 74882

## 3 Сведения о лабораторном оборудовании
### 3.1 Микросхема 4-разрядного АЛУ — 74181

*Алгоритм работы*
1. В симуляторе Digital откройте или собрите проект стенда с микросхемой 74181.
2. Установите значения операндов $A$ и $B$, переключив соответствующие входы ($A_{3} – A_{0}, B_{3} – B_{0}$) в интерфейсе симулятора.
3. Задате код операции, переключив тетраду входов $S_3 – $S-0$ согласно таблице функций и установите вход $M$ для выбора типа операции ($M = 0$ — арифметика, $M = 1$ — логика).
4. Активируйте входной перенос $C_{0} = 1$ или $0$.
5. Проанализируйте результат на выходах $F_{3} – F_{0}$, а также сигналы состояния ($C_{4}$, $P$, $G$, $A$ $=$ $B$).      |

*Пример*

Рассмотрим выполнение арифметической операции сложения двух четырёхразрядных чисел. Пусть $A = 0101 (5), B = 0011 (3)$.
На входы микросхемы в симуляторе устанавливаются:

$A_{3} = 0, A-{2} = 1, A_{1} = 0, A_{0} = 1$

$B_{3} = 0, B_{2} = 0, B_{1} = 1, B_{0} = 1$
 
Для операции сложения с учётом переноса выбирается код $S_{3} – S_{0} = 0001$ (см. Таблицу команд).

Устанавливается:

$M = 0$ (арифметическая операция)

$C_{0} = 1$  (входной перенос)

В результате на выходе:

$F_{3} – F_{0} = 1001 (9)$, 

так как 5 + 3 + 1 = 9

$C_{4} = 0$ (переполнения нет).

![alt](/Lab_2/Lab_2_theory/Images/screnshots/example_74181.png)
Рисунок 6 - Пример работу АЛУ 74181

### 3.2 Микросхема 4-разрядного ускоренного переноса — 74182

*Алгоритм работы*

1. В симуляторе Digital откройте или соберите схему, включающую две микросхемы 74181 и одну микросхему 74182, соединённые по каскадной схеме для реализации 8-битной ALU с ускоренным переносом.

2. Подайте на входы $A$ и $B$ два восьмиразрядных операнда. Разделите их на две тетрады:
   - Младшие биты ($A_0$–$A_3$, $B_0$–$B_3$) подключите к первой 74181.
   - Старшие биты ($A_4$–$A_7$, $B_4$–$B_7$) — ко второй 74181.

3. Установите управляющий код операции с помощью сигналов $S_3$–$S_0$, подключённых параллельно к обеим микросхемам 74181. Установите значение сигнала $M$:
   - $M = 0$ — арифметическая операция;
   - $M = 1$ — логическая операция.

4. Установите начальный входной перенос $C_0 = 1$ или $0$ подав его на вход микросхемы 74182.

5. Подключите сигналы $P$ и $G$ от каждой из 74181 к соответствующим входам $P_0$, $P_1$, $G_0$, $G_1$ микросхемы 74182.

6. Получите выходные сигналы переноса $C_1$, $C_2$ и т. д. с 74182:
   - $C_1$ подключите к входу переноса второй (старшей) 74181.
   - $C_4$ (итоговый перенос всей ALU) используйте по необходимости.

7. Проанализируйте результат:
   - На выходах $F_3$–$F_0$ первой и $F_3$–$F_0$ второй 74181 (итоговый 8-битный результат).
   - По сигналам переноса $C_4$, а также $P$ и $G$ при необходимости для последующего каскадирования.

*Пример*

Рассмотрим выполнение операции сложения двух 8-битных чисел:  
$A = 01010101$ (85), $B = 00110011$ (51), входной перенос $C_0 = 1$.

Разделим операнды на младшие и старшие тетрады и подадим в симулятор:

Для первой (младшей) 74181:

$A_3 = 0$, $A_2 = 1$, $A_1 = 0$, $A_0 = 1$ → $A_{\text{low}} = 0101$

$B_3 = 0$, $B_2 = 0$, $B_1 = 1$, $B_0 = 1$ → $B_{\text{low}} = 0011$

Для второй (старшей) 74181:

$A_7 = 0$, $A_6 = 1$, $A_5 = 0$, $A_4 = 1$ → $A_{\text{high}} = 0101$

$B_7 = 0$, $B_6 = 0$, $B_5 = 1$, $B_4 = 1$ → $B_{\text{high}} = 0011$

Управляющие сигналы:

$S_3$–$S_0 = 0001$ (код сложения)  
$M = 0$ (арифметическая операция)  
$C_0 = 1$ (начальный перенос)

Микросхема 74182 получает:

- $G_0$, $P_0$ от первой 74181  
- $G_1$, $P_1$ от второй 74181  
- $C_0 = 1$ (входной перенос)

На основании этих данных 74182 рассчитывает и подаёт:

- $C_1$ → на вход переноса второй 74181  
- $C_4$ → итоговый перенос всей 8-битной ALU

Результат:

- Первая 74181: $F = 0101 + 0011 + 1 = 1001$ → $F_3$–$F_0 = 1001$
- Вторая 74181 с учётом переноса: $F = 0101 + 0011 + 1 = 1001$ → $F_7$–$F_4 = 1001$

Итоговый результат:

$F_7$–$F_0 = 10011001$ (в двоичной форме) = **153** (в десятичной форме)

$C_4 = 0$ — переполнения нет.

![alt] 
Рисунок 7 — Пример 4-разрядного ускоренного переноса — 74182


#### 3.3 Микросхема 32-разрядного ускоренного переноса - 74882

*Алгоритм работы*

1. Сборка схемы АЛУ  
   Постройте схему, в которую входят:
   - Восемь микросхем 74181, каждая реализует 4-разрядную АЛУ;
   - Одна микросхема 74882, выполняющая функцию ускоренного переноса между восемью 4-битными блоками (всего 32 разряда).

2. Разделение входных данных  
   Разбейте 32-битные операнды $A$ и $B$ на восемь 4-битных тетрад:
   - $A_0$–$A_3$, $B_0$–$B_3$ → 1-я 74181;
   - $A_4$–$A_7$, $B_4$–$B_7$ → 2-я 74181;
   - ...
   - $A_{28}$–$A_{31}$, $B_{28}$–$B_{31}$ → 8-я 74181.

3. Установка управляющих сигналов  
   - Установите одинаковые значения $S_3$–$S_0$ и $M$ для всех 74181:
     - $M = 0$ — арифметика;
     - $S_3$–$S_0 = 0001$ — сложение.
   - Эти сигналы задают тип операции и код выполняемой функции.

4. Подключение микросхемы 74882  
   - Получите сигналы распространения переноса ($P_0$–$P_7$) и генерации переноса ($G_0$–$G_7$) с каждой 74181.
   - Подайте эти сигналы на соответствующие входы микросхемы 74882.
   - Установите начальный входной перенос $C_n = 1$ или $0$ на вход микросхемы 74882.

5. Управление переносами между 74181  
   - 74882 вычисляет сигналы переноса $C_1$–$C_7$ между блоками:
     - $C_1$ подаётся на вторую 74181;
     - ...
     - $C_7$ подаётся на восьмую 74181.
   - Перенос $C_0$ подаётся только на первую 74181.
   - Перенос $C_8$ (итоговый) — на выходе 74882, может использоваться как флаг переполнения.

6. Анализ результатов
   - Снимите 4-разрядные выходы $F_0$–$F_3$ с каждой 74181;
   - Соберите их в один 32-битный результат:
     - От младших разрядов (первая 74181) к старшим (восьмая 74181).


*Пример*

Рассмотрим выполнение сложения двух 32-битных чисел:  
$A = \texttt{0x12345678}$  
$B = \texttt{0x9ABCDEF0}$  
Начальный перенос: $C_n = 1$

1. Разбиение на тетрады:

| ALU (74181) | Тетрада $A$ | Тетрада $B$ |
|-------------|-------------|-------------|
| ALU₀        | 0111 1000   | 1111 0000   |
| ALU₁        | 0101 0110   | 1101 1110   |
| ALU₂        | 0011 0100   | 1011 1100   |
| ALU₃        | 0001 0010   | 1001 1010   |

2. Управляющие сигналы:
- $S_3S_2S_1S_0 = 0001$ — сложение  
- $M = 0$ — арифметическая операция  
- $C_n = 1$ — входной перенос

3. Сигналы $P_i$, $G_i$ и перенос:
- Каждый 74181 генерирует свой $P_i$ и $G_i$  
- 74882 получает эти сигналы и вычисляет:
  - $C_1$ → во 2-ю 74181  
  - ...  
  - $C_7$ → в 8-ю 74181

Результат:
- После выполнения сложения и передачи переносов через 74882, на выходах ALU₀–ALU₇ формируется итог:  
- $A + B + C_n = \texttt{0xAD609569}$


## 4. Описание Verilator

### 4.1 Описание Verilator

Verilator — это инструмент, который компилирует исходные тексты на Verilog и SystemVerilog в высокооптимизированный (и опционально многопоточный) точный цикл C++ или SystemC код. Преобразованные модули можно инстанцировать и использовать в тестбенчах на C++ или SystemC для целей верификации и/или моделирования.

#### 4.1.1 Достоинства Verilator

Verilator — это симулятор Verilog/SystemVerilog, промышленного уровня, очень быстрый, бесплатный и с открытым исходным кодом. Однако, Verilator нельзя считать прямым аналогом таких инструментов как, как Modelsim, Questa Sim, Synopsys VCS, Vivado Xsim и других симуляторов, основанных на событиях. Verilator — это цикл-ориентированный симулятор, что означает, что он не вычисляет события внутри одного такта и не симулирует точное временное поведение схемы. Вместо этого состояние схемы обычно пересчитывается один раз за такт, поэтому любые внутритактовые "глитчи" (скачки сигнала) не видны, а задержки сигналов по времени не поддерживаются. Это одновременно и плюс, и минус по сравнению с другими симуляторами.

##### 4.1.1.1 Скорость

Так как Verilator является цикл-ориентированным, его нельзя использовать для таймингового моделирования, симуляции с обратной аннотацией временных параметров (back-annotated netlists), асинхронной (безтактной) логики, или вообще для любых изменений сигналов, которые завязаны на время — все выходы переключаются мгновенно при каждом вызове схемы.

Однако, именно за счёт игнорирования всего, что происходит между фронтами тактов, симуляции в Verilator идут чрезвычайно быстро. Он отлично подходит для функционального моделирования синхронных цифровых схем с одним или несколькими тактами, а также для создания программных моделей из кода на Verilog/SystemVerilog, которые можно использовать при разработке ПО.

##### 4.1.1.2 Качество кода

Так как Verilator использует цикл-ориентированный подход, он не может полностью поддерживать стандарты IEEE Verilog и SystemVerilog. Тем не менее, инструменты синтеза обычно тоже не полностью совместимы с этими стандартами.

Помимо того, что Verilator не поддерживает временные задержки, он также не принимает большую часть неконструкционного (несинтезируемого) кода (за исключением таких элементов, как ```$display()```, ```$finish()```, ```$fatal()```), поэтому, как правило, не любой тестбенч на SystemVerilog получится скомпилировать в Verilator без серьёзных изменений. Если код не поддерживается, Verilator выдаст большое количество предупреждений и ошибок.

Благодаря тому, что Verilator не поддерживает несинтезируемый код — его поведение ближе к инструментам синтеза по сравнению с другими симуляторами. Это вынуждает писать код более "чистый" с точки зрения синтеза, что потенциально сокращает количество проблем на более поздних стадиях разработки.

##### 4.1.1.3 Стоимость

Verilator — это бесплатный инструмент с открытым исходным кодом. Для симуляции схемы с помощью Verilator создаётся нативный исполняемый файл из преобразованного HDL-кода и тестбенча на C++ с помощью компилятора GCC и системы сборки Make. Так как весь инструментарий бесплатен, нет никаких ограничений по количеству запускаемых экземпляров или числу пользователей. Благодаря высокой скорости работы Verilator позволяет быстро выполнять симуляции даже сложных схем на старых компьютерах и ноутбуках, так что нет необходимости в дорогом вычислительном оборудовании. 

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-23.png)

Рисунок 8 - Пользователи Verilator

#### 4.1.2 Начало работы

В данной работе предполагается, что вы используете какую-либо версию Linux на своём компьютере и что у вас уже установлены Verilator, GTKWave, Make и GCC.

```bash
    git clone https://github.com/n-kremeris/verilator_basics
    git checkout verilator_pt1
```

#### 4.1.3 Создание DUT

Чтобы проверить, как работает Verilator, необходимо устройство для тестирования (DUT — device under test). В данной работе представлена простая АЛУ на SystemVerilog. Исходный код приведён ниже:

``` sv
/****** alu.sv ******/
typedef enum logic [1:0] {
     add     = 2'h1,
     sub     = 2'h2,
     nop     = 2'h0
} operation_t /*verilator public*/;

module alu #(
        parameter WIDTH = 6
) (
        input clk,
        input rst,

        input  operation_t  op_in,
        input  [WIDTH-1:0]  a_in,
        input  [WIDTH-1:0]  b_in,
        input               in_valid,

        output logic [WIDTH-1:0]  out,
        output logic              out_valid
);

        operation_t  op_in_r;
        logic  [WIDTH-1:0]  a_in_r;
        logic  [WIDTH-1:0]  b_in_r;
        logic               in_valid_r;
        logic  [WIDTH-1:0]  result;

        // Register all inputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        op_in_r     <= '0;
                        a_in_r      <= '0;
                        b_in_r      <= '0;
                        in_valid_r  <= '0;
                end else begin
                        op_in_r    <= op_in;
                        a_in_r     <= a_in;
                        b_in_r     <= b_in;
                        in_valid_r <= in_valid;
                end
        end

        // Compute the result
        always_comb begin
                result = '0;
                if (in_valid_r) begin
                        case (op_in_r)
                                add: result = a_in_r + b_in_r;
                                sub: result = a_in_r + (~b_in_r+1'b1);
                                default: result = '0;
                        endcase
                end
        end

        // Register outputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        out       <= '0;
                        out_valid <= '0;
                end else begin
                        out       <= result;
                        out_valid <= in_valid_r;
                end
        end

endmodule;
```

Для начала работы необходимо создать новый рабочий каталог и сохранить исходный код АЛУ под именем alu.sv.

Как вы можете видеть, это АЛУ очень простое. Оно имеет два регистрационных этапа, не поддерживает остановку (stalling) и выполняет только две операции: сложение и вычитание. На рисунке 2 пример временной диаграммы, показывающей, ожидаемую работу АЛУ:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-22.png)

Рисунок 9 - Примитивный конвейер АЛУ

Из рисунка 2 видно, что на первом этапе входные сигналы записываются в регистры, а на втором этапе комбинационный результат также записывается в выходные регистры. Этого понимания достаточно, чтобы рассмотреть шаги, необходимые для создания базового тестбенча.

#### 4.1.4 Преобразование SystemVerilog в C++

##### 4.1.4.1 Верификация с помощью Verilator

Как упоминалось ранее, Verilator требует, чтобы тестбенч на C++ компилировался в исполняемый файл системы. Однако, невозможно без предварительной подготовки включить SystemVerilog АЛУ в тестбенч на C++. Для начала необходимо использовать Verilator, чтобы преобразовать код SystemVerilog в C++, или «верилировать» его, что в самом базовом виде выполняется так:

```css
verilator --cc alu.sv
```
Параметр --cc говорит Verilator выполнить преобразование в C++. Verilator также поддерживает преобразование в SystemC (для этого используется параметр --sc).
  
##### 4.1.4.2 Результаты преобразования

Выполнение приведённой выше команды создаёт новую папку с именем ```obj_dir``` в рабочем каталоге. Именно туда попадают все преобразованные исходники:

```
$ ls -l obj_dir/
Valu___024unit.cpp  Valu___024unit__Slow.cpp  Valu.cpp  Valu.mk
Valu__Syms.cpp  Valu__ver.d  Valu___024unit.h  Valu_classes.mk
Valu.h  Valu__Slow.cpp  Valu__Syms.h  Valu__verFiles.dat
```

Сгенерированные файлы с расширением ```.mk``` будут использоваться с ```Make``` для сборки исполняемого файла симуляции, а файлы ```.h``` и ```.cpp``` содержат заголовки C++ и исходные коды реализации, полученные в результате преобразования из SystemVerilog. 

Два наиболее важных, на данный момент, файла:

- ```Valu.h``` — это основной заголовочный файл, содержащий определение класса преобразованного «ALU». Именно этот класс будет «инстанцирован» в тестбенче на C++ как DUT;

- ```Valu___024unit.h``` — это внутренний заголовок для класса «ALU», который содержит определение типа operation_t.

#### 4.1.5 Разработка базового тестбенча для Verilator

##### 4.1.5.1 Пример тестбенча на C++

После того как DUT (устройство под тестированием) преобразован в C++,  можно начать писать тестбенч. Тестбенч будет находиться в новом файле с именем ```tb_alu.cpp```. Минимальный пример кода тестбенча  приведен ниже на C++:

```cpp
#include <stdlib.h>
#include <iostream>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Valu.h"
#include "Valu___024unit.h"

#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut->clk ^= 1;
        dut->eval();
        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```

Первые несколько строк с директивами ```#include``` в понятны сами по себе: подключается <verilated.h> и <verilated_vcd_c.h>, которые идут с установкой Verilator, чтобы получить доступ к основным функциям Verilator и записывать временные диаграммы в файл формата VCD (value change dump).

Как уже упоминалось, ```"Valu.h"``` содержит основной класс Verilated-модуля АЛУ, а ```"Valu___024unit.h"``` содержит преобразованное Verilator определение перечисления typedef.

Далее идут две строки:

```cpp
#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;
```

Переменная ```sim_time``` используется для отслеживания момента завершения симуляции. Существует несколько способов остановки симуляции, но в данном примере симуляция завершается после 20 фронтов тактового сигнала.

Затем идет основная функция main():

```cpp

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    /* <...> */

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```
Строка ```Valu dut = new Valu;``` создаёт экземпляр преобразованного модуля АЛУ. В SystemVerilog это примерно аналогично записи ```alu dut (.);```.

Следующие четыре строки настраивают запись временных диаграмм. Создается объект ```m_trace``` и передается устройству ```dut``` в строке ```dut->trace(m_trace, 5);```. Параметр 5 ограничивает глубину трассировки до 5 уровней вниз по иерархии DUT.

Ниже представлена часть, которая выполняет симуляцию:

```cpp

while (sim_time < MAX_SIM_TIME) {
    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Во время каждой итерации цикла строка ```dut->clk ^= 1;``` инвертирует сигнал тактового генератора АЛУ (создавая фронты/спады такта). Это будет единственный тактовый сигнал, который используется в тестбенче.

Вызов ```dut->eval();``` производит вычисление всех сигналов модуля АЛУ, а ```m_trace->dump(sim_time);``` записывает все трассированные сигналы в файл временных диаграмм. Как видно, модель вычисляется только по фронтам тактового сигнала.

Переменная времени симуляции затем увеличивается, и цикл продолжается до достижения ```MAX_SIM_TIME```. Обратите внимание, что это не реальное время — переменная просто считает, сколько раз инвертировали такт.

Как видно, этот тестбенч пока что только тактирует модель, но это хорошая отправная точка для дальнейшей разработки.

##### 4.1.5.2 Сборка исполняемого файла симуляции

Когда тестбенч написан, необходимо собрать исполняемый файл для запуска симуляции.

В отличие от некоторых других симуляторов (например, Modelsim), где исходники открываются через графический интерфейс, либо передаются в исполняемый файл Modelsim, приложение Verilator не используется напрямую для симуляции тестбенча.

Приложение Verilator служит только для преобразования Verilog в C++ и генерации инструкций для сборки с помощью ```Make```. Симулятором здесь является сам тестбенч на C++.

Тестбенч и преобразованные HDL-файлы представляют собой обычное приложение на C++, которое компилируется и запускается на компьютере. Запуск скомпилированного исполняемого файла — это и есть процесс симуляции, а для сборки используется компилятор GCC.

Чтобы собрать исполняемый файл симуляции, нужно снова запустить Verilator для генерации файлов ```.mk``` с добавлением тестбенча на C++ — это делается так:

```bash
$ verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp
```
Дополнительно используются такие параметры:

- ```-Wall``` — включает все предупреждения компилятора C++. Необязательно, но полезно для новичков;

- ```--trace``` — включает запись временных диаграмм.

Для сборки исполняемого файла выполняем команду:

``` bash
$ make -C obj_dir -f Valu.mk Valu
```

Параметр ```-C obj_dir``` говорит ```make``` работать в каталоге ```obj_dir```. С помощью ```-f Valu.mk``` указывается нужный Makefile. Наконец, make собирает цель ```Valu```, которая и есть имя компилируемого тестбенча.

Если сборка прошла успешно, исполняемый файл ```Valu``` сохранится в папке ```obj_dir```.

##### 4.1.5.2 Запуск тестбенча

После сборки необходимо запустить бинарник ```Valu``` для запуска симуляции:

```bash
$ ./obj_dir/Valu
```

На первый взгляд, кажется, что ничего не произошло. Однако запуск симуляции создал файл с временными диаграммами под именем ```waveform.vcd``` в рабочем каталоге.

##### 4.1.5.3 Просмотр временных диаграмм Verilator

Вы можете открыть этот файл временных диаграмм с помощью программы ```GTKWave```:

```bash
gtkwave waveform.vcd
```

Откроется окно GTKWave, которое будет выглядеть примерно так:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-24.png)

Рисунок 10 - Окно новой сессии GTKWave

Следуйте показанным шагам, чтобы загрузить сигналы из DUT и просмотреть их временные диаграммы:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-25.png)

Рисунок 11 - Просмотр временных диаграмм в GTKWave

##### 4.1.6 Наблюдения

Во-первых, можно заметить, что в симуляции нет никаких значений 'x' (неопределённых значений). Это связано с тем, что Verilator является симулятором с двумя состояниями, и по умолчанию все сигналы инициализируются в 0. Это хорошо для скорости (так как 2 состояния — меньше, чем 4), но есть недостаток. Невозможно проверить корректность логики сброса. 

Во-вторых, полпериода такта занимает 1 пикосекунду. Это стандартный таймскейл Verilator, и в данном случае он не означает какую-то конкретную временную величину.

### 4.2. Основы верификации SystemVerilog с использованием C++

#### 4.2.1 Использование Make
Для быстрой сборки и запуска симуляции будет использована утилита Make.
В рабочем каталоге необходимо создать файл с именем ```Makefile``` и вставить следующее содержимое:

``` make
MODULE=alu

.PHONY:sim
sim: waveform.vcd

.PHONY:verilate
verilate: .stamp.verilate

.PHONY:build
build: obj_dir/Valu

.PHONY:waves
waves: waveform.vcd
  @echo
  @echo "### WAVES ###"
  gtkwave waveform.vcd

waveform.vcd: ./obj_dir/V$(MODULE)
  @echo
  @echo "### SIMULATING ###"
  @./obj_dir/V$(MODULE)

./obj_dir/V$(MODULE): .stamp.verilate
  @echo
  @echo "### BUILDING SIM ###"
  make -C obj_dir -f V$(MODULE).mk V$(MODULE)

.stamp.verilate: $(MODULE).sv tb_$(MODULE).cpp
  @echo
  @echo "### VERILATING ###"
  verilator -Wall --trace -cc $(MODULE).sv --exe tb_$(MODULE).cpp
  @touch .stamp.verilate

.PHONY:lint
lint: $(MODULE).sv
  verilator --lint-only $(MODULE).sv

.PHONY: clean
clean:
  rm -rf .stamp.*;
  rm -rf ./obj_dir
  rm -rf waveform.vcd
```
После сохранения файла, возможно быстро пересобрать всю симуляцию, запустив в терминале ```make sim```, открыть ```GTKWave``` с помощью ```make waves```, выполнить вериляцию дизайна с помощью ```make verilate``` или собрать верилированные исходники с помощью ```make build```.

Обратите внимание, также есть дополнительная команда ```make lint```, которая вызывает Verilator с ключом ```--lint-only```. Это полезно для быстрой проверки ваших исходных файлов Verilog/SystemVerilog на ошибки. 

И наконец, есть команда ```make clean```, которая удаляет весь мусор, сгенерированный в процессе сборки.

#### 4.2.2 Случайные начальные значения

Одно из вышеупомянутых наблюдений в том, что Verilator является симулятором с двумя состояниями, что значит, что он поддерживает только логические значения ```1``` и ```0```, и не поддерживает ```X```. Поэтому Verilator по умолчанию инициализирует все сигналы в ```0```, что видно на Рисунка 5 из предыдущих результатов симуляции:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-21.png)

Рисунок 12 - По умолчанию все инициализировано равным 0

Кроме того, если код, присваивает X регистру, то по умолчанию он также получает значение 0.

Однако это поведение можно изменить с помощью параметров командной строки — можно заставить Verilator инициализировать все сигналы в ```1``` или, что лучше, в случайные значения. Это позволит проверить, работает ли сигнал сброса, как только он будет добавлен в тестбенч.

Чтобы сделать так, чтобы тестбенч инициализировал сигналы случайными значениями, сначала нужно вызвать ```Verilated::commandArgs(argc, argv);``` перед созданием объекта DUT:

```cpp
int main(int argc, char** argv, char** env) {
    Verilated::commandArgs(argc, argv);
    Valu *dut = new Valu;
    <...>
```
Затем необходимо обновить команду сборки вериляции, добавив ```--x-assign unique``` и ```--x-initial unique```. Строка 31 в Makefile теперь должна выглядеть так:

```make
verilator -Wall --trace --x-assign unique --x-initial unique -cc $(MODULE).sv --exe tb_$(MODULE).cpp
```

И наконец, необходимо передать ```+verilator+rand+reset+2``` исполняемому файлу симуляции, чтобы установить метод инициализации сигналов во время выполнения в случайный. Это значит, что строка 21 в Makefile должна выглядеть так:

```make
@./obj_dir/V$(MODULE) +verilator+rand+reset+2
```

Теперь, вызвав ```make clean``` и ```make waves```, будет видно, что сигналы инициализируются случайными значениями в начале симуляции:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-26.png)

Рисунок 13 - Случайная инициализация

#### 4.2.3 Сброс DUT

Чтобы сбросить DUT и его входные сигналы, необходимо обновить основной цикл тестбенча так:

```cpp

while (sim_time < MAX_SIM_TIME) {
    dut->rst = 0;
    if(sim_time > 1 && sim_time < 5){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

В строке 3 произвольно выбрано, чтобы сброс происходил между фронтами тактов на 3 и 5. При необходимости это можно изменить.

В строке 4 сброс устанавливается в высокий уровень, а в последующих строках все входы DUT сбрасываются в 0.

Строки 11-14 не изменены. Тактовый сигнал инвертируется и увеличивается счётчик времени симуляции.

Строка 2 добавлена, чтобы сбрасывать счётчик обратно в 0 при последующих итерациях цикла. В совокупности строки 2-3-4 эквивалентны следующему коду на SystemVerilog:

```sv
always_comb begin
    dut.rst = 1'b0;
    if (sim_time >= 3 && sim_time < 6) begin
        dut.rst = 1'b1;
    end
end
```
Повторный запуск симуляции теперь даёт следующее:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-27.png)

Рисунок 14 - Сигнал сброса в действии

Как видно на Рисунке 14, сигнал сброса успешно генерируется в тестбенче. Чтобы сделать основной цикл немного чище, можно вынести код сброса в отдельную функцию за пределами ```main()```:

```cpp
void dut_reset (Valu *dut, vluint64_t &sim_time){
    dut->rst = 0;
    if(sim_time >= 3 && sim_time < 6){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }
}```

Затем добавнеобходимо добавить вызов ```dut_reset``` в главный цикл:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Теперь, когда сброс работает, можно рассмотреть добавление реальных стимулов и кода верификации.

#### 4.2.4 Базовая верификация

На данный момент в основном цикле симуляции следующее:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Теперь, если симулировать тестбенч на Verilog/SystemVerilog как DUT, вместо модуля ALU, можно было бы добавить проверку ```Verilated::gotFinish()``` и остановить симуляцию, если это значение становится ```true```. Это происходит, когда вызывается ```$finish()``` из Verilog/SystemVerilog. Тогда тестбенч на C++ был бы достаточен для симуляции тестбенча на Verilog/SystemVerilog.

Но этого недостаточно, так как в рамках работы необходимо вставить стимулы и код верификации в главный цикл тестбенча на C++, чтобы управлять и проверять DUT.

##### 4.2.4.1 Счётчик фронтов тактового сигнала

Для настройки счетчика фронтов тактового сигнала, будет создана отдельная переменная для подсчёта положительных фронтов тактового сигнала. Эта переменная будет того же типа, что и sim_time:

```cpp
vluint64_t sim_time = 0;
vluint64_t posedge_cnt = 0;```

Далее необходимо модифицировать код генерации тактового сигнала, добавив счётчик положительных фронтов:

```cpp
dut->clk ^= 1;            // Инвертировать тактовый сигнал
dut->eval();              // Оценить DUT на текущем фронте
if(dut->clk == 1){
    posedge_cnt++;        // Увеличить счётчик при положительном фронте
}
m_trace->dump(sim_time);  // Сохранить в waveform.vcd
sim_time++;               // Увеличить время симуляции
```
Добавление счётчика между ```eval``` и ```dump``` на Verilog можно переписать в седующем виде:

```sv
initial posedge_cnt <= '0;
always_ff @ (posedge clk, posedge rst) begin
    posedge_cnt <= posedge_cnt + 1'b1;
end
```
И на этом этапе можно начать верифицировать АЛУ.

##### 4.2.4.2 Примитивные стимулы и проверки для DUT

Ожидаемые временные диаграммы для АЛУ представлены на рисунке 15:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-28.png)

Рисунок 15 - Ожидаемое поведение АЛУ

Игнорируя входы a, b и операцию, а также выходные данные, сначала необходимо проверить, что сигнал входной валидности (input valid) проходит до выхода.

Есть 2 регистрационные стадии, которые, если упростить, выглядели бы так:

```verilog
always_ff @ (posedge clk) begin
    in_valid_r <= in_valid;
    out_valid <= out_valid_r;
end
```

Таким образом, если на ```in_valid``` подать ```1``` на 5-м положительном фронте тактового сигнала, то можно будет увидеть ```1``` на ```out_valid``` через два тактовых цикла, или другими словами, на 7-м положительном фронте. Код для проверки:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    dut->in_valid = 0;
    if (dut->clk == 1){
        posedge_cnt++;
        if (posedge_cnt == 5){
            dut->in_valid = 1;       // установить in_valid на 5-м фронте
        }
        if (posedge_cnt == 7){
            if (dut->out_valid != 1) // проверить out_valid на 7-м фронте
                std::cout << "ERROR!" << std::endl;
        }
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

То, что выполняет выделенный код, будет аналогично этому:

```verilog
always_comb begin
    in_valid = 0;
    if (posedge_cnt == 5)
        in_valid = 1;

    if (posedge_cnt == 7)
        assert (out_valid == 1) else $error("ERROR!")
end
```

Результат симуляции представлен на рисунке 16:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-29.png)

Рисунок 16 - Графическое объяснение проверки valid

Необходимо убедиться, что код генерации стимулов и проверки, следует нижеописанному порядку действий:

- Тактовая частота устанавливается на 1, выполняется оценка для создания положительного фронта, а затем устанавливаются входные данные / выходные данные перед сбросом и увеличением времени моделирования.

- На следующем положительном фронте тактового сигнала внутри цикла ```while()``` входные данные, заданные ранее, будут переданы в схему во время ```eval```, а затем сразу после вычисления входные данные должны быть сброшены до значений по умолчанию.

#### 4.2.5 Мониторинг сигналов утверждений (assertions)

Установка ```in_valid``` на 5-м фронте и проверка, что ```out_valid``` равен 1, работает, но если возникнет необходимость проверить валидность на большем числе тактов, придётся добавить намного больше проверок. Более того, в коде не проверяется, что ```out_valid``` равен 0 там, где это должно быть, а это значит, что ```out_valid``` мог бы "застрять" на 1, и тестбенч не выдал бы ошибку. Поэтому верификационный код можно значительно улучшить, написав немного C++ кода для непрерывного мониторинга ```in_valid``` и ```out_valid```, аналогично тому, как это делают утверждения в SystemVerilog.

Функция будет выглядеть следующим образом:

```cpp
#define VERIF_START_TIME 7
void check_out_valid(Valu *dut, vluint64_t &sim_time){
    static unsigned char in_valid = 0; // in_valid текущего цикла
    static unsigned char in_valid_d = 0; // задержанный in_valid
    static unsigned char out_valid_exp = 0; // ожидаемое значение out_valid

    if (sim_time >= VERIF_START_TIME) {
        // обратите внимание на порядок!
        out_valid_exp = in_valid_d;
        in_valid_d = in_valid;
        in_valid = dut->in_valid;
        if (out_valid_exp != dut->out_valid) {
            std::cout << "ERROR: out_valid mismatch, "
                << "exp: " << (int)(out_valid_exp)
                << " recv: " << (int)(dut->out_valid)
                << " simtime: " << sim_time << std::endl;
        }
    }
}
```

```VERIF_START_TIME``` нужен, чтобы гарантировать, что  проверочный код не выполняется до или во время сброса, чтобы предотвратить ложные срабатывания ошибок. Если посмотреть на Рисунок 9, видно, что ```rst``` возвращается в 0 на отметке 6ps (что равно sim_time = 6), поэтому sim_time = 7 — это точка, с которой необходимо начинать проверку valid.

Код проверки моделирует конвейер регистров между ```in_valid``` и ```out_valid```. Оригинальный код вышеописанной функции можно заменить следующим образом:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        if (posedge_cnt == 5){
            dut->in_valid = 1;
        }
        check_out_valid(dut, sim_time);
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

Если на данном этапе запустить симуляцию, ошибок не будет, потому что сигнал ```valid``` правильно передается. Однако, чтобы окончательно убедиться, что новый код работает, можно обратиться в ```alu.sv``` и изменить выходную стадию так, чтобы ```out_valid``` всегда устанавливался в 1:

```verilog
always_ff @ (posedge clk, posedge rst) begin
    if (rst) begin
        out       <= '0;
        out_valid <= '0;
    end else begin
        out       <= result;
        out_valid <= 1'b1;  //**** здесь должно быть in_valid_r ****//
    end
end
```

Запустив симуляции снова, вывод будет следующим:

```perl
### SIMULATING ###
./obj_dir/Valu +verilator+rand+reset+2
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 8
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 10
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 14
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 16
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 18
```

#### 4.2.6 Генерация случайного valid сигнала

Чтобы заменимть единственное присваивание ```in_valid``` на что-то, что будет случайно устанавливать его в 1 или 0, необходимо подключить заголовок C++ ```cstdlib```:

```cpp
#include <cstdlib>
```

и использовать функцию генерации псевдослучайных чисел ```rand()``` для генерации случайных 1 и 0 в пользовательской функции ```set_rnd_out_valid```:

```cpp
void set_rnd_out_valid(Valu *dut, vluint64_t &sim_time){
    if (sim_time >= VERIF_START_TIME) {
        dut->in_valid = rand() % 2; // генерировать значения 0 и 1
    }
}
```

Также необходимо инициализировать генератор случайных чисел с помощью вызова ```srand```, который можно поместить прямо в начало функции main:

```cpp
int main(int argc, char** argv, char** env) {
    srand (time(NULL));
``` 

Следует увеличить ```MAX_SIM_TIME``` до чего-то более существенного, например до 300:

```cpp
#define MAX_SIM_TIME 300
```

И после запуска ```make sim``` и ```make waves```, вот результаты новой самопроверяющейся случайной симуляции представлены на рисунке 17:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-30.png)

Рисунок 17 - Обновленные симуляции с случайными значениями

#### 4.2.7 Готовый тестбенч

Врезультате проделанной работы на данном этапе получилась следующая версия C++ тестбенча:

```cpp
#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Valu.h"
#include "Valu___024unit.h"

#define MAX_SIM_TIME 300
#define VERIF_START_TIME 7
vluint64_t sim_time = 0;
vluint64_t posedge_cnt = 0;

void dut_reset (Valu *dut, vluint64_t &sim_time){
    dut->rst = 0;
    if(sim_time >= 3 && sim_time < 6){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }
}

void check_out_valid(Valu *dut, vluint64_t &sim_time){
    static unsigned char in_valid = 0; // in_valid текущего цикла
    static unsigned char in_valid_d = 0; // задержанный in_valid
    static unsigned char out_valid_exp = 0; // ожидаемое значение out_valid

    if (sim_time >= VERIF_START_TIME) {
        out_valid_exp = in_valid_d;
        in_valid_d = in_valid;
        in_valid = dut->in_valid;
        if (out_valid_exp != dut->out_valid) {
            std::cout << "ERROR: out_valid mismatch, "
                << "exp: " << (int)(out_valid_exp)
                << " recv: " << (int)(dut->out_valid)
                << " simtime: " << sim_time << std::endl;
        }
    }
}

void set_rnd_out_valid(Valu *dut, vluint64_t &sim_time){
    if (sim_time >= VERIF_START_TIME) {
        dut->in_valid = rand() % 2;
    }
}

int main(int argc, char** argv, char** env) {
    srand (time(NULL));
    Verilated::commandArgs(argc, argv);
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut_reset(dut, sim_time);

        dut->clk ^= 1;
        dut->eval();

        if (dut->clk == 1){
            dut->in_valid = 0;
            posedge_cnt++;
            set_rnd_out_valid(dut, sim_time);
            check_out_valid(dut, sim_time);
        }

        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```

### 4.3. Традиционный пример верефикации

#### 4.3.1 Создание typedef ```operation_t``` доступным в тестбенче на C++

Прежде чем начать проверять, правильно ли АЛУ складывает или вычитает два числа, для начала необходимо сделать typedef операции доступным в тестбенче ```tb_alu.cpp```.

В начале кода АЛУ есть следующее:

```verilog
typedef enum logic [1:0] {
  add = 2'h1,
  sub = 2'h2,
  nop = 2'h0
} operation_t /*verilator public*/;
```

Обратите внимание на комментарий ```/*verilator public*/``` после имени ```operation_t```. Это говорит Verilator преобразовать этот typedef в C++ и сделать его общедоступным — это происходит во время шага верилации (конвертация HDL в C++).

Такие комментарии называются директивами или прагмами — они дают Verilator дополнительную информацию о том, как обрабатывать HDL-код. Список таких директив можно найти в руководстве по расширениям языка Verilator.

Если посмотреть в папку ```obj_dir```, где находятся артефакты конверсии, можно найти файл ```Valu___024unit.h```, который содержит верифицированную версию перечисления typedef:

```cpp
// TYPEDEFS
// That were declared public
enum operation_t {
    add = 1U,
    sub = 2U,
    nop = 0U
};
```
Если бы комментарий ```/*verilator public*/``` не был добавлен, этот typedef не был бы доступен в заголовочном файле.

Так как этот заголовок уже включен в ```tb_alu.cpp``` (```#include "Valu___024unit.h"```), теперь можно ем использовать определения внутри перечисления (enum) для задания входа ```op_in``` АЛУ.

Значения перечисления затем могут быть доступны в тестбенче следующим образом:

```cpp
Valu___024unit::operation_t::add
Valu___024unit::operation_t::sub
```
На этом этапе есть всё необходимое, чтобы приступить к проверке функциональности сложения и вычитания АЛУ.

#### 4.3.2 Пример традиционной (временной) верификации

Ранее был продемонстрирован примитивный метод проектирования тестбенча, который проверял корректность работы сигнала ```out_valid``` у АЛУ.

Ранее проверялось, что пайплайн между ```in_valid``` и ```out_valid``` работает правильно, задавая ```1``` на ```in_valid``` на пятом такте и проверяя, что ```out_valid``` равен ```1``` на седьмом такте:

```cpp
if (posedge_cnt == 5){
    dut->in_valid = 1; // устанавливаем in_valid на 5-м такте
}
if (posedge_cnt == 7){
    if (dut->out_valid != 1) // проверяем out_valid на 7-м такте
        std::cout << "ERROR!" << std::endl;
}
```
Этот пример сам по себе довольно слабый (а что если ```out_valid``` всегда застревал на ```1```?), но он хорошо иллюстрирует сутьЭто назвается традиционным или временным стилем верификации, потому что на вход явно подается конкретное входное значение в определённый момент времени и проверяется, что выходные значения соответствуют ожидаемым после некоторого времени. Этот стиль отлично подходит для быстрой проверки небольших схем, хотя может быть не лучшим выбором при работе со сложными модулями.

##### 4.3.2.1 Временные стимулы

На данном этапе основной цикл должен выглядеть так:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        set_rnd_out_valid(dut, sim_time);
        check_out_valid(dut, sim_time);
    }
    m_trace->dump(sim_time);
    sim_time++;
}
```

Можно выполнить операцию сложения на такте 10 и вычитания на такте 20. Для этого необходимо убрать функцию случайной передачи, которая находится в строке 10, и заменить её на оператор switch следующим образом:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        switch (posedge_cnt){
            case 10:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::add;
                break;

            case 20:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::sub;
                break;
        }
        check_out_valid(dut, sim_time);
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

Как видно, в обоих случаях устанавливается ```dut->in_valid``` в ```1```, задаются некоторые входные операнды в ```dut->a_in``` и ```dut->b_in```, а затем устанавливается ```dut->op_in``` в желаемую операцию: сложение на 10-м такте и вычитание на 20-м. При симуляции можно увидеть, как это работает на Рисунке 18:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-31.png)
Рисунок 18 - Результаты симуляции сложения и вычитания

Из рисунка 18 видно, что АЛУ работает корректно.

##### 4.3.2.2 Проверка результатов по времени

Конвейер АЛУ всегда занимает фиксированное количество — 2 такта — чтобы обработать входные данные и вернуть результат на выходах, поэтому можно добавить проверки на 12-м и 22-м тактах для верификации результатов:

```cpp
switch (posedge_cnt){
    case 10:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::add;
        break;

    case 12:
        if (dut->out != 8)
            std::cout << "Addition failed @ " << sim_time << std::endl;
        break;

    case 20:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::sub;
        break;

    case 22:
        if (dut->out != 2)
            std::cout << "Subtraction failed @ " << sim_time << std::endl;
        break;
}
```
Нет необходимости явно проверять, что ```out_valid``` корректен в случаях 12 и 22 — это по-прежнему делает функция ```check_out_valid()```.

Если на данном этапе запустить симуляцию, можно увидеть, что она проходит без проблем, потому что АЛУ написано правильно. Однако, если открыть```alu.sv``` и изменить вектор результата ```result```:

```verilog
//sub: result = a_in_r + (~b_in_r+1'b1); // оригинал
sub: result = a_in_r + (~b_in_r+6'h3);   // модифицировано
```

Можно будет заметить, что симуляция провалится и укажет нам, где была обнаружена ошибка:

```perl
### SIMULATING ###
./obj_dir/Valu +verilator+rand+reset+2
Subtraction failed @ 42
```

#### 4.3.3 Подведение временных итогов

Это руководство демонстрирует примитивный пример верификационного кода на C++, который можно использовать для выполнения базовых задач верификации. Существует множество вариаций того, как можно структурировать такой код — можно использовать операторы ```switch```, как показано здесь, отдельные ```if```- выражения или разбивать код на отдельные функции. Однако, скорее всего, вы согласитесь, что такой метод верификации, хотя простой и быстрый в реализации, на самом деле недостаточен для более сложных проектов.

## 4.4. Современный транзакционный (UVM) стиль тестбенча на C++

В этом руководстве будут рассмотрены более современные методы верификации, а именно — транзакционные тестбенчи в стиле UVM.

### 4.4.1 Определение транзакционного тестбенча?

Постоянно растущая сложность FPGA и ASIC дизайнов приводит к ужесточению требований к верификации. Возросший спрос на продвинутые тестбенчи породил появление новых методологий и инструментов, таких как OVM, VVM, UVM, SystemC, а также различных Python-фреймворков. Все эти инструменты направлены на одну цель — облегчение построения мощных, самопроверяющих тестбенчей из переиспользуемых компонентов, с одновременным увеличением покрытия кода, минимизацией дублирования и избавлением инженеров по верификации от необходимости постоянно смотреть на осциллограммы. Один из главных способов достижения этой цели — поощрение написания тестбенчей транзакционного стиля, которые, как раз могут быть реализованы на чистом C++ вместе с Verilator.

Транзакционный тестбенч — это тестбенч, который использует транзакции (что, по сути, представляет собой обмен данными или управляющими пакетами), которые обеспечивают абстракцию поверх прямого присваивания значений входным контактам и непосредственной проверки значений выходных контактов устройства, проходящего тестирование (DUT). 

Традиционный тестбенч на VHDL, Verilog, SystemVerilog или C++ обычно имеет экземпляр DUT, а также длинный поведенческий код с циклами и условными операторами, который последовательно подаёт сигналы на входы DUT для перевода его в определённые состояния. Как правило, такие тестбенчи проверяются на корректность визуальным просмотром осциллограмм, и хотя можно добавить самопроверку через утверждения или мониторинг.

В отличие от этого, транзакционный тестбенч поощряет строгое разделение на различные функциональные блоки, которые общаются между собой через транзакции. Базовый транзакционный тестбенч может состоять из:

- блока генерации стимулов для DUT (генератор транзакций / последовательность);

- блока, подающего эти данные на DUT (драйвер);

- блока, который наблюдает выходы DUT и генерирует результаты (монитор);

- блока, собирающего пакеты данных и сравнивающего их для проверки (табло);

- блока, собирающего данные и рассчитывающего функциональное покрытие (ковередж).

Сразу видно главный минус транзакционных тестбенчей — это сложность: из-за множества отдельных блоков базовая симуляция запускается медленнее. Однако этот недостаток перекрывается непревзойдённой гибкостью и повторным использованием кода.

Например, если есть драйвер для интерфейса типа A, его можно использовать его с любым другим DUT с таким же интерфейсом типа A — достаточно просто передать ему новые данные. Если интерфейс заменяется с типа A на тип B, достаточно поменять драйвер с A на B, оставляя остальной тестбенч без изменений.

#### 4.4.2 Рандомизированные транзакционные (в UVM стиле) тестбенчи на чистом C++ с Verilator

Тестбенчи в стиле UVM довольно легко пишутся и на чистом C++. Структуры наподобие драйверов, мониторов и табло просто реализуются, и также возможно реализовать покрытие и последовательные структуры, приложив немного дополнительных усилий.

Реализация современных транзакционных тестбенчей на чистом C++ вместо SystemC или UVM-SystemC имеет преимущество в простоте старта, а иногда и в более высокой производительности. Минус — многое из того, что уже есть в SystemC или UVM, придётся реализовать вручную. Теоретически, можно создать тестбенч на SystemVerilog UVM, преобразовать его в C++ с помощью Verilator и управлять базовым C++ тестбенчем. Однако поддержка UVM в Verilator пока ещё не полноценная.

Учитывая всё это, в данной работе будет создан базовый транзакционный тестбенч на чистом C++, без сторонних библиотек. Будут написсаны структуры, которые условно представляют транзакции, драйверы, мониторы и табло. Это даст необходимые знания для создания мощных тестбенчей на C++, а также понятную и простую в использовании основу для последующих проектов.

#### 4.4.3 Базовая блок-схема транзакционного тестбенча

Вот базовый пример того, как устроен современный транзакционный тестбенч:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-32.png)

Рисунок 19 - Блок-схема базового транзакционного тестового стенда

Описание компонент представлено ниже:

##### 4.4.3.1 Транзакция и элемент транзакции

Транзакция — это высокоуровневая операция обмена данными, а элемент транзакции — это просто пакет данных, то есть набор информации или инструкций. Обычно реализуется как класс или структура и содержит данные, отправляемые в DUT или получаемые от него.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-33.png)

Рисунок 20 - Элемент транзакции

##### 4.4.3.2 Генератор транзакций

Это класс или блок кода, который создаёт элементы транзакций, используемые как инструкции для подачи на входы DUT.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-34.png)

Рисунок 21 - Генератор транзакций

##### 4.4.3.3 Драйвер

Эти структуры берут элементы транзакций и, на основе содержащихся данных, управляют физическими входами входного интерфейса (устанавливая 1 и 0), чтобы ввести данные в DUT. Иногда драйверы требуются и для сложных выходных интерфейсов.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-35.png)

Рисунок 22 - Драйвер

##### 4.4.3.4 Интерфейс

Интерфейс — это просто набор или группа контактов, которые используются для конкретной функции. Например, FIFO обычно имеет два интерфейса: входной и выходной, а двухтактовая память (dual-clock RAM) может иметь четыре: вход для порта A, выход для порта A, вход для порта B, выход для порта B.

Интерфейс может быть классом или структурой, которая объединяет функционально связанные контакты, или, как будет в данном случае, это также может быть неявная группировка контактов без явного объединения в коде.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-36.png)

Рисунок 23 - Интерфейс

##### 4.4.3.5 Монитор

Это по сути полная противоположность драйвера — вместо того чтобы управлять физическими состояниями пинов на интерфейсах, мониторы пассивно наблюдают (мониторят) за тем, что происходит на интерфейсе. Мониторы обычно подключаются к выходному интерфейсу, где они используются для проверки выходных данных устройства под тестом. Кроме того, вы можете увидеть их подключёнными к входным интерфейсам, где они могут проверять, что связанный драйвер корректно управляет интерфейсом.

То, что они делают с данными, полученными в результате наблюдаемых изменений сигналов, зависит от разработчика тестбенча. Мониторы могут быть полностью автономными и самопроверяющими, то есть они могут напрямую выполнять код, который проверяет правильность изменений сигналов по мере появления событий на интерфейсе. Однако, чаще мониторы проектируются так, чтобы генерировать новые элементы транзакций из наблюдаемых изменений состояний контактов интерфейса. Эти элементы транзакций затем отправляются в анализирующие порты табло.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-37.png)

Рисунок 24 - Монитор

##### 4.4.3.6 Табло

Структура табло обычно содержит наибольшую часть самопроверяющего кода тестбенча. Одно табло имеет один или несколько анализирующих (слушающих) портов, которые используются для получения элементов транзакций от мониторов. Табло выполняет проверки на полученных элементах транзакций, чтобы убедиться, что наблюдаемые входные стимулы приводят к корректным выходам, и определяет, прошёл тестбенч или нет.

Обычно в тестбенче используют одно табло, но ничто не мешает вам создать столько, сколько захотите.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-38.png)

Рисунок 25 - Табло

#### 4.4.4 Структура и компоненты транзакционного тестбенча для АЛУ

Подобно базовой блок-схеме на рисункке 26, ниже представлена структура транзакционного тестбенча для АЛУ:

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-40.png)

Рисунок 26 - Блок-схема транзакционного тестового стенда

Необходимо изучить код, который находится в тестбенче ```tb_alu.cpp```.

##### 4.4.4.1 Элемент транзакции AluInTx

У ALU есть входной интерфейс, состоящий из пинов ```op_in```, ``a_in``, ```b_in``` и ```in_valid```. Поэтому необходим класс элемента транзакции, который сможет содержать данные для управления этими контактами. Это можно сделать следующим образом:

```cpp
class AluInTx {
    public:
        uint32_t a;
        uint32_t b;
        enum Operation {
            add = Valu___024unit::operation_t::add,
            sub = Valu___024unit::operation_t::sub,
            nop = Valu___024unit::operation_t::nop
        } op;
};
```

Числовые значения для ```a_in``` и ```b_in``` можно легко хранить в типе ```uint32_t```, который представляет собой беззнаковое 32-битное целое число.

Verilator допускает использование ```uint8_t``` для сигналов шириной до 8 бит, ```uint16_t``` — до 16 бит, ```uint32_t``` — до 32 бит, и ```vluint64_t``` — до 64 бит, и если ширина сигнала меньше или равна размеру переменной, компилятор выполнит автоматическое приведение типов по мере необходимости.

Чтобы задать операцию для операндов ```a``` и ```b```, создается перечисление ```op```, где значения берутся из сгенерированного Verilator кода SystemVerilog АЛУ. Это избавляет от необходимости каждый раз писать длинный префикс ```Valu___024unit::operation_t::```.

Наконец, нам нет необходимости хранить информацию о ```in_valid``` в ```AluInTx``` — драйвер сам будет управлять ```in_valid``` на основе полученного ```AluInTx```.

##### 4.4.4.2 Генератор элементов транзакции rndAluInTx

Теперь, когда готов шаблон для транзакции ```AluInTx```, необходимо написать код, который будет создавать объекты этого типа и присваивать случайные значения операндам. Это делается в генераторе транзакций:

```cpp
AluInTx* rndAluInTx(){
    //20% шанс сгенерировать транзакцию
    if(rand()%5 == 0){
        AluInTx *tx = new AluInTx();
        tx->op = AluInTx::Operation(rand() % 3); // ENUM имеет значения 0, 1, 2
        tx->a = rand() % 11 + 10; // генерируем a в диапазоне 10-20
        tx->b = rand() % 6;  // генерируем b в диапазоне 0-5
        return tx;
    } else {
        return NULL;
    }
}
```

Каждый раз при вызове функции ```rndAluInTx()```, она случайным образом либо:

1. выделяет память под объект ```AluInTx``` (строка 4), присваивает случайные значения ``op``, ```a``` и ```b```, и возвращает указатель на вновь созданный объект (строка 8);

2. либо немедленно возвращает NULL (строка 10), что означает, что транзакция не была сгенерирована.

Причина случайного пропуска генерации каждой второй транзакции — это создание пауз между командами, отправляемыми АЛУ. Возвращение NULL — не единственный способ сделать это: можно пойти противоположным путём и создать последовательность, которая зависит от некоторой временной переменной (например, тиков симуляции или счётчика положительных фронтов), а затем генерировать транзакции только в определённые моменты времени.

##### 4.4.4.3 Драйвер интерфейса ввода AluInDrv

Как только будет сгенерирован элемент транзакции ```AluInTx``` с помощью генератора ```rndAluInTx```, ```AluInTx``` передастся в драйверный блок, который управляет входным интерфейсом АЛУ, используя информацию из этого элемента транзакции. Ниже приведен код драйвера из тестбенча:

```cpp
class AluInDrv {
    private:
        Valu *dut;
    public:
        AluInDrv(Valu *dut){
            this->dut = dut;
        }

        void drive(AluInTx *tx){
            // мы всегда начинаем с установки in_valid в 0, и устанавливаем его в 1 позже, только если это необходимо
            dut->in_valid = 0;

            // Ничего не передаём, если элемент транзакции не существует
            if(tx != NULL){
                if (tx->op != AluInTx::nop) {
                    // Если операция не является NOP, мы передаём её на
                    // пины входного интерфейса
                    dut->in_valid = 1;
                    dut->op_in = tx->op;
                    dut->a_in = tx->a;
                    dut->b_in = tx->b;
                }
                // Освобождаем память, удаляя элемент tx
                // после того как он был использован
                delete tx;
            }
        }
};
```

Конструктор ```AluInDrv``` требует дескриптор на объект dut. Необходимо иметь дескриптор устройства, проходящего тестирование (DUT), внутри драйверов и мониторов, чтобы иметь доступ к его выводам.

На строке 12 видно, что входной сигнал ```in_valid``` всегда по умолчанию устанавливается в ```0```. Это связано с тем, что, если нет допустимого ```AluInTx``` и при этом он не является ```NOP```, входные данные для АЛУ не будут считаться валидными. Примерный эквивалент на SystemVerilog будет таким:

```systemverilog
always_comb begin
    dut.in_valid = 1'b0;
    if ( tx item существует && операция != NOP ) begin
        dut.in_valid = 1'b1;
    end
end
```

Если элемент транзакции не NULL, то на строке 26 происходит удаление (освобождение памяти), где хранится объект транзакции. Это очень важно сделать — как только элемент используется (записывается в DUT), срок его службы заканчивается, и он должен быть удалён, иначе будет утечка памяти.

Важно обратить внимание, что C++ поддерживает умное управление памятью. Однако для целей объяснения, ручное управление памятью лучше иллюстрирует срок жизни элементов транзакций.

##### 4.4.4.4 Монитор входного интерфейса AluInMon

```AluInMon``` следит за входным интерфейсом АЛУ, выполняя противоположные действия драйверу, который были рассмотрены ранее.

```cpp
class AluInMon {
    private:
        Valu *dut;
        AluScb *scb;
    public:
        AluInMon(Valu *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            if (dut->in_valid == 1) {
                // Если на входном интерфейсе есть валидные данные,
                // создаём новый элемент транзакции AluInTx и заполняем
                // его данными, считанными с пинов интерфейса
                AluInTx *tx = new AluInTx();
                tx->op = AluInTx::Operation(dut->op_in);
                tx->a = dut->a_in;
                tx->b = dut->b_in;

                // затем передаём элемент транзакции в scoreboard
                scb->writeIn(tx);
            }
        }
};
```

Здесь на строке 12 можно заметить сигнал ```in_valid``` на входе АЛУ. Если вход валидный, монитор создаёт новый элемент транзакции ```AluInTx```, считывает значения ```op_in```, ```a_in```, ```b_in``` контактов и помещает их в ```AluInTx``` переменные ```op```, ```a```, и ```b```.

Этот новый элемент транзакции сообщает, какую операцию отправили на входы АЛУ, что будет нужно для проверки корректности выходных данных АЛУ. Поэтому на строке 22 новая транзакция записывается в таблицу для последующего использования.

##### 4.4.4.5 Элемент транзакции AluOutTx

Точно так же, как ```AluInTx``` элемент транзакции для операций с интерфейсом ввода, ```AluOutTx``` элемент транзакции для хранения информации о результатах, получаемых с помощью интерфейса вывода.

Однако, поскольку единственное, что предоставляется на выходе — это одно значение результата, ```AluOutTx``` содержит только одну переменную:

```cpp
class AluOutTx {
    public:
        uint32_t out;
};
```

##### 4.4.4.6 Монитор выходного интерфейса AluOutMon

Здесь вступает в действие элемент ```AluOutTx```. Точно так же, как монитор входа, ```AluOutMon``` наблюдает выходной интерфейс аналогичным образом:

```cpp
class AluOutMon {
    private:
        Valu *dut;
        AluScb *scb;
    public:
        AluOutMon(Valu *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            if (dut->out_valid == 1) {
                // Если на выходном интерфейсе валидные данные,
                // создаём новый элемент AluOutTx и заполняем
                // его результатом, считанным с пинов интерфейса
                AluOutTx *tx = new AluOutTx();
                tx->out = dut->out;

                // затем передаём элемент транзакции в scoreboard
                scb->writeOut(tx);
            }
        }
};
```

```AluOutMon``` ждёт, пока сигнал ```out_valid``` не станет равным 1. Когда это происходит, создаётся новый элемент ```AluOutTx``` (строка 16), значение на выходных контактах испытуемого устройства сохраняется в ```out``` переменной в ```AluOutTx``` элементе, а затем элемент передаётся на табло.

##### 4.4.4.7 Табло AluScb

Табло - это самый важный блок в тестбенче, это мозг всей операции:

```cpp
// Табло ALU
class AluScb {
    private:
        std::deque<AluInTx*> in_q;

    public:
        // Порт монитора входного интерфейса
        void writeIn(AluInTx *tx){
            // Поместить полученный элемент транзакции в очередь для последующей обработки
            in_q.push_back(tx);
        }

        // Порт монитора выходного интерфейса
        void writeOut(AluOutTx* tx){
            // Мы никогда не должны получать данные из выходного интерфейса
            // до тех пор, пока на входной интерфейс не будет подано значение
            if(in_q.empty()){
                std::cout <<"Фатальная ошибка в AluScb: пустая очередь AluInTx" << std::endl;
                exit(1);
            }

            // Извлекаем элемент транзакции из начала очереди входных элементов
            AluInTx* in;
            in = in_q.front();
            in_q.pop_front();

            switch(in->op){
                // На выходе не должен появляться валидный сигнал, если операция отсутствует,
                // поэтому мы не должны получать транзакцию с операцией NOP
                case AluInTx::nop :
                    std::cout << "Фатальная ошибка в AluScb, получен NOP на входе" << std::endl;
                    exit(1);
                    break;

                // Получена транзакция сложения
                case AluInTx::add :
                    if (in->a + in->b != tx->out) {
                        std::cout << std::endl;
                        std::cout << "AluScb: несоответствие при сложении" << std::endl;
                        std::cout << "  Ожидалось: " << in->a + in->b
                                  << "  Фактически: " << tx->out << std::endl;
                        std::cout << "  Время симуляции: " << sim_time << std::endl;
                    }
                    break;

                // Получена транзакция вычитания
                case AluInTx::sub :
                    if (in->a - in->b != tx->out) {
                        std::cout << std::endl;
                        std::cout << "AluScb: несоответствие при вычитании" << std::endl;
                        std::cout << "  Ожидалось: " << in->a - in->b
                                  << "  Фактически: " << tx->out << std::endl;
                        std::cout << "  Время симуляции: " << sim_time << std::endl;
                    }
                    break;
            }
            // Так как элементы транзакций были размещены в куче, важно
            // освободить память после их использования
            delete in;
            delete tx;
        }
};
```

С самого начала создаётся очередь для хранения элементов транзакций ```AluInTx``` в табло:

```cpp
std::deque<AluInTx*> in_q;
```

Каждый раз, когда в АЛУ отправляется допустимая операция, монитор входного интерфейса записывает элемент ```AluInTx``` в табло через метод writeIn (строка 8). Элемент ```AluInTx``` необходимо сравнить с соответствующим элементом ```AluOutTx```, чтобы проверить правильность результата АЛУ. Так как АЛУ конвейерный, можно отправить несколько команд на входной интерфейс до того, как придут какие-либо выходные элементы ```AluOutTx```. Поэтому элементы ```AluInTx``` нужно сохранять для последующей проверки, и очередь идеально подходит для этой задачи.

Метод ```writeOut``` (строка 14) — это место, где происходит вся проверка результатов. Сначала, на строке 17, проверяется, не выдаёт ли АЛУ случайный мусор на выходе — результат на выходе должен появиться только после того, как допустимая операция была подана на вход, поэтому никогда не должно быть такого момента, когда результат на выходе появился раньше, чем хотя бы один элемент ```AluInTx``` в очереди.

Далее, если очередь ```in_q``` не пуста, из нее извлекается первый (самый старый) элемент ```AluInTx``` и переходит к оператору ```switch``` на строке 27. Первый случай ```switch``` (строка 30) проверяет правильность работы тестбенча — валидный сигнал не должен появляться на входе при операции ```NOP```, и если элемент ```AluInTx``` с операцией ```NOP``` попал в табло, это значит, что драйвер ```AluInDrv``` работает некорректно.

В оставшихся случаях, в зависимости от того, является ли операция сложением (строка 36) или вычитанием (строка 47), необходимо сложить или вычесть операнды из ```AluInTx``` и сравнивнить с результатом в ```AluOutTx```.

В конце метода ```writeOut```, элементы транзакций удаляются (строки 59 и 60), так как они больше не нужны.

#### 4.4.5 Сборфункционала воедино

Главный цикл — это место, где происходит вся верификационная "магия". Функция ```main``` содержит создание всех блоков тестбенча (мониторы, драйвер, табло), а затем в главном цикле итеративно вызываются функции всех этих блоков до окончания симуляции. Или до тех пор, пока тестбенч не завершится с ошибкой. Ниже представлен код функции main и основного симуляционного цикла:

```cpp
int main(int argc, char** argv, char** env) {
    <...>

    AluInTx   *tx;

    // Создаём драйвер, табло и блоки мониторов входа и выхода
    AluInDrv  *drv    = new AluInDrv(dut);
    AluScb    *scb    = new AluScb();
    AluInMon  *inMon  = new AluInMon(dut, scb);
    AluOutMon *outMon = new AluOutMon(dut, scb);

    while (sim_time < MAX_SIM_TIME) {
        dut_reset(dut, sim_time);
        dut->clk ^= 1;
        dut->eval();

        // Все действия по управлению/мониторингу выполняются на положительном фронте
        if (dut->clk == 1){

            if (sim_time >= VERIF_START_TIME) {
                // Генерация случайной транзакции AluInTx
                tx = rndAluInTx();

                // Передача транзакции драйверу ALU,
                // который управляет входами на основе данных в транзакции
                drv->drive(tx);

                // Мониторинг входного интерфейса
                inMon->monitor();

                // Мониторинг выходного интерфейса
                outMon->monitor();
            }
        }
        // конец обработки положительного фронта

        m_trace->dump(sim_time);
        sim_time++;
    }

    <...>
    delete dut;
    delete outMon;
    delete inMon;
    delete scb;
    delete drv;
    exit(EXIT_SUCCESS);
}
```

После создания блоков тестбенча (строки 14-17), симуляция входит в главный цикл на строке 19, который выполняется до конца симуляционного времени.

На каждой итерации цикла проверяется, наступил ли положительный фронт тактового сигнала (строка 25). Если да, тестбенч генерирует транзакцию ```AluInTx``` (строка 28).

Эта транзакция передаётся драйверу ```AluInDrv``` (строка 33), который управляет входными линиями АЛУ по информации из транзакции.

На этом же фронте монитор ```AluInMon``` наблюдает входные линии (строка 36) и из наблюдений формирует новый элемент ```AluInTx```, который записывается в табло.

Также на этом же фронте монитор ```AluOutMon``` следит за выходами АЛУ (строка 39), но транзакции ```AluOutTx``` пока не создаются из-за задержки в АЛУ по конвейеру — нужно минимум две итерации цикла, прежде чем результаты появятся.

После завершения симуляции все блоки тестбенча удаляются для освобождения памяти (строки 46-50).

#### 4.4.6 Симуляция

Для запуска симуляции, достаточно выполнить ```make``` в каталоге проекта — это соберёт и запустит тестбенч. Никакого интересного вывода не будет, потому что АЛУ и тестбенч работают корректно, тест проходит без ошибок.

Но это не очень информативно, поэтому можно посмотреть, что будет, если что-то пойдёт не так.

#### 4.4.7 Плохие результаты АЛУ

Легко обнаружить, если АЛУ выдаёт неправильные результаты, табло сразу пожалуется. Если моделировать АЛУ вот так:

```verilog
out       <= 6'h5; // должно быть "<= result"
out_valid <= in_valid_r;
```

Тогда табло тут же засечёт ошибку:

```verilog
AluScb: add mismatch
  Expected: 15  Actual: 5
  Simtime: 204

AluScb: sub mismatch
  Expected: 11  Actual: 5
  Simtime: 234

AluScb: add mismatch
  Expected: 17  Actual: 5
  Simtime: 236
```

#### 4.4.8 Неожиданный out_valid в АЛУ

Если сделать так, чтобы АЛУ всегда сигнализировало валидный выход:

```verilog
out       <= result;
out_valid <= 1'b1; // должно быть "<= in_valid_r"
```

Тогда тестовый стенд немедленно завершит работу с фатальной ошибкой при первом обнаружении некорректного корректного вывода:

```verilog
./obj_dir/Valu +verilator+rand+reset+2 
Fatal Error in AluScb: empty AluInTx queue
make: *** [Makefile:23: waveform.vcd] Error 1
```
Это потому что табло не ожидает увидеть выходные данные, если на вход ранее не подавалась команда.

#### 4.4.9 Графическое представление

С помощью GTKWave, можно выполнить ```make waves```, чтобы посмотреть на случайно сгенерированные транзакции в виде волн.

![alt text](/Lab_2/Lab_2_theory/Images/verilator/image-41.png)

Рисунок 27 - Графическое представление


## 5. Описание работы виртуального стенда 8 разрядного АЛУ на виртуальной плате DE10-Lite 

![alt text](https://github.com/YarosLove91/Virtual_DE_stands/blob/virtual_stand_DE10_LITE/images/screenshot.jpg?raw=true)

### 5.1 Описание проекта

Эмулятор платы DE10-Lite с полным функционалом, включая:
- Графический интерфейс пользователя
- Сетевое взаимодействие с Verilog-симуляцией
- 10 переключателей
- 10 светодиодов
- 6 семисегментных индикаторов
- 2 кнопки
- Сохранение и загрузка состояний

### 5.2 Основные возможности

- Точная эмуляция компонентов платы DE10-Lite
- Интерактивное взаимодействие с Verilog-симуляцией
- Адаптивный интерфейс с масштабированием
- Гибкая система конфигурации
- Сохранение положений переключателей и кнопок между сеансами
- Сброс состояния к значениям по умолчанию

### 5.3 Требования

#### 5.3.1 Для графического клиента

- Python 3.6+
- Библиотеки:
  - `tkinter`
  - `Pillow` (PIL)
  - `json`
  - `configparser`

#### 5.3.2 Для Verilog сервера

- Verilator 4.0+
- Компилятор с поддержкой C++17
- Библиотеки:
  - `libjsoncpp`
  - `pthread`

### 5.4 Установка

1. Клонируйте репозиторий:
```bash
git clone -b stand_ALU_8b https://git.miem.hse.ru/1963/virtual_fpga_boards.git
cd virtual_fpga_boards
```

2. Установите зависимости Python:
```bash
pip install pillow
```

3. Соберите сервер:
```bash
make build
```

### 5.5 Использование

Возможен одновременный запуск через Makefile или запуск графического клиента и сервера по отдельности.
Во втором случае при запуске графического клиента можно ввести параметры расширения окна.

## 5.6 Запуск через Makefile

```bash
make run
```

## 5.7 Запуск графического клиента

```bash
python app.py [--width ШИРИНА] [--height ВЫСОТА] [--config ФАЙЛ]
```

Параметры:

--width: Ширина окна в пикселях (переопределяет конфиг)

--height: Высота окна в пикселях (переопределяет конфиг)

--config: Путь к файлу конфигурации (по умолчанию: config.ini)

## 5.8 Файл конфигурации

Отредактируйте config.ini для настройки размеров окна:

```ini
[DEFAULT]
width = 800
height = 500
```

## 5.9 Запуск сервера

```bash
./server
```
### 5.9.1 Функционал графического интерфейса

- Переключатели: 10 переключателей, которые можно включать и выключать. Их состояние сохраняется между сеансами.
- Кнопки: 2 кнопки, которые остаются "нажатыми" после клика и возвращаются в исходное состояние при повторном клике.
- Светодиоды: 10 светодиодов, отображающих состояние.
- Семисегментные индикаторы: 6 индикаторов, отображающих значения.
- Кнопка "Save": Сохраняет текущее состояние переключателей и кнопок в файл state.pkl.
- Кнопка "Load": Загружает сохраненное состояние из файла state.pkl.
- Кнопка "Reset": Сбрасывает состояние переключателей и кнопок к значениям по умолчанию.

### 5.9.2 Makefile

Доступные команды:

| Команда          | Описание                                                                 |
|------------------|--------------------------------------------------------------------------|
| `make`           | Показывает справку по доступным командам                                |
| `make build`     | Собирает проект (верилирует Verilog и компилирует C++ код)              |
| `make run`       | Собирает и запускает сервер                                             |
| `make clean`     | Удаляет все сгенерированные файлы сборки                                |
| `make check_python` | Проверяет версию Python (должна быть 3.6+)                          |

### 5.9.3 Таблица сигналов

На виртуальной плате DE10-Lite загружено 8-битное АЛУ, которое поддерживает арифметические и логические операции. Ниже приведено описание сигналов, подключенных к элементам платы.

| **Сигнал**         | **Описание**                              | **Подключение**                     |
|---------------------|------------------------------------------|--------------------------------------|
| `alu_result[7:0]`  | Результат работы АЛУ                     | LEDR0-LEDR7, HEX0-HEX1              |
| `alu_cout`         | Перенос (Carry Out)                      | LEDR8                               |
| `a_reg[7:0]`       | Регистр операнда A                      | SW3-0 и KEY0 (запись)             |
| `b_reg[7:0]`       | Регистр операнда B                      | SW3-0 и KEY0 (запись)            |
| `sel[3:0]`         | Код операции АЛУ                        | SW[7:4]                             |
| `KEY[1]`           | Режим работы АЛУ (арифметический/логический) | KEY1                              |
| `SW[9]`            | Выбор операнда (A или B)                 | SW9                                |
| `SW[8]`            | Выбор части операнда (младшая/старшая)    | SW8                                |
| `KEY[0]`           | Запись данных в регистр                 | KEY0                                |
| `HEX[3:2]`        | Отображение операнда A                  | HEX2 (младшая часть), HEX3 (старшая часть) |
| `HEX[5:4]`        | Отображение операнда B                  | HEX4 (младшая часть), HEX5 (старшая часть) |

## 6. Описание работы виртуальный стенд 16 разрядного АЛУ на виртуальной плате DE2-115 (+ листинг код Verilog)
 
![alt text](https://github.com/YarosLove91/Virtual_DE_stands/blob/virtual_stand_DE2_115/images/screenshot.jpg?raw=true)

### 6.1 Описание проекта

Эмулятор платы DE2-115 с полным функционалом, включая:
- Графический интерфейс пользователя
- Сетевое взаимодействие с Verilog-симуляцией
- 18 переключателей
- 18 красных светодиодов
- 8 зеленых светодиодов
- 8 семисегментных индикаторов
- 4 кнопки
- Сохранение и загрузка состояний

### 6.2 Основные возможности

- Точная эмуляция компонентов платы DE2-115
- Интерактивное взаимодействие с Verilog-симуляцией
- Адаптивный интерфейс с масштабированием
- Гибкая система конфигурации
- Сохранение положений переключателей и кнопок 
- Сброс состояния к значениям по умолчанию

### 6.3 Требования

#### 6.3.1 Для графического клиента

- Python 3.6+
- Библиотеки:
  - `tkinter`
  - `Pillow` (PIL)
  - `json`
  - `configparser`

#### 6.3.2 Для сервера

- Verilator 4.0+
- Компилятор с поддержкой C++17
- Библиотеки:
  - `libjsoncpp`
  - `pthread`

### 6.4 Установка

1. Клонируйте репозиторий:
```bash
git clone -b virtual_stand_DE2_115 https://github.com/YarosLove91/Virtual_DE_stands.git
cd Virtual_DE_stands
```

2. Установите зависимости Python:
```bash
pip install pillow
```

3. Соберите сервер:
```bash
make build
```

### 6.5 Использование

Возможен одновременный запуск через Makefile или запуск графического клиента и сервера по отдельности.
Во втором случае при запуске графического клиента можно ввести параметры расширения окна.

### 6.6  Запуск через Makefile

```bash
make run
```

### 6.7 Запуск графического клиента

```bash
python app.py [--width ШИРИНА] [--height ВЫСОТА] [--config ФАЙЛ]
```

Параметры:

--width: Ширина окна в пикселях (переопределяет конфиг)

--height: Высота окна в пикселях (переопределяет конфиг)

--config: Путь к файлу конфигурации (по умолчанию: config.ini)

### 6.8 Файл конфигурации

Отредактируйте config.ini для настройки размеров окна:

```ini
[DEFAULT]
width = 1024
height = 768
```

### 6.9 Запуск сервера

```bash
./server
```

#### 6.9.1 Функционал графического интерфейса

- Переключатели: 18 переключателей, которые можно включать и выключать. Их состояние сохраняется между сеансами.
- Кнопки: 4 кнопки. Кнопки автоматически отпускаются через малое количество времени после нажатия (эмулируется кратковременное нажатие).
- Красные светодиоды: 18 светодиодов, отображающих состояние.
- Зеленые светодиоды: 8 светодиодов, отображающих режимы работы.
- Семисегментные индикаторы: 8 индикаторов, отображающих значения.
- Кнопка "Save": Сохраняет текущее состояние переключателей и кнопок в файл state.pkl.
- Кнопка "Load": Загружает сохраненное состояние из файла state.pkl.
- Кнопка "Reset": Сбрасывает состояние переключателей и кнопок к значениям по умолчанию.

#### 6.9.2 Makefile

Доступные команды:

| Команда          | Описание                                                                 |
|------------------|--------------------------------------------------------------------------|
| `make`           | Показывает справку по доступным командам                                |
| `make build`     | Собирает проект (верилирует Verilog и компилирует C++ код)              |
| `make run`       | Собирает и запускает сервер                                             |
| `make clean`     | Удаляет все сгенерированные файлы сборки                                |
| `make check_python` | Проверяет версию Python (должна быть 3.6+)                          |

### 6.10 Таблица сигналов

На виртуальной плате DE2-115 загружено 16-битное АЛУ, которое поддерживает арифметические и логические операции. Ниже приведено описание сигналов, подключенных к элементам платы.

| **Сигнал**         | **Описание**                              | **Подключение**                     |
|---------------------|------------------------------------------|--------------------------------------|
| `alu_result[15:0]` | Результат работы АЛУ                     | LEDR0-LEDR15, HEX0-HEX3 |
| `alu_cout`         | Перенос (Carry Out)                      | LEDG0               |
| `a_reg[15:0]`      | Регистр операнда A                      | SW7-SW0 и KEY0 (запись), KEY1 (сброс) |
| `b_reg[15:0]`      | Регистр операнда B                      | SW7-SW0 и KEY0 (запись), KEY2 (сброс) |
| `sel[3:0]`         | Код операции АЛУ                        | SW14-SW11         |
| `mode`             | Режим работы АЛУ (арифметический/логический) | SW15           |
| `carry_in`         | Входной перенос (Carry In)               | SW8               |
| `SW[9]`              | Выбор операнда (A или B)                 | SW9                                 |
| `SW[10]`      | Выбор части операнда (младшая/старшая)    | SW10                                |
| `KEY[0]`            | Запись данных в регистр                 | KEY0                                |
| `KEY[1]`          | Сброс регистра A                        | KEY1                                |
| `KEY[2]`          | Сброс регистра B                        | KEY2         