# 3. Традиционный пример верефикации

## 3.1 Создание typedef ```operation_t``` доступным в тестбенче на C++

Прежде чем начать проверять, правильно ли АЛУ складывает или вычитает два числа, для начала необходимо сделать typedef операции доступным в тестбенче ```tb_alu.cpp```.

В начале кода АЛУ есть следующее:

```verilog
typedef enum logic [1:0] {
  add = 2'h1,
  sub = 2'h2,
  nop = 2'h0
} operation_t /*verilator public*/;
```

Обратите внимание на комментарий ```/*verilator public*/``` после имени ```operation_t```. Это говорит Verilator преобразовать этот typedef в C++ и сделать его общедоступным — это происходит во время шага верилации (конвертация HDL в C++).

Такие комментарии называются директивами или прагмами — они дают Verilator дополнительную информацию о том, как обрабатывать HDL-код. Список таких директив можно найти в руководстве по расширениям языка Verilator.

Если посмотреть в папку ```obj_dir```, где находятся артефакты конверсии, можно найти файл ```Valu___024unit.h```, который содержит верифицированную версию перечисления typedef:

```cpp
// TYPEDEFS
// That were declared public
enum operation_t {
    add = 1U,
    sub = 2U,
    nop = 0U
};
```
Если бы комментарий ```/*verilator public*/``` не был добавлен, этот typedef не был бы доступен в заголовочном файле.

Так как этот заголовок уже включен в ```tb_alu.cpp``` (```#include "Valu___024unit.h"```), теперь можно ем использовать определения внутри перечисления (enum) для задания входа ```op_in``` АЛУ.

Значения перечисления затем могут быть доступны в тестбенче следующим образом:

```cpp
Valu___024unit::operation_t::add
Valu___024unit::operation_t::sub
```
На этом этапе есть всё необходимое, чтобы приступить к проверке функциональности сложения и вычитания АЛУ.

## 3.2 Пример традиционной (временной) верификации

Ранее был продемонстрирован примитивный метод проектирования тестбенча, который проверял корректность работы сигнала ```out_valid``` у АЛУ.

Ранее проверялось, что пайплайн между ```in_valid``` и ```out_valid``` работает правильно, задавая ```1``` на ```in_valid``` на пятом такте и проверяя, что ```out_valid``` равен ```1``` на седьмом такте:

```cpp
if (posedge_cnt == 5){
    dut->in_valid = 1; // устанавливаем in_valid на 5-м такте
}
if (posedge_cnt == 7){
    if (dut->out_valid != 1) // проверяем out_valid на 7-м такте
        std::cout << "ERROR!" << std::endl;
}
```
Этот пример сам по себе довольно слабый (а что если ```out_valid``` всегда застревал на ```1```?), но он хорошо иллюстрирует сутьЭто назвается традиционным или временным стилем верификации, потому что на вход явно подается конкретное входное значение в определённый момент времени и проверяется, что выходные значения соответствуют ожидаемым после некоторого времени. Этот стиль отлично подходит для быстрой проверки небольших схем, хотя может быть не лучшим выбором при работе со сложными модулями.

### 3.2.1 Временные стимулы

На данном этапе основной цикл должен выглядеть так:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        set_rnd_out_valid(dut, sim_time);
        check_out_valid(dut, sim_time);
    }
    m_trace->dump(sim_time);
    sim_time++;
}
```

Можно выполнить операцию сложения на такте 10 и вычитания на такте 20. Для этого необходимо убрать функцию случайной передачи, которая находится в строке 10, и заменить её на оператор switch следующим образом:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        switch (posedge_cnt){
            case 10:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::add;
                break;

            case 20:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::sub;
                break;
        }
        check_out_valid(dut, sim_time);
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

Как видно, в обоих случаях устанавливается ```dut->in_valid``` в ```1```, задаются некоторые входные операнды в ```dut->a_in``` и ```dut->b_in```, а затем устанавливается ```dut->op_in``` в желаемую операцию: сложение на 10-м такте и вычитание на 20-м. При симуляции можно увидеть, как это работает на Рисунке 11:

![alt text](../Images/image-31.png)
Рис. 11: Результаты симуляции сложения и вычитания

Из рисунка 11 видно, что АЛУ работает корректно.

### 3.2.2 Проверка результатов по времени

Конвейер АЛУ всегда занимает фиксированное количество — 2 такта — чтобы обработать входные данные и вернуть результат на выходах, поэтому можно добавить проверки на 12-м и 22-м тактах для верификации результатов:

```cpp
switch (posedge_cnt){
    case 10:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::add;
        break;

    case 12:
        if (dut->out != 8)
            std::cout << "Addition failed @ " << sim_time << std::endl;
        break;

    case 20:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::sub;
        break;

    case 22:
        if (dut->out != 2)
            std::cout << "Subtraction failed @ " << sim_time << std::endl;
        break;
}
```
Нет необходимости явно проверять, что ```out_valid``` корректен в случаях 12 и 22 — это по-прежнему делает функция ```check_out_valid()```.

Если на данном этапе запустить симуляцию, можно увидеть, что она проходит без проблем, потому что АЛУ написано правильно. Однако, если открыть```alu.sv``` и изменить вектор результата ```result```:

```verilog
//sub: result = a_in_r + (~b_in_r+1'b1); // оригинал
sub: result = a_in_r + (~b_in_r+6'h3);   // модифицировано
```

Можно будет заметить, что симуляция провалится и укажет нам, где была обнаружена ошибка:

```perl
### SIMULATING ###
./obj_dir/Valu +verilator+rand+reset+2
Subtraction failed @ 42
```

## 3.3 Подведение временных итогов

Это руководство демонстрирует примитивный пример верификационного кода на C++, который можно использовать для выполнения базовых задач верификации. Существует множество вариаций того, как можно структурировать такой код — можно использовать операторы ```switch```, как показано здесь, отдельные ```if```- выражения или разбивать код на отдельные функции. Однако, скорее всего, вы согласитесь, что такой метод верификации, хотя простой и быстрый в реализации, на самом деле недостаточен для более сложных проектов.
