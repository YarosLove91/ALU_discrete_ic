# 1. Описание Verilator

Verilator — это инструмент, который компилирует исходные тексты на Verilog и SystemVerilog в высокооптимизированный (и опционально многопоточный) точный цикл C++ или SystemC код. Преобразованные модули можно инстанцировать и использовать в тестбенчах на C++ или SystemC для целей верификации и/или моделирования.

## 1.1 Достоинства Verilator

Verilator — это симулятор Verilog/SystemVerilog, промышленного уровня, очень быстрый, бесплатный и с открытым исходным кодом. Однако, Verilator нельзя считать прямым аналогом таких инструментов как, как Modelsim, Questa Sim, Synopsys VCS, Vivado Xsim и других симуляторов, основанных на событиях. Verilator — это цикл-ориентированный симулятор, что означает, что он не вычисляет события внутри одного такта и не симулирует точное временное поведение схемы. Вместо этого состояние схемы обычно пересчитывается один раз за такт, поэтому любые внутритактовые "глитчи" (скачки сигнала) не видны, а задержки сигналов по времени не поддерживаются. Это одновременно и плюс, и минус по сравнению с другими симуляторами.

### 1.1.1 Скорость

Так как Verilator является цикл-ориентированным, его нельзя использовать для таймингового моделирования, симуляции с обратной аннотацией временных параметров (back-annotated netlists), асинхронной (безтактной) логики, или вообще для любых изменений сигналов, которые завязаны на время — все выходы переключаются мгновенно при каждом вызове схемы.

Однако, именно за счёт игнорирования всего, что происходит между фронтами тактов, симуляции в Verilator идут чрезвычайно быстро. Он отлично подходит для функционального моделирования синхронных цифровых схем с одним или несколькими тактами, а также для создания программных моделей из кода на Verilog/SystemVerilog, которые можно использовать при разработке ПО.

### 1.1.2 Качество кода

Так как Verilator использует цикл-ориентированный подход, он не может полностью поддерживать стандарты IEEE Verilog и SystemVerilog. Тем не менее, инструменты синтеза обычно тоже не полностью совместимы с этими стандартами.

Помимо того, что Verilator не поддерживает временные задержки, он также не принимает большую часть неконструкционного (несинтезируемого) кода (за исключением таких элементов, как ```$display()```, ```$finish()```, ```$fatal()```), поэтому, как правило, не любой тестбенч на SystemVerilog получится скомпилировать в Verilator без серьёзных изменений. Если код не поддерживается, Verilator выдаст большое количество предупреждений и ошибок.

Благодаря тому, что Verilator не поддерживает несинтезируемый код — его поведение ближе к инструментам синтеза по сравнению с другими симуляторами. Это вынуждает писать код более "чистый" с точки зрения синтеза, что потенциально сокращает количество проблем на более поздних стадиях разработки.

### 1.1.3 Стоимость

Verilator — это бесплатный инструмент с открытым исходным кодом. Для симуляции схемы с помощью Verilator создаётся нативный исполняемый файл из преобразованного HDL-кода и тестбенча на C++ с помощью компилятора GCC и системы сборки Make. Так как весь инструментарий бесплатен, нет никаких ограничений по количеству запускаемых экземпляров или числу пользователей. Благодаря высокой скорости работы Verilator позволяет быстро выполнять симуляции даже сложных схем на старых компьютерах и ноутбуках, так что нет необходимости в дорогом вычислительном оборудовании. 

![alt text](../Images/image-23.png)

Рисунок 1 - Пользователи Verilator

## 1.2 Начало работы

В данной работе предполагается, что вы используете какую-либо версию Linux на своём компьютере и что у вас уже установлены Verilator, GTKWave, Make и GCC.

```bash
    git clone https://github.com/n-kremeris/verilator_basics
    git checkout verilator_pt1
```

## 1.3 Создание DUT

Чтобы проверить, как работает Verilator, необходимо устройство для тестирования (DUT — device under test). В данной работе представлена простая АЛУ на SystemVerilog. Исходный код приведён ниже:

``` sv
/****** alu.sv ******/
typedef enum logic [1:0] {
     add     = 2'h1,
     sub     = 2'h2,
     nop     = 2'h0
} operation_t /*verilator public*/;

module alu #(
        parameter WIDTH = 6
) (
        input clk,
        input rst,

        input  operation_t  op_in,
        input  [WIDTH-1:0]  a_in,
        input  [WIDTH-1:0]  b_in,
        input               in_valid,

        output logic [WIDTH-1:0]  out,
        output logic              out_valid
);

        operation_t  op_in_r;
        logic  [WIDTH-1:0]  a_in_r;
        logic  [WIDTH-1:0]  b_in_r;
        logic               in_valid_r;
        logic  [WIDTH-1:0]  result;

        // Register all inputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        op_in_r     <= '0;
                        a_in_r      <= '0;
                        b_in_r      <= '0;
                        in_valid_r  <= '0;
                end else begin
                        op_in_r    <= op_in;
                        a_in_r     <= a_in;
                        b_in_r     <= b_in;
                        in_valid_r <= in_valid;
                end
        end

        // Compute the result
        always_comb begin
                result = '0;
                if (in_valid_r) begin
                        case (op_in_r)
                                add: result = a_in_r + b_in_r;
                                sub: result = a_in_r + (~b_in_r+1'b1);
                                default: result = '0;
                        endcase
                end
        end

        // Register outputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        out       <= '0;
                        out_valid <= '0;
                end else begin
                        out       <= result;
                        out_valid <= in_valid_r;
                end
        end

endmodule;
```

Для начала работы необходимо создать новый рабочий каталог и сохранить исходный код АЛУ под именем alu.sv.

Как вы можете видеть, это АЛУ очень простое. Оно имеет два регистрационных этапа, не поддерживает остановку (stalling) и выполняет только две операции: сложение и вычитание. На рисунке 2 пример временной диаграммы, показывающей, ожидаемую работу АЛУ:

![alt text](../Images/image-22.png)

Рисунок 2 - Примитивный конвейер АЛУ

Из рисунка 2 видно, что на первом этапе входные сигналы записываются в регистры, а на втором этапе комбинационный результат также записывается в выходные регистры. Этого понимания достаточно, чтобы рассмотреть шаги, необходимые для создания базового тестбенча.

## 1.4 Преобразование SystemVerilog в C++

### 1.4.1 Верификация с помощью Verilator

Как упоминалось во введении, Verilator требует, чтобы тестбенч на C++ компилировался в исполняемый файл системы. Однако, невозможно без предварительной подготовки включить SystemVerilog АЛУ в тестбенч на C++. Для начала необходимо использовать Verilator, чтобы преобразовать код SystemVerilog в C++, или «верилировать» его, что в самом базовом виде выполняется так:

```css
verilator --cc alu.sv
```
Параметр --cc говорит Verilator выполнить преобразование в C++. Verilator также поддерживает преобразование в SystemC (для этого используется параметр --sc).
  
### 1.4.2 Результаты преобразования

Выполнение приведённой выше команды создаёт новую папку с именем ```obj_dir``` в рабочем каталоге. Именно туда попадают все преобразованные исходники:

```
$ ls -l obj_dir/
Valu___024unit.cpp  Valu___024unit__Slow.cpp  Valu.cpp  Valu.mk
Valu__Syms.cpp  Valu__ver.d  Valu___024unit.h  Valu_classes.mk
Valu.h  Valu__Slow.cpp  Valu__Syms.h  Valu__verFiles.dat
```

Сгенерированные файлы с расширением ```.mk``` будут использоваться с ```Make``` для сборки исполняемого файла симуляции, а файлы ```.h``` и ```.cpp``` содержат заголовки C++ и исходные коды реализации, полученные в результате преобразования из SystemVerilog. 

Два наиболее важных, на данный момент, файла:

- ```Valu.h``` — это основной заголовочный файл, содержащий определение класса преобразованного «ALU». Именно этот класс будет «инстанцирован» в тестбенче на C++ как DUT;

- ```Valu___024unit.h``` — это внутренний заголовок для класса «ALU», который содержит определение типа operation_t.

## 1.5 Разработка базового тестбенча для Verilator

### 1.5.1 Пример тестбенча на C++

После того как DUT (устройство под тестированием) преобразован в C++,  можно начать писать тестбенч. Тестбенч будет находиться в новом файле с именем ```tb_alu.cpp```. Минимальный пример кода тестбенча  приведен ниже на C++:

```cpp
#include <stdlib.h>
#include <iostream>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Valu.h"
#include "Valu___024unit.h"

#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut->clk ^= 1;
        dut->eval();
        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```

Первые несколько строк с директивами ```#include``` в понятны сами по себе: подключается <verilated.h> и <verilated_vcd_c.h>, которые идут с установкой Verilator, чтобы получить доступ к основным функциям Verilator и записывать временные диаграммы в файл формата VCD (value change dump).

Как уже упоминалось, ```"Valu.h"``` содержит основной класс Verilated-модуля АЛУ, а ```"Valu___024unit.h"``` содержит преобразованное Verilator определение перечисления typedef.

Далее идут две строки:

```cpp
#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;
```

Переменная ```sim_time``` используется для отслеживания момента завершения симуляции. Существует несколько способов остановки симуляции, но в данном примере симуляция завершается после 20 фронтов тактового сигнала.

Затем идет основная функция main():

```cpp

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    /* <...> */

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```
Строка ```Valu dut = new Valu;``` создаёт экземпляр преобразованного модуля АЛУ. В SystemVerilog это примерно аналогично записи ```alu dut (.);```.

Следующие четыре строки настраивают запись временных диаграмм. Создается объект ```m_trace``` и передается устройству ```dut``` в строке ```dut->trace(m_trace, 5);```. Параметр 5 ограничивает глубину трассировки до 5 уровней вниз по иерархии DUT.

Ниже представлена часть, которая выполняет симуляцию:

```cpp

while (sim_time < MAX_SIM_TIME) {
    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Во время каждой итерации цикла строка ```dut->clk ^= 1;``` инвертирует сигнал тактового генератора АЛУ (создавая фронты/спады такта). Это будет единственный тактовый сигнал, который используется в тестбенче.

Вызов ```dut->eval();``` производит вычисление всех сигналов модуля АЛУ, а ```m_trace->dump(sim_time);``` записывает все трассированные сигналы в файл временных диаграмм. Как видно, модель вычисляется только по фронтам тактового сигнала.

Переменная времени симуляции затем увеличивается, и цикл продолжается до достижения ```MAX_SIM_TIME```. Обратите внимание, что это не реальное время — переменная просто считает, сколько раз инвертировали такт.

Как видно, этот тестбенч пока что только тактирует модель, но это хорошая отправная точка для дальнейшей разработки.

### 1.5.2 Сборка исполняемого файла симуляции

Когда тестбенч написан, необходимо собрать исполняемый файл для запуска симуляции.

В отличие от некоторых других симуляторов (например, Modelsim), где исходники открываются через графический интерфейс, либо передаются в исполняемый файл Modelsim, приложение Verilator не используется напрямую для симуляции тестбенча.

Приложение Verilator служит только для преобразования Verilog в C++ и генерации инструкций для сборки с помощью ```Make```. Симулятором здесь является сам тестбенч на C++.

Тестбенч и преобразованные HDL-файлы представляют собой обычное приложение на C++, которое компилируется и запускается на компьютере. Запуск скомпилированного исполняемого файла — это и есть процесс симуляции, а для сборки используется компилятор GCC.

Чтобы собрать исполняемый файл симуляции, нужно снова запустить Verilator для генерации файлов ```.mk``` с добавлением тестбенча на C++ — это делается так:

```bash
$ verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp
```
Дополнительно используются такие параметры:

- ```-Wall``` — включает все предупреждения компилятора C++. Необязательно, но полезно для новичков;

- ```--trace``` — включает запись временных диаграмм.

Для сборки исполняемого файла выполняем команду:

``` bash
$ make -C obj_dir -f Valu.mk Valu
```

Параметр ```-C obj_dir``` говорит ```make``` работать в каталоге ```obj_dir```. С помощью ```-f Valu.mk``` указывается нужный Makefile. Наконец, make собирает цель ```Valu```, которая и есть имя компилируемого тестбенча.

Если сборка прошла успешно, исполняемый файл ```Valu``` сохранится в папке ```obj_dir```.

### 1.5.2 Запуск тестбенча

После сборки необходимо запустить бинарник ```Valu``` для запуска симуляции:

```bash
$ ./obj_dir/Valu
```

На первый взгляд, кажется, что ничего не произошло. Однако запуск симуляции создал файл с временными диаграммами под именем ```waveform.vcd``` в рабочем каталоге.

### 1.5.3 Просмотр временных диаграмм Verilator

Вы можете открыть этот файл временных диаграмм с помощью программы ```GTKWave```:

```bash
gtkwave waveform.vcd
```

Откроется окно GTKWave, которое будет выглядеть примерно так:

![alt text](../Images/image-24.png)

Рисунок 3 - Окно новой сессии GTKWave

Следуйте показанным шагам, чтобы загрузить сигналы из DUT и просмотреть их временные диаграммы:

![alt text](../Images/image-25.png)

Рисунок - 4 Просмотр временных диаграмм в GTKWave

## 1.6 Наблюдения

Во-первых, можно заметить, что в симуляции нет никаких значений 'x' (неопределённых значений). Это связано с тем, что Verilator является симулятором с двумя состояниями, и по умолчанию все сигналы инициализируются в 0. Это хорошо для скорости (так как 2 состояния — меньше, чем 4), но есть недостаток. Невозможно проверить корректность логики сброса. 

Во-вторых, полпериода такта занимает 1 пикосекунду. Это стандартный таймскейл Verilator, и в данном случае он не означает какую-то конкретную временную величину.
