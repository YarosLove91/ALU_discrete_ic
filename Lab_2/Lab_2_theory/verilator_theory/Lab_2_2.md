- [1. Описание Verilator](#1-описание-verilator)
  - [1.1 Достоинства Verilator](#11-достоинства-verilator)
    - [1.1.1 Скорость](#111-скорость)
    - [1.1.2 Качество кода](#112-качество-кода)
    - [1.1.3 Стоимость](#113-стоимость)
  - [1.2 Начало работы](#12-начало-работы)
  - [1.3 Создание DUT](#13-создание-dut)
  - [1.4 Преобразование SystemVerilog в C++](#14-преобразование-systemverilog-в-c)
    - [1.4.1 Верификация с помощью Verilator](#141-верификация-с-помощью-verilator)
    - [1.4.2 Результаты преобразования](#142-результаты-преобразования)
  - [1.5 Разработка базового тестбенча для Verilator](#15-разработка-базового-тестбенча-для-verilator)
    - [1.5.1 Пример тестбенча на C++](#151-пример-тестбенча-на-c)
    - [1.5.2 Сборка исполняемого файла симуляции](#152-сборка-исполняемого-файла-симуляции)
    - [1.5.2 Запуск тестбенча](#152-запуск-тестбенча)
    - [1.5.3 Просмотр временных диаграмм Verilator](#153-просмотр-временных-диаграмм-verilator)
  - [1.6 Наблюдения](#16-наблюдения)
- [2. Основы верификации SystemVerilog с использованием C++](#2-основы-верификации-systemverilog-с-использованием-c)
  - [2.1 Использование Make](#21-использование-make)
  - [2.2 Случайные начальные значения](#22-случайные-начальные-значения)
  - [2.3 Сброс DUT](#23-сброс-dut)
  - [2.4 Базовая верификация](#24-базовая-верификация)
    - [2.4.1 Счётчик фронтов тактового сигнала](#241-счётчик-фронтов-тактового-сигнала)
    - [2.4.2 Примитивные стимулы и проверки для DUT](#242-примитивные-стимулы-и-проверки-для-dut)
  - [2.5 Мониторинг сигналов утверждений (assertions)](#25-мониторинг-сигналов-утверждений-assertions)
  - [2.6 Генерация случайного valid сигнала](#26-генерация-случайного-valid-сигнала)
  - [2.7 Готовый тестбенч](#27-готовый-тестбенч)
- [3. Традиционный пример верефикации](#3-традиционный-пример-верефикации)
  - [3.1 Создание typedef ```operation_t``` доступным в тестбенче на C++](#31-создание-typedef-operation_t-доступным-в-тестбенче-на-c)
  - [3.2 Пример традиционной (временной) верификации](#32-пример-традиционной-временной-верификации)
    - [3.2.1 Временные стимулы](#321-временные-стимулы)
    - [3.2.2 Проверка результатов по времени](#322-проверка-результатов-по-времени)
  - [3.3 Подведение временных итогов](#33-подведение-временных-итогов)
- [4. Современный транзакционный (UVM) стиль тестбенча на C++](#4-современный-транзакционный-uvm-стиль-тестбенча-на-c)
  - [4.1 Определение транзакционного тестбенча?](#41-определение-транзакционного-тестбенча)
  - [4.2 Рандомизированные транзакционные (в UVM стиле) тестбенчи на чистом C++ с Verilator](#42-рандомизированные-транзакционные-в-uvm-стиле-тестбенчи-на-чистом-c-с-verilator)
  - [4.3 Базовая блок-схема транзакционного тестбенча](#43-базовая-блок-схема-транзакционного-тестбенча)
    - [4.3.1 Транзакция и элемент транзакции](#431-транзакция-и-элемент-транзакции)
    - [4.3.2 Генератор транзакций](#432-генератор-транзакций)
    - [4.3.3 Драйвер](#433-драйвер)
    - [4.3.4 Интерфейс](#434-интерфейс)
    - [4.3.5 Монитор](#435-монитор)
    - [4.3.6 Табло](#436-табло)
  - [4.4 Структура и компоненты транзакционного тестбенча для АЛУ](#44-структура-и-компоненты-транзакционного-тестбенча-для-алу)
    - [4.4.1 Элемент транзакции AluInTx](#441-элемент-транзакции-aluintx)
    - [4.4.2 Генератор элементов транзакции rndAluInTx](#442-генератор-элементов-транзакции-rndaluintx)
    - [4.4.3 Драйвер интерфейса ввода AluInDrv](#443-драйвер-интерфейса-ввода-aluindrv)
    - [4.4.4 Монитор входного интерфейса AluInMon](#444-монитор-входного-интерфейса-aluinmon)
    - [4.4.5 Элемент транзакции AluOutTx](#445-элемент-транзакции-aluouttx)
    - [4.4.6 Монитор выходного интерфейса AluOutMon](#446-монитор-выходного-интерфейса-aluoutmon)
    - [4.4.7 Табло AluScb](#447-табло-aluscb)
  - [4.5 Сборфункционала воедино](#45-сборфункционала-воедино)
  - [4.6 Симуляция](#46-симуляция)
  - [4.7 Плохие результаты АЛУ](#47-плохие-результаты-алу)
  - [4.8 Неожиданный out\_valid в АЛУ](#48-неожиданный-out_valid-в-алу)
  - [4.9 Графическое представление](#49-графическое-представление)

# 1. Описание Verilator

Verilator — это инструмент, который компилирует исходные тексты на Verilog и SystemVerilog в высокооптимизированный (и опционально многопоточный) точный цикл C++ или SystemC код. Преобразованные модули можно инстанцировать и использовать в тестбенчах на C++ или SystemC для целей верификации и/или моделирования.

## 1.1 Достоинства Verilator

Verilator — это симулятор Verilog/SystemVerilog, промышленного уровня, очень быстрый, бесплатный и с открытым исходным кодом. Однако, Verilator нельзя считать прямым аналогом таких инструментов как, как Modelsim, Questa Sim, Synopsys VCS, Vivado Xsim и других симуляторов, основанных на событиях. Verilator — это цикл-ориентированный симулятор, что означает, что он не вычисляет события внутри одного такта и не симулирует точное временное поведение схемы. Вместо этого состояние схемы обычно пересчитывается один раз за такт, поэтому любые внутритактовые "глитчи" (скачки сигнала) не видны, а задержки сигналов по времени не поддерживаются. Это одновременно и плюс, и минус по сравнению с другими симуляторами.

### 1.1.1 Скорость

Так как Verilator является цикл-ориентированным, его нельзя использовать для таймингового моделирования, симуляции с обратной аннотацией временных параметров (back-annotated netlists), асинхронной (безтактной) логики, или вообще для любых изменений сигналов, которые завязаны на время — все выходы переключаются мгновенно при каждом вызове схемы.

Однако, именно за счёт игнорирования всего, что происходит между фронтами тактов, симуляции в Verilator идут чрезвычайно быстро. Он отлично подходит для функционального моделирования синхронных цифровых схем с одним или несколькими тактами, а также для создания программных моделей из кода на Verilog/SystemVerilog, которые можно использовать при разработке ПО.

### 1.1.2 Качество кода

Так как Verilator использует цикл-ориентированный подход, он не может полностью поддерживать стандарты IEEE Verilog и SystemVerilog. Тем не менее, инструменты синтеза обычно тоже не полностью совместимы с этими стандартами.

Помимо того, что Verilator не поддерживает временные задержки, он также не принимает большую часть неконструкционного (несинтезируемого) кода (за исключением таких элементов, как ```$display()```, ```$finish()```, ```$fatal()```), поэтому, как правило, не любой тестбенч на SystemVerilog получится скомпилировать в Verilator без серьёзных изменений. Если код не поддерживается, Verilator выдаст большое количество предупреждений и ошибок.

Благодаря тому, что Verilator не поддерживает несинтезируемый код — его поведение ближе к инструментам синтеза по сравнению с другими симуляторами. Это вынуждает писать код более "чистый" с точки зрения синтеза, что потенциально сокращает количество проблем на более поздних стадиях разработки.

### 1.1.3 Стоимость

Verilator — это бесплатный инструмент с открытым исходным кодом. Для симуляции схемы с помощью Verilator создаётся нативный исполняемый файл из преобразованного HDL-кода и тестбенча на C++ с помощью компилятора GCC и системы сборки Make. Так как весь инструментарий бесплатен, нет никаких ограничений по количеству запускаемых экземпляров или числу пользователей. Благодаря высокой скорости работы Verilator позволяет быстро выполнять симуляции даже сложных схем на старых компьютерах и ноутбуках, так что нет необходимости в дорогом вычислительном оборудовании. 

![alt text](../Images/image-23.png)

Рисунок 1 - Пользователи Verilator

## 1.2 Начало работы

В данной работе предполагается, что вы используете какую-либо версию Linux на своём компьютере и что у вас уже установлены Verilator, GTKWave, Make и GCC.

```bash
    git clone https://github.com/n-kremeris/verilator_basics
    git checkout verilator_pt1
```

## 1.3 Создание DUT

Чтобы проверить, как работает Verilator, необходимо устройство для тестирования (DUT — device under test). В данной работе представлена простая АЛУ на SystemVerilog. Исходный код приведён ниже:

``` sv
/****** alu.sv ******/
typedef enum logic [1:0] {
     add     = 2'h1,
     sub     = 2'h2,
     nop     = 2'h0
} operation_t /*verilator public*/;

module alu #(
        parameter WIDTH = 6
) (
        input clk,
        input rst,

        input  operation_t  op_in,
        input  [WIDTH-1:0]  a_in,
        input  [WIDTH-1:0]  b_in,
        input               in_valid,

        output logic [WIDTH-1:0]  out,
        output logic              out_valid
);

        operation_t  op_in_r;
        logic  [WIDTH-1:0]  a_in_r;
        logic  [WIDTH-1:0]  b_in_r;
        logic               in_valid_r;
        logic  [WIDTH-1:0]  result;

        // Register all inputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        op_in_r     <= '0;
                        a_in_r      <= '0;
                        b_in_r      <= '0;
                        in_valid_r  <= '0;
                end else begin
                        op_in_r    <= op_in;
                        a_in_r     <= a_in;
                        b_in_r     <= b_in;
                        in_valid_r <= in_valid;
                end
        end

        // Compute the result
        always_comb begin
                result = '0;
                if (in_valid_r) begin
                        case (op_in_r)
                                add: result = a_in_r + b_in_r;
                                sub: result = a_in_r + (~b_in_r+1'b1);
                                default: result = '0;
                        endcase
                end
        end

        // Register outputs
        always_ff @ (posedge clk, posedge rst) begin
                if (rst) begin
                        out       <= '0;
                        out_valid <= '0;
                end else begin
                        out       <= result;
                        out_valid <= in_valid_r;
                end
        end

endmodule;
```

Для начала работы необходимо создать новый рабочий каталог и сохранить исходный код АЛУ под именем alu.sv.

Как вы можете видеть, это АЛУ очень простое. Оно имеет два регистрационных этапа, не поддерживает остановку (stalling) и выполняет только две операции: сложение и вычитание. На рисунке 2 пример временной диаграммы, показывающей, ожидаемую работу АЛУ:

![alt text](../Images/image-22.png)

Рисунок 2 - Примитивный конвейер АЛУ

Из рисунка 2 видно, что на первом этапе входные сигналы записываются в регистры, а на втором этапе комбинационный результат также записывается в выходные регистры. Этого понимания достаточно, чтобы рассмотреть шаги, необходимые для создания базового тестбенча.

## 1.4 Преобразование SystemVerilog в C++

### 1.4.1 Верификация с помощью Verilator

Как упоминалось во введении, Verilator требует, чтобы тестбенч на C++ компилировался в исполняемый файл системы. Однако, невозможно без предварительной подготовки включить SystemVerilog АЛУ в тестбенч на C++. Для начала необходимо использовать Verilator, чтобы преобразовать код SystemVerilog в C++, или «верилировать» его, что в самом базовом виде выполняется так:

```css
verilator --cc alu.sv
```
Параметр --cc говорит Verilator выполнить преобразование в C++. Verilator также поддерживает преобразование в SystemC (для этого используется параметр --sc).
  
### 1.4.2 Результаты преобразования

Выполнение приведённой выше команды создаёт новую папку с именем ```obj_dir``` в рабочем каталоге. Именно туда попадают все преобразованные исходники:

```
$ ls -l obj_dir/
Valu___024unit.cpp  Valu___024unit__Slow.cpp  Valu.cpp  Valu.mk
Valu__Syms.cpp  Valu__ver.d  Valu___024unit.h  Valu_classes.mk
Valu.h  Valu__Slow.cpp  Valu__Syms.h  Valu__verFiles.dat
```

Сгенерированные файлы с расширением ```.mk``` будут использоваться с ```Make``` для сборки исполняемого файла симуляции, а файлы ```.h``` и ```.cpp``` содержат заголовки C++ и исходные коды реализации, полученные в результате преобразования из SystemVerilog. 

Два наиболее важных, на данный момент, файла:

- ```Valu.h``` — это основной заголовочный файл, содержащий определение класса преобразованного «ALU». Именно этот класс будет «инстанцирован» в тестбенче на C++ как DUT;

- ```Valu___024unit.h``` — это внутренний заголовок для класса «ALU», который содержит определение типа operation_t.

## 1.5 Разработка базового тестбенча для Verilator

### 1.5.1 Пример тестбенча на C++

После того как DUT (устройство под тестированием) преобразован в C++,  можно начать писать тестбенч. Тестбенч будет находиться в новом файле с именем ```tb_alu.cpp```. Минимальный пример кода тестбенча  приведен ниже на C++:

```cpp
#include <stdlib.h>
#include <iostream>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Valu.h"
#include "Valu___024unit.h"

#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut->clk ^= 1;
        dut->eval();
        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```

Первые несколько строк с директивами ```#include``` в понятны сами по себе: подключается <verilated.h> и <verilated_vcd_c.h>, которые идут с установкой Verilator, чтобы получить доступ к основным функциям Verilator и записывать временные диаграммы в файл формата VCD (value change dump).

Как уже упоминалось, ```"Valu.h"``` содержит основной класс Verilated-модуля АЛУ, а ```"Valu___024unit.h"``` содержит преобразованное Verilator определение перечисления typedef.

Далее идут две строки:

```cpp
#define MAX_SIM_TIME 20
vluint64_t sim_time = 0;
```

Переменная ```sim_time``` используется для отслеживания момента завершения симуляции. Существует несколько способов остановки симуляции, но в данном примере симуляция завершается после 20 фронтов тактового сигнала.

Затем идет основная функция main():

```cpp

int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    /* <...> */

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```
Строка ```Valu dut = new Valu;``` создаёт экземпляр преобразованного модуля АЛУ. В SystemVerilog это примерно аналогично записи ```alu dut (.);```.

Следующие четыре строки настраивают запись временных диаграмм. Создается объект ```m_trace``` и передается устройству ```dut``` в строке ```dut->trace(m_trace, 5);```. Параметр 5 ограничивает глубину трассировки до 5 уровней вниз по иерархии DUT.

Ниже представлена часть, которая выполняет симуляцию:

```cpp

while (sim_time < MAX_SIM_TIME) {
    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Во время каждой итерации цикла строка ```dut->clk ^= 1;``` инвертирует сигнал тактового генератора АЛУ (создавая фронты/спады такта). Это будет единственный тактовый сигнал, который используется в тестбенче.

Вызов ```dut->eval();``` производит вычисление всех сигналов модуля АЛУ, а ```m_trace->dump(sim_time);``` записывает все трассированные сигналы в файл временных диаграмм. Как видно, модель вычисляется только по фронтам тактового сигнала.

Переменная времени симуляции затем увеличивается, и цикл продолжается до достижения ```MAX_SIM_TIME```. Обратите внимание, что это не реальное время — переменная просто считает, сколько раз инвертировали такт.

Как видно, этот тестбенч пока что только тактирует модель, но это хорошая отправная точка для дальнейшей разработки.

### 1.5.2 Сборка исполняемого файла симуляции

Когда тестбенч написан, необходимо собрать исполняемый файл для запуска симуляции.

В отличие от некоторых других симуляторов (например, Modelsim), где исходники открываются через графический интерфейс, либо передаются в исполняемый файл Modelsim, приложение Verilator не используется напрямую для симуляции тестбенча.

Приложение Verilator служит только для преобразования Verilog в C++ и генерации инструкций для сборки с помощью ```Make```. Симулятором здесь является сам тестбенч на C++.

Тестбенч и преобразованные HDL-файлы представляют собой обычное приложение на C++, которое компилируется и запускается на компьютере. Запуск скомпилированного исполняемого файла — это и есть процесс симуляции, а для сборки используется компилятор GCC.

Чтобы собрать исполняемый файл симуляции, нужно снова запустить Verilator для генерации файлов ```.mk``` с добавлением тестбенча на C++ — это делается так:

```bash
$ verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp
```
Дополнительно используются такие параметры:

- ```-Wall``` — включает все предупреждения компилятора C++. Необязательно, но полезно для новичков;

- ```--trace``` — включает запись временных диаграмм.

Для сборки исполняемого файла выполняем команду:

``` bash
$ make -C obj_dir -f Valu.mk Valu
```

Параметр ```-C obj_dir``` говорит ```make``` работать в каталоге ```obj_dir```. С помощью ```-f Valu.mk``` указывается нужный Makefile. Наконец, make собирает цель ```Valu```, которая и есть имя компилируемого тестбенча.

Если сборка прошла успешно, исполняемый файл ```Valu``` сохранится в папке ```obj_dir```.

### 1.5.2 Запуск тестбенча

После сборки необходимо запустить бинарник ```Valu``` для запуска симуляции:

```bash
$ ./obj_dir/Valu
```

На первый взгляд, кажется, что ничего не произошло. Однако запуск симуляции создал файл с временными диаграммами под именем ```waveform.vcd``` в рабочем каталоге.

### 1.5.3 Просмотр временных диаграмм Verilator

Вы можете открыть этот файл временных диаграмм с помощью программы ```GTKWave```:

```bash
gtkwave waveform.vcd
```

Откроется окно GTKWave, которое будет выглядеть примерно так:

![alt text](../Images/image-24.png)

Рисунок 3 - Окно новой сессии GTKWave

Следуйте показанным шагам, чтобы загрузить сигналы из DUT и просмотреть их временные диаграммы:

![alt text](../Images/image-25.png)

Рисунок - 4 Просмотр временных диаграмм в GTKWave

## 1.6 Наблюдения

Во-первых, можно заметить, что в симуляции нет никаких значений 'x' (неопределённых значений). Это связано с тем, что Verilator является симулятором с двумя состояниями, и по умолчанию все сигналы инициализируются в 0. Это хорошо для скорости (так как 2 состояния — меньше, чем 4), но есть недостаток. Невозможно проверить корректность логики сброса. 

Во-вторых, полпериода такта занимает 1 пикосекунду. Это стандартный таймскейл Verilator, и в данном случае он не означает какую-то конкретную временную величину.

# 2. Основы верификации SystemVerilog с использованием C++

## 2.1 Использование Make
Для быстрой сборки и запуска симуляции будет использована утилита Make.
В рабочем каталоге необходимо создать файл с именем ```Makefile``` и вставить следующее содержимое:

``` make
MODULE=alu

.PHONY:sim
sim: waveform.vcd

.PHONY:verilate
verilate: .stamp.verilate

.PHONY:build
build: obj_dir/Valu

.PHONY:waves
waves: waveform.vcd
	@echo
	@echo "### WAVES ###"
	gtkwave waveform.vcd

waveform.vcd: ./obj_dir/V$(MODULE)
	@echo
	@echo "### SIMULATING ###"
	@./obj_dir/V$(MODULE)

./obj_dir/V$(MODULE): .stamp.verilate
	@echo
	@echo "### BUILDING SIM ###"
	make -C obj_dir -f V$(MODULE).mk V$(MODULE)

.stamp.verilate: $(MODULE).sv tb_$(MODULE).cpp
	@echo
	@echo "### VERILATING ###"
	verilator -Wall --trace -cc $(MODULE).sv --exe tb_$(MODULE).cpp
	@touch .stamp.verilate

.PHONY:lint
lint: $(MODULE).sv
	verilator --lint-only $(MODULE).sv

.PHONY: clean
clean:
	rm -rf .stamp.*;
	rm -rf ./obj_dir
	rm -rf waveform.vcd
```
После сохранения файла, возможно быстро пересобрать всю симуляцию, запустив в терминале ```make sim```, открыть ```GTKWave``` с помощью ```make waves```, выполнить вериляцию дизайна с помощью ```make verilate``` или собрать верилированные исходники с помощью ```make build```.

Обратите внимание, также есть дополнительная команда ```make lint```, которая вызывает Verilator с ключом ```--lint-only```. Это полезно для быстрой проверки ваших исходных файлов Verilog/SystemVerilog на ошибки. 

И наконец, есть команда ```make clean```, которая удаляет весь мусор, сгенерированный в процессе сборки.

## 2.2 Случайные начальные значения

Одно из вышеупомянутых наблюдений в том, что Verilator является симулятором с двумя состояниями, что значит, что он поддерживает только логические значения ```1``` и ```0```, и не поддерживает ```X```. Поэтому Verilator по умолчанию инициализирует все сигналы в ```0```, что видно на Рисунка 5 из предыдущих результатов симуляции:

![alt text](../Images/image-21.png)

Рисунок 5 - По умолчанию все инициализировано равным 0

Кроме того, если код, присваивает X регистру, то по умолчанию он также получает значение 0.

Однако это поведение можно изменить с помощью параметров командной строки — можно заставить Verilator инициализировать все сигналы в ```1``` или, что лучше, в случайные значения. Это позволит проверить, работает ли сигнал сброса, как только он будет добавлен в тестбенч.

Чтобы сделать так, чтобы тестбенч инициализировал сигналы случайными значениями, сначала нужно вызвать ```Verilated::commandArgs(argc, argv);``` перед созданием объекта DUT:

```cpp
int main(int argc, char** argv, char** env) {
    Verilated::commandArgs(argc, argv);
    Valu *dut = new Valu;
    <...>
```
Затем необходимо обновить команду сборки вериляции, добавив ```--x-assign unique``` и ```--x-initial unique```. Строка 31 в Makefile теперь должна выглядеть так:

```make
verilator -Wall --trace --x-assign unique --x-initial unique -cc $(MODULE).sv --exe tb_$(MODULE).cpp
```

И наконец, необходимо передать ```+verilator+rand+reset+2``` исполняемому файлу симуляции, чтобы установить метод инициализации сигналов во время выполнения в случайный. Это значит, что строка 21 в Makefile должна выглядеть так:

```make
@./obj_dir/V$(MODULE) +verilator+rand+reset+2
```

Теперь, вызвав ```make clean``` и ```make waves```, будет видно, что сигналы инициализируются случайными значениями в начале симуляции:

![alt text](../Images/image-26.png)

Рисунок 6 - Случайная инициализация

## 2.3 Сброс DUT

Чтобы сбросить DUT и его входные сигналы, необходимо обновить основной цикл тестбенча так:

```cpp

while (sim_time < MAX_SIM_TIME) {
    dut->rst = 0;
    if(sim_time > 1 && sim_time < 5){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

В строке 3 произвольно выбрано, чтобы сброс происходил между фронтами тактов на 3 и 5. При необходимости это можно изменить.

В строке 4 сброс устанавливается в высокий уровень, а в последующих строках все входы DUT сбрасываются в 0.

Строки 11-14 не изменены. Тактовый сигнал инвертируется и увеличивается счётчик времени симуляции.

Строка 2 добавлена, чтобы сбрасывать счётчик обратно в 0 при последующих итерациях цикла. В совокупности строки 2-3-4 эквивалентны следующему коду на SystemVerilog:

```sv
always_comb begin
    dut.rst = 1'b0;
    if (sim_time >= 3 && sim_time < 6) begin
        dut.rst = 1'b1;
    end
end
```
Повторный запуск симуляции теперь даёт следующее:

![alt text](../Images/image-27.png)

Рисунок 7 - Сигнал сброса в действии

Как видно на Рисунке 7, сигнал сброса успешно генерируется в тестбенче. Чтобы сделать основной цикл немного чище, можно вынести код сброса в отдельную функцию за пределами ```main()```:

```cpp
void dut_reset (Valu *dut, vluint64_t &sim_time){
    dut->rst = 0;
    if(sim_time >= 3 && sim_time < 6){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }
}```

Затем добавнеобходимо добавить вызов ```dut_reset``` в главный цикл:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Теперь, когда сброс работает, можно рассмотреть добавление реальных стимулов и кода верификации.

## 2.4 Базовая верификация

На данный момент в основном цикле симуляции следующее:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Теперь, если симулировать тестбенч на Verilog/SystemVerilog как DUT, вместо модуля ALU, можно было бы добавить проверку ```Verilated::gotFinish()``` и остановить симуляцию, если это значение становится ```true```. Это происходит, когда вызывается ```$finish()``` из Verilog/SystemVerilog. Тогда тестбенч на C++ был бы достаточен для симуляции тестбенча на Verilog/SystemVerilog.

Но этого недостаточно, так как в рамках работы необходимо вставить стимулы и код верификации в главный цикл тестбенча на C++, чтобы управлять и проверять DUT.

### 2.4.1 Счётчик фронтов тактового сигнала

Для настройки счетчика фронтов тактового сигнала, будет создана отдельная переменная для подсчёта положительных фронтов тактового сигнала. Эта переменная будет того же типа, что и sim_time:

```cpp
vluint64_t sim_time = 0;
vluint64_t posedge_cnt = 0;```

Далее необходимо модифицировать код генерации тактового сигнала, добавив счётчик положительных фронтов:

```cpp
dut->clk ^= 1;            // Инвертировать тактовый сигнал
dut->eval();              // Оценить DUT на текущем фронте
if(dut->clk == 1){
    posedge_cnt++;        // Увеличить счётчик при положительном фронте
}
m_trace->dump(sim_time);  // Сохранить в waveform.vcd
sim_time++;               // Увеличить время симуляции
```
Добавление счётчика между ```eval``` и ```dump``` на Verilog можно переписать в седующем виде:

```sv
initial posedge_cnt <= '0;
always_ff @ (posedge clk, posedge rst) begin
    posedge_cnt <= posedge_cnt + 1'b1;
end
```
И на этом этапе можно начать верифицировать АЛУ.

### 2.4.2 Примитивные стимулы и проверки для DUT

Ожидаемые временные диаграммы для АЛУ представлены на рисунке 8:

![alt text](../Images/image-28.png)

Рисунок 8 - Ожидаемое поведение АЛУ

Игнорируя входы a, b и операцию, а также выходные данные, сначала необходимо проверить, что сигнал входной валидности (input valid) проходит до выхода.

Есть 2 регистрационные стадии, которые, если упростить, выглядели бы так:

```verilog
always_ff @ (posedge clk) begin
    in_valid_r <= in_valid;
    out_valid <= out_valid_r;
end
```

Таким образом, если на ```in_valid``` подать ```1``` на 5-м положительном фронте тактового сигнала, то можно будет увидеть ```1``` на ```out_valid``` через два тактовых цикла, или другими словами, на 7-м положительном фронте. Код для проверки:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    dut->in_valid = 0;
    if (dut->clk == 1){
        posedge_cnt++;
        if (posedge_cnt == 5){
            dut->in_valid = 1;       // установить in_valid на 5-м фронте
        }
        if (posedge_cnt == 7){
            if (dut->out_valid != 1) // проверить out_valid на 7-м фронте
                std::cout << "ERROR!" << std::endl;
        }
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

То, что выполняет выделенный код, будет аналогично этому:

```verilog
always_comb begin
    in_valid = 0;
    if (posedge_cnt == 5)
        in_valid = 1;

    if (posedge_cnt == 7)
        assert (out_valid == 1) else $error("ERROR!")
end
```

Результат симуляции представлен на рисунке 9:

![alt text](../Images/image-29.png)

Рисунок 9 - Графическое объяснение проверки valid

Необходимо убедиться, что код генерации стимулов и проверки, следует нижеописанному порядку действий:

- Тактовая частота устанавливается на 1, выполняется оценка для создания положительного фронта, а затем устанавливаются входные данные / выходные данные перед сбросом и увеличением времени моделирования.

- На следующем положительном фронте тактового сигнала внутри цикла ```while()``` входные данные, заданные ранее, будут переданы в схему во время ```eval```, а затем сразу после вычисления входные данные должны быть сброшены до значений по умолчанию.

## 2.5 Мониторинг сигналов утверждений (assertions)

Установка ```in_valid``` на 5-м фронте и проверка, что ```out_valid``` равен 1, работает, но если возникнет необходимость проверить валидность на большем числе тактов, придётся добавить намного больше проверок. Более того, в коде не проверяется, что ```out_valid``` равен 0 там, где это должно быть, а это значит, что ```out_valid``` мог бы "застрять" на 1, и тестбенч не выдал бы ошибку. Поэтому верификационный код можно значительно улучшить, написав немного C++ кода для непрерывного мониторинга ```in_valid``` и ```out_valid```, аналогично тому, как это делают утверждения в SystemVerilog.

Функция будет выглядеть следующим образом:

```cpp
#define VERIF_START_TIME 7
void check_out_valid(Valu *dut, vluint64_t &sim_time){
    static unsigned char in_valid = 0; // in_valid текущего цикла
    static unsigned char in_valid_d = 0; // задержанный in_valid
    static unsigned char out_valid_exp = 0; // ожидаемое значение out_valid

    if (sim_time >= VERIF_START_TIME) {
        // обратите внимание на порядок!
        out_valid_exp = in_valid_d;
        in_valid_d = in_valid;
        in_valid = dut->in_valid;
        if (out_valid_exp != dut->out_valid) {
            std::cout << "ERROR: out_valid mismatch, "
                << "exp: " << (int)(out_valid_exp)
                << " recv: " << (int)(dut->out_valid)
                << " simtime: " << sim_time << std::endl;
        }
    }
}
```

```VERIF_START_TIME``` нужен, чтобы гарантировать, что  проверочный код не выполняется до или во время сброса, чтобы предотвратить ложные срабатывания ошибок. Если посмотреть на Рисунок 9, видно, что ```rst``` возвращается в 0 на отметке 6ps (что равно sim_time = 6), поэтому sim_time = 7 — это точка, с которой необходимо начинать проверку valid.

Код проверки моделирует конвейер регистров между ```in_valid``` и ```out_valid```. Оригинальный код вышеописанной функции можно заменить следующим образом:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        if (posedge_cnt == 5){
            dut->in_valid = 1;
        }
        check_out_valid(dut, sim_time);
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

Если на данном этапе запустить симуляцию, ошибок не будет, потому что сигнал ```valid``` правильно передается. Однако, чтобы окончательно убедиться, что новый код работает, можно обратиться в ```alu.sv``` и изменить выходную стадию так, чтобы ```out_valid``` всегда устанавливался в 1:

```verilog
always_ff @ (posedge clk, posedge rst) begin
    if (rst) begin
        out       <= '0;
        out_valid <= '0;
    end else begin
        out       <= result;
        out_valid <= 1'b1;  //**** здесь должно быть in_valid_r ****//
    end
end
```

Запустив симуляции снова, вывод будет следующим:

```perl
### SIMULATING ###
./obj_dir/Valu +verilator+rand+reset+2
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 8
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 10
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 14
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 16
ERROR: out_valid mismatch, exp: 0 recv: 1 simtime: 18
```

## 2.6 Генерация случайного valid сигнала

Чтобы заменимть единственное присваивание ```in_valid``` на что-то, что будет случайно устанавливать его в 1 или 0, необходимо подключить заголовок C++ ```cstdlib```:

```cpp
#include <cstdlib>
```

и использовать функцию генерации псевдослучайных чисел ```rand()``` для генерации случайных 1 и 0 в пользовательской функции ```set_rnd_out_valid```:

```cpp
void set_rnd_out_valid(Valu *dut, vluint64_t &sim_time){
    if (sim_time >= VERIF_START_TIME) {
        dut->in_valid = rand() % 2; // генерировать значения 0 и 1
    }
}
```

Также необходимо инициализировать генератор случайных чисел с помощью вызова ```srand```, который можно поместить прямо в начало функции main:

```cpp
int main(int argc, char** argv, char** env) {
    srand (time(NULL));
``` 

Следует увеличить ```MAX_SIM_TIME``` до чего-то более существенного, например до 300:

```cpp
#define MAX_SIM_TIME 300
```

И после запуска ```make sim``` и ```make waves```, вот результаты новой самопроверяющейся случайной симуляции представлены на рисунке 10:

![alt text](../Images/image-30.png)

Рисунок 10 - Обновленные симуляции с случайными значениями

## 2.7 Готовый тестбенч

Врезультате проделанной работы на данном этапе получилась следующая версия C++ тестбенча:

```cpp
#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Valu.h"
#include "Valu___024unit.h"

#define MAX_SIM_TIME 300
#define VERIF_START_TIME 7
vluint64_t sim_time = 0;
vluint64_t posedge_cnt = 0;

void dut_reset (Valu *dut, vluint64_t &sim_time){
    dut->rst = 0;
    if(sim_time >= 3 && sim_time < 6){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }
}

void check_out_valid(Valu *dut, vluint64_t &sim_time){
    static unsigned char in_valid = 0; // in_valid текущего цикла
    static unsigned char in_valid_d = 0; // задержанный in_valid
    static unsigned char out_valid_exp = 0; // ожидаемое значение out_valid

    if (sim_time >= VERIF_START_TIME) {
        out_valid_exp = in_valid_d;
        in_valid_d = in_valid;
        in_valid = dut->in_valid;
        if (out_valid_exp != dut->out_valid) {
            std::cout << "ERROR: out_valid mismatch, "
                << "exp: " << (int)(out_valid_exp)
                << " recv: " << (int)(dut->out_valid)
                << " simtime: " << sim_time << std::endl;
        }
    }
}

void set_rnd_out_valid(Valu *dut, vluint64_t &sim_time){
    if (sim_time >= VERIF_START_TIME) {
        dut->in_valid = rand() % 2;
    }
}

int main(int argc, char** argv, char** env) {
    srand (time(NULL));
    Verilated::commandArgs(argc, argv);
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut_reset(dut, sim_time);

        dut->clk ^= 1;
        dut->eval();

        if (dut->clk == 1){
            dut->in_valid = 0;
            posedge_cnt++;
            set_rnd_out_valid(dut, sim_time);
            check_out_valid(dut, sim_time);
        }

        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
}
```

# 3. Традиционный пример верефикации

## 3.1 Создание typedef ```operation_t``` доступным в тестбенче на C++

Прежде чем начать проверять, правильно ли АЛУ складывает или вычитает два числа, для начала необходимо сделать typedef операции доступным в тестбенче ```tb_alu.cpp```.

В начале кода АЛУ есть следующее:

```verilog
typedef enum logic [1:0] {
  add = 2'h1,
  sub = 2'h2,
  nop = 2'h0
} operation_t /*verilator public*/;
```

Обратите внимание на комментарий ```/*verilator public*/``` после имени ```operation_t```. Это говорит Verilator преобразовать этот typedef в C++ и сделать его общедоступным — это происходит во время шага верилации (конвертация HDL в C++).

Такие комментарии называются директивами или прагмами — они дают Verilator дополнительную информацию о том, как обрабатывать HDL-код. Список таких директив можно найти в руководстве по расширениям языка Verilator.

Если посмотреть в папку ```obj_dir```, где находятся артефакты конверсии, можно найти файл ```Valu___024unit.h```, который содержит верифицированную версию перечисления typedef:

```cpp
// TYPEDEFS
// That were declared public
enum operation_t {
    add = 1U,
    sub = 2U,
    nop = 0U
};
```
Если бы комментарий ```/*verilator public*/``` не был добавлен, этот typedef не был бы доступен в заголовочном файле.

Так как этот заголовок уже включен в ```tb_alu.cpp``` (```#include "Valu___024unit.h"```), теперь можно ем использовать определения внутри перечисления (enum) для задания входа ```op_in``` АЛУ.

Значения перечисления затем могут быть доступны в тестбенче следующим образом:

```cpp
Valu___024unit::operation_t::add
Valu___024unit::operation_t::sub
```
На этом этапе есть всё необходимое, чтобы приступить к проверке функциональности сложения и вычитания АЛУ.

## 3.2 Пример традиционной (временной) верификации

Ранее был продемонстрирован примитивный метод проектирования тестбенча, который проверял корректность работы сигнала ```out_valid``` у АЛУ.

Ранее проверялось, что пайплайн между ```in_valid``` и ```out_valid``` работает правильно, задавая ```1``` на ```in_valid``` на пятом такте и проверяя, что ```out_valid``` равен ```1``` на седьмом такте:

```cpp
if (posedge_cnt == 5){
    dut->in_valid = 1; // устанавливаем in_valid на 5-м такте
}
if (posedge_cnt == 7){
    if (dut->out_valid != 1) // проверяем out_valid на 7-м такте
        std::cout << "ERROR!" << std::endl;
}
```
Этот пример сам по себе довольно слабый (а что если ```out_valid``` всегда застревал на ```1```?), но он хорошо иллюстрирует сутьЭто назвается традиционным или временным стилем верификации, потому что на вход явно подается конкретное входное значение в определённый момент времени и проверяется, что выходные значения соответствуют ожидаемым после некоторого времени. Этот стиль отлично подходит для быстрой проверки небольших схем, хотя может быть не лучшим выбором при работе со сложными модулями.

### 3.2.1 Временные стимулы

На данном этапе основной цикл должен выглядеть так:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        set_rnd_out_valid(dut, sim_time);
        check_out_valid(dut, sim_time);
    }
    m_trace->dump(sim_time);
    sim_time++;
}
```

Можно выполнить операцию сложения на такте 10 и вычитания на такте 20. Для этого необходимо убрать функцию случайной передачи, которая находится в строке 10, и заменить её на оператор switch следующим образом:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();

    if (dut->clk == 1){
        dut->in_valid = 0;
        posedge_cnt++;
        switch (posedge_cnt){
            case 10:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::add;
                break;

            case 20:
                dut->in_valid = 1;
                dut->a_in = 5;
                dut->b_in = 3;
                dut->op_in = Valu___024unit::operation_t::sub;
                break;
        }
        check_out_valid(dut, sim_time);
    }

    m_trace->dump(sim_time);
    sim_time++;
}
```

Как видно, в обоих случаях устанавливается ```dut->in_valid``` в ```1```, задаются некоторые входные операнды в ```dut->a_in``` и ```dut->b_in```, а затем устанавливается ```dut->op_in``` в желаемую операцию: сложение на 10-м такте и вычитание на 20-м. При симуляции можно увидеть, как это работает на Рисунке 11:

![alt text](../Images/image-31.png)
Рис. 11: Результаты симуляции сложения и вычитания

Из рисунка 11 видно, что АЛУ работает корректно.

### 3.2.2 Проверка результатов по времени

Конвейер АЛУ всегда занимает фиксированное количество — 2 такта — чтобы обработать входные данные и вернуть результат на выходах, поэтому можно добавить проверки на 12-м и 22-м тактах для верификации результатов:

```cpp
switch (posedge_cnt){
    case 10:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::add;
        break;

    case 12:
        if (dut->out != 8)
            std::cout << "Addition failed @ " << sim_time << std::endl;
        break;

    case 20:
        dut->in_valid = 1;
        dut->a_in = 5;
        dut->b_in = 3;
        dut->op_in = Valu___024unit::operation_t::sub;
        break;

    case 22:
        if (dut->out != 2)
            std::cout << "Subtraction failed @ " << sim_time << std::endl;
        break;
}
```
Нет необходимости явно проверять, что ```out_valid``` корректен в случаях 12 и 22 — это по-прежнему делает функция ```check_out_valid()```.

Если на данном этапе запустить симуляцию, можно увидеть, что она проходит без проблем, потому что АЛУ написано правильно. Однако, если открыть```alu.sv``` и изменить вектор результата ```result```:

```verilog
//sub: result = a_in_r + (~b_in_r+1'b1); // оригинал
sub: result = a_in_r + (~b_in_r+6'h3);   // модифицировано
```

Можно будет заметить, что симуляция провалится и укажет нам, где была обнаружена ошибка:

```perl
### SIMULATING ###
./obj_dir/Valu +verilator+rand+reset+2
Subtraction failed @ 42
```

## 3.3 Подведение временных итогов

Это руководство демонстрирует примитивный пример верификационного кода на C++, который можно использовать для выполнения базовых задач верификации. Существует множество вариаций того, как можно структурировать такой код — можно использовать операторы ```switch```, как показано здесь, отдельные ```if```- выражения или разбивать код на отдельные функции. Однако, скорее всего, вы согласитесь, что такой метод верификации, хотя простой и быстрый в реализации, на самом деле недостаточен для более сложных проектов.

# 4. Современный транзакционный (UVM) стиль тестбенча на C++

В этом руководстве будут рассмотрены более современные методы верификации, а именно — транзакционные тестбенчи в стиле UVM.

## 4.1 Определение транзакционного тестбенча?

Постоянно растущая сложность FPGA и ASIC дизайнов приводит к ужесточению требований к верификации. Возросший спрос на продвинутые тестбенчи породил появление новых методологий и инструментов, таких как OVM, VVM, UVM, SystemC, а также различных Python-фреймворков. Все эти инструменты направлены на одну цель — облегчение построения мощных, самопроверяющих тестбенчей из переиспользуемых компонентов, с одновременным увеличением покрытия кода, минимизацией дублирования и избавлением инженеров по верификации от необходимости постоянно смотреть на осциллограммы. Один из главных способов достижения этой цели — поощрение написания тестбенчей транзакционного стиля, которые, как раз могут быть реализованы на чистом C++ вместе с Verilator.

Транзакционный тестбенч — это тестбенч, который использует транзакции (что, по сути, представляет собой обмен данными или управляющими пакетами), которые обеспечивают абстракцию поверх прямого присваивания значений входным контактам и непосредственной проверки значений выходных контактов устройства, проходящего тестирование (DUT). 

Традиционный тестбенч на VHDL, Verilog, SystemVerilog или C++ обычно имеет экземпляр DUT, а также длинный поведенческий код с циклами и условными операторами, который последовательно подаёт сигналы на входы DUT для перевода его в определённые состояния. Как правило, такие тестбенчи проверяются на корректность визуальным просмотром осциллограмм, и хотя можно добавить самопроверку через утверждения или мониторинг.

В отличие от этого, транзакционный тестбенч поощряет строгое разделение на различные функциональные блоки, которые общаются между собой через транзакции. Базовый транзакционный тестбенч может состоять из:

- блока генерации стимулов для DUT (генератор транзакций / последовательность);

- блока, подающего эти данные на DUT (драйвер);

- блока, который наблюдает выходы DUT и генерирует результаты (монитор);

- блока, собирающего пакеты данных и сравнивающего их для проверки (табло);

- блока, собирающего данные и рассчитывающего функциональное покрытие (ковередж).

Сразу видно главный минус транзакционных тестбенчей — это сложность: из-за множества отдельных блоков базовая симуляция запускается медленнее. Однако этот недостаток перекрывается непревзойдённой гибкостью и повторным использованием кода.

Например, если есть драйвер для интерфейса типа A, его можно использовать его с любым другим DUT с таким же интерфейсом типа A — достаточно просто передать ему новые данные. Если интерфейс заменяется с типа A на тип B, достаточно поменять драйвер с A на B, оставляя остальной тестбенч без изменений.

## 4.2 Рандомизированные транзакционные (в UVM стиле) тестбенчи на чистом C++ с Verilator

Тестбенчи в стиле UVM довольно легко пишутся и на чистом C++. Структуры наподобие драйверов, мониторов и табло просто реализуются, и также возможно реализовать покрытие и последовательные структуры, приложив немного дополнительных усилий.

Реализация современных транзакционных тестбенчей на чистом C++ вместо SystemC или UVM-SystemC имеет преимущество в простоте старта, а иногда и в более высокой производительности. Минус — многое из того, что уже есть в SystemC или UVM, придётся реализовать вручную. Теоретически, можно создать тестбенч на SystemVerilog UVM, преобразовать его в C++ с помощью Verilator и управлять базовым C++ тестбенчем. Однако поддержка UVM в Verilator пока ещё не полноценная.

Учитывая всё это, в данной работе будет создан базовый транзакционный тестбенч на чистом C++, без сторонних библиотек. Будут написсаны структуры, которые условно представляют транзакции, драйверы, мониторы и табло. Это даст необходимые знания для создания мощных тестбенчей на C++, а также понятную и простую в использовании основу для последующих проектов.

## 4.3 Базовая блок-схема транзакционного тестбенча

Вот базовый пример того, как устроен современный транзакционный тестбенч:

![alt text](../Images/image-32.png)

Рисунок 12 - Блок-схема базового транзакционного тестового стенда

Описание компонент представлено ниже:

### 4.3.1 Транзакция и элемент транзакции

Транзакция — это высокоуровневая операция обмена данными, а элемент транзакции — это просто пакет данных, то есть набор информации или инструкций. Обычно реализуется как класс или структура и содержит данные, отправляемые в DUT или получаемые от него.

![alt text](../Images/image-33.png)

Рисунок 13 - Элемент транзакции

### 4.3.2 Генератор транзакций

Это класс или блок кода, который создаёт элементы транзакций, используемые как инструкции для подачи на входы DUT.

![alt text](../Images/image-34.png)

Рисунок 14 - Генератор транзакций

### 4.3.3 Драйвер

Эти структуры берут элементы транзакций и, на основе содержащихся данных, управляют физическими входами входного интерфейса (устанавливая 1 и 0), чтобы ввести данные в DUT. Иногда драйверы требуются и для сложных выходных интерфейсов.

![alt text](../Images/image-35.png)

Рисунок 15 - Драйвер

### 4.3.4 Интерфейс

Интерфейс — это просто набор или группа контактов, которые используются для конкретной функции. Например, FIFO обычно имеет два интерфейса: входной и выходной, а двухтактовая память (dual-clock RAM) может иметь четыре: вход для порта A, выход для порта A, вход для порта B, выход для порта B.

Интерфейс может быть классом или структурой, которая объединяет функционально связанные контакты, или, как будет в данном случае, это также может быть неявная группировка контактов без явного объединения в коде.

![alt text](../Images/image-36.png)

Рисунок 16 - Интерфейс

### 4.3.5 Монитор

Это по сути полная противоположность драйвера — вместо того чтобы управлять физическими состояниями пинов на интерфейсах, мониторы пассивно наблюдают (мониторят) за тем, что происходит на интерфейсе. Мониторы обычно подключаются к выходному интерфейсу, где они используются для проверки выходных данных устройства под тестом. Кроме того, вы можете увидеть их подключёнными к входным интерфейсам, где они могут проверять, что связанный драйвер корректно управляет интерфейсом.

То, что они делают с данными, полученными в результате наблюдаемых изменений сигналов, зависит от разработчика тестбенча. Мониторы могут быть полностью автономными и самопроверяющими, то есть они могут напрямую выполнять код, который проверяет правильность изменений сигналов по мере появления событий на интерфейсе. Однако, чаще мониторы проектируются так, чтобы генерировать новые элементы транзакций из наблюдаемых изменений состояний контактов интерфейса. Эти элементы транзакций затем отправляются в анализирующие порты табло.

![alt text](../Images/image-37.png)

Рисунок 17 - Монитор

### 4.3.6 Табло

Структура табло обычно содержит наибольшую часть самопроверяющего кода тестбенча. Одно табло имеет один или несколько анализирующих (слушающих) портов, которые используются для получения элементов транзакций от мониторов. Табло выполняет проверки на полученных элементах транзакций, чтобы убедиться, что наблюдаемые входные стимулы приводят к корректным выходам, и определяет, прошёл тестбенч или нет.

Обычно в тестбенче используют одно табло, но ничто не мешает вам создать столько, сколько захотите.

![alt text](../Images/image-38.png)

Рисунок 18 - Табло

## 4.4 Структура и компоненты транзакционного тестбенча для АЛУ

Подобно базовой блок-схеме на рисункке 12, ниже представлена структура транзакционного тестбенча для АЛУ:

![alt text](../Images/image-40.png)

Рисунок 19 - Блок-схема транзакционного тестового стенда

Необходимо изучить код, который находится в тестбенче ```tb_alu.cpp```.

### 4.4.1 Элемент транзакции AluInTx

У ALU есть входной интерфейс, состоящий из пинов ```op_in```, ``a_in``, ```b_in``` и ```in_valid```. Поэтому необходим класс элемента транзакции, который сможет содержать данные для управления этими контактами. Это можно сделать следующим образом:

```cpp
class AluInTx {
    public:
        uint32_t a;
        uint32_t b;
        enum Operation {
            add = Valu___024unit::operation_t::add,
            sub = Valu___024unit::operation_t::sub,
            nop = Valu___024unit::operation_t::nop
        } op;
};
```

Числовые значения для ```a_in``` и ```b_in``` можно легко хранить в типе ```uint32_t```, который представляет собой беззнаковое 32-битное целое число.

Verilator допускает использование ```uint8_t``` для сигналов шириной до 8 бит, ```uint16_t``` — до 16 бит, ```uint32_t``` — до 32 бит, и ```vluint64_t``` — до 64 бит, и если ширина сигнала меньше или равна размеру переменной, компилятор выполнит автоматическое приведение типов по мере необходимости.

Чтобы задать операцию для операндов ```a``` и ```b```, создается перечисление ```op```, где значения берутся из сгенерированного Verilator кода SystemVerilog АЛУ. Это избавляет от необходимости каждый раз писать длинный префикс ```Valu___024unit::operation_t::```.

Наконец, нам нет необходимости хранить информацию о ```in_valid``` в ```AluInTx``` — драйвер сам будет управлять ```in_valid``` на основе полученного ```AluInTx```.

### 4.4.2 Генератор элементов транзакции rndAluInTx

Теперь, когда готов шаблон для транзакции ```AluInTx```, необходимо написать код, который будет создавать объекты этого типа и присваивать случайные значения операндам. Это делается в генераторе транзакций:

```cpp
AluInTx* rndAluInTx(){
    //20% шанс сгенерировать транзакцию
    if(rand()%5 == 0){
        AluInTx *tx = new AluInTx();
        tx->op = AluInTx::Operation(rand() % 3); // ENUM имеет значения 0, 1, 2
        tx->a = rand() % 11 + 10; // генерируем a в диапазоне 10-20
        tx->b = rand() % 6;  // генерируем b в диапазоне 0-5
        return tx;
    } else {
        return NULL;
    }
}
```

Каждый раз при вызове функции ```rndAluInTx()```, она случайным образом либо:

1. выделяет память под объект ```AluInTx``` (строка 4), присваивает случайные значения ``op``, ```a``` и ```b```, и возвращает указатель на вновь созданный объект (строка 8);

2. либо немедленно возвращает NULL (строка 10), что означает, что транзакция не была сгенерирована.

Причина случайного пропуска генерации каждой второй транзакции — это создание пауз между командами, отправляемыми АЛУ. Возвращение NULL — не единственный способ сделать это: можно пойти противоположным путём и создать последовательность, которая зависит от некоторой временной переменной (например, тиков симуляции или счётчика положительных фронтов), а затем генерировать транзакции только в определённые моменты времени.

### 4.4.3 Драйвер интерфейса ввода AluInDrv

Как только будет сгенерирован элемент транзакции ```AluInTx``` с помощью генератора ```rndAluInTx```, ```AluInTx``` передастся в драйверный блок, который управляет входным интерфейсом АЛУ, используя информацию из этого элемента транзакции. Ниже приведен код драйвера из тестбенча:

```cpp
class AluInDrv {
    private:
        Valu *dut;
    public:
        AluInDrv(Valu *dut){
            this->dut = dut;
        }

        void drive(AluInTx *tx){
            // мы всегда начинаем с установки in_valid в 0, и устанавливаем его в 1 позже, только если это необходимо
            dut->in_valid = 0;

            // Ничего не передаём, если элемент транзакции не существует
            if(tx != NULL){
                if (tx->op != AluInTx::nop) {
                    // Если операция не является NOP, мы передаём её на
                    // пины входного интерфейса
                    dut->in_valid = 1;
                    dut->op_in = tx->op;
                    dut->a_in = tx->a;
                    dut->b_in = tx->b;
                }
                // Освобождаем память, удаляя элемент tx
                // после того как он был использован
                delete tx;
            }
        }
};
```

Конструктор ```AluInDrv``` требует дескриптор на объект dut. Необходимо иметь дескриптор устройства, проходящего тестирование (DUT), внутри драйверов и мониторов, чтобы иметь доступ к его выводам.

На строке 12 видно, что входной сигнал ```in_valid``` всегда по умолчанию устанавливается в ```0```. Это связано с тем, что, если нет допустимого ```AluInTx``` и при этом он не является ```NOP```, входные данные для АЛУ не будут считаться валидными. Примерный эквивалент на SystemVerilog будет таким:

```systemverilog
always_comb begin
    dut.in_valid = 1'b0;
    if ( tx item существует && операция != NOP ) begin
        dut.in_valid = 1'b1;
    end
end
```

Если элемент транзакции не NULL, то на строке 26 происходит удаление (освобождение памяти), где хранится объект транзакции. Это очень важно сделать — как только элемент используется (записывается в DUT), срок его службы заканчивается, и он должен быть удалён, иначе будет утечка памяти.

Важно обратить внимание, что C++ поддерживает умное управление памятью. Однако для целей объяснения, ручное управление памятью лучше иллюстрирует срок жизни элементов транзакций.

### 4.4.4 Монитор входного интерфейса AluInMon

```AluInMon``` следит за входным интерфейсом АЛУ, выполняя противоположные действия драйверу, который были рассмотрены ранее.

```cpp
class AluInMon {
    private:
        Valu *dut;
        AluScb *scb;
    public:
        AluInMon(Valu *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            if (dut->in_valid == 1) {
                // Если на входном интерфейсе есть валидные данные,
                // создаём новый элемент транзакции AluInTx и заполняем
                // его данными, считанными с пинов интерфейса
                AluInTx *tx = new AluInTx();
                tx->op = AluInTx::Operation(dut->op_in);
                tx->a = dut->a_in;
                tx->b = dut->b_in;

                // затем передаём элемент транзакции в scoreboard
                scb->writeIn(tx);
            }
        }
};
```

Здесь на строке 12 можно заметить сигнал ```in_valid``` на входе АЛУ. Если вход валидный, монитор создаёт новый элемент транзакции ```AluInTx```, считывает значения ```op_in```, ```a_in```, ```b_in``` контактов и помещает их в ```AluInTx``` переменные ```op```, ```a```, и ```b```.

Этот новый элемент транзакции сообщает, какую операцию отправили на входы АЛУ, что будет нужно для проверки корректности выходных данных АЛУ. Поэтому на строке 22 новая транзакция записывается в таблицу для последующего использования.

### 4.4.5 Элемент транзакции AluOutTx

Точно так же, как ```AluInTx``` элемент транзакции для операций с интерфейсом ввода, ```AluOutTx``` элемент транзакции для хранения информации о результатах, получаемых с помощью интерфейса вывода.

Однако, поскольку единственное, что предоставляется на выходе — это одно значение результата, ```AluOutTx``` содержит только одну переменную:

```cpp
class AluOutTx {
    public:
        uint32_t out;
};
```

### 4.4.6 Монитор выходного интерфейса AluOutMon

Здесь вступает в действие элемент ```AluOutTx```. Точно так же, как монитор входа, ```AluOutMon``` наблюдает выходной интерфейс аналогичным образом:

```cpp
class AluOutMon {
    private:
        Valu *dut;
        AluScb *scb;
    public:
        AluOutMon(Valu *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            if (dut->out_valid == 1) {
                // Если на выходном интерфейсе валидные данные,
                // создаём новый элемент AluOutTx и заполняем
                // его результатом, считанным с пинов интерфейса
                AluOutTx *tx = new AluOutTx();
                tx->out = dut->out;

                // затем передаём элемент транзакции в scoreboard
                scb->writeOut(tx);
            }
        }
};
```

```AluOutMon``` ждёт, пока сигнал ```out_valid``` не станет равным 1. Когда это происходит, создаётся новый элемент ```AluOutTx``` (строка 16), значение на выходных контактах испытуемого устройства сохраняется в ```out``` переменной в ```AluOutTx``` элементе, а затем элемент передаётся на табло.

### 4.4.7 Табло AluScb

Табло - это самый важный блок в тестбенче, это мозг всей операции:

```cpp
// Табло ALU
class AluScb {
    private:
        std::deque<AluInTx*> in_q;

    public:
        // Порт монитора входного интерфейса
        void writeIn(AluInTx *tx){
            // Поместить полученный элемент транзакции в очередь для последующей обработки
            in_q.push_back(tx);
        }

        // Порт монитора выходного интерфейса
        void writeOut(AluOutTx* tx){
            // Мы никогда не должны получать данные из выходного интерфейса
            // до тех пор, пока на входной интерфейс не будет подано значение
            if(in_q.empty()){
                std::cout <<"Фатальная ошибка в AluScb: пустая очередь AluInTx" << std::endl;
                exit(1);
            }

            // Извлекаем элемент транзакции из начала очереди входных элементов
            AluInTx* in;
            in = in_q.front();
            in_q.pop_front();

            switch(in->op){
                // На выходе не должен появляться валидный сигнал, если операция отсутствует,
                // поэтому мы не должны получать транзакцию с операцией NOP
                case AluInTx::nop :
                    std::cout << "Фатальная ошибка в AluScb, получен NOP на входе" << std::endl;
                    exit(1);
                    break;

                // Получена транзакция сложения
                case AluInTx::add :
                    if (in->a + in->b != tx->out) {
                        std::cout << std::endl;
                        std::cout << "AluScb: несоответствие при сложении" << std::endl;
                        std::cout << "  Ожидалось: " << in->a + in->b
                                  << "  Фактически: " << tx->out << std::endl;
                        std::cout << "  Время симуляции: " << sim_time << std::endl;
                    }
                    break;

                // Получена транзакция вычитания
                case AluInTx::sub :
                    if (in->a - in->b != tx->out) {
                        std::cout << std::endl;
                        std::cout << "AluScb: несоответствие при вычитании" << std::endl;
                        std::cout << "  Ожидалось: " << in->a - in->b
                                  << "  Фактически: " << tx->out << std::endl;
                        std::cout << "  Время симуляции: " << sim_time << std::endl;
                    }
                    break;
            }
            // Так как элементы транзакций были размещены в куче, важно
            // освободить память после их использования
            delete in;
            delete tx;
        }
};
```

С самого начала создаётся очередь для хранения элементов транзакций ```AluInTx``` в табло:

```cpp
std::deque<AluInTx*> in_q;
```

Каждый раз, когда в АЛУ отправляется допустимая операция, монитор входного интерфейса записывает элемент ```AluInTx``` в табло через метод writeIn (строка 8). Элемент ```AluInTx``` необходимо сравнить с соответствующим элементом ```AluOutTx```, чтобы проверить правильность результата АЛУ. Так как АЛУ конвейерный, можно отправить несколько команд на входной интерфейс до того, как придут какие-либо выходные элементы ```AluOutTx```. Поэтому элементы ```AluInTx``` нужно сохранять для последующей проверки, и очередь идеально подходит для этой задачи.

Метод ```writeOut``` (строка 14) — это место, где происходит вся проверка результатов. Сначала, на строке 17, проверяется, не выдаёт ли АЛУ случайный мусор на выходе — результат на выходе должен появиться только после того, как допустимая операция была подана на вход, поэтому никогда не должно быть такого момента, когда результат на выходе появился раньше, чем хотя бы один элемент ```AluInTx``` в очереди.

Далее, если очередь ```in_q``` не пуста, из нее извлекается первый (самый старый) элемент ```AluInTx``` и переходит к оператору ```switch``` на строке 27. Первый случай ```switch``` (строка 30) проверяет правильность работы тестбенча — валидный сигнал не должен появляться на входе при операции ```NOP```, и если элемент ```AluInTx``` с операцией ```NOP``` попал в табло, это значит, что драйвер ```AluInDrv``` работает некорректно.

В оставшихся случаях, в зависимости от того, является ли операция сложением (строка 36) или вычитанием (строка 47), необходимо сложить или вычесть операнды из ```AluInTx``` и сравнивнить с результатом в ```AluOutTx```.

В конце метода ```writeOut```, элементы транзакций удаляются (строки 59 и 60), так как они больше не нужны.

## 4.5 Сборфункционала воедино

Главный цикл — это место, где происходит вся верификационная "магия". Функция ```main``` содержит создание всех блоков тестбенча (мониторы, драйвер, табло), а затем в главном цикле итеративно вызываются функции всех этих блоков до окончания симуляции. Или до тех пор, пока тестбенч не завершится с ошибкой. Ниже представлен код функции main и основного симуляционного цикла:

```cpp
int main(int argc, char** argv, char** env) {
    <...>

    AluInTx   *tx;

    // Создаём драйвер, табло и блоки мониторов входа и выхода
    AluInDrv  *drv    = new AluInDrv(dut);
    AluScb    *scb    = new AluScb();
    AluInMon  *inMon  = new AluInMon(dut, scb);
    AluOutMon *outMon = new AluOutMon(dut, scb);

    while (sim_time < MAX_SIM_TIME) {
        dut_reset(dut, sim_time);
        dut->clk ^= 1;
        dut->eval();

        // Все действия по управлению/мониторингу выполняются на положительном фронте
        if (dut->clk == 1){

            if (sim_time >= VERIF_START_TIME) {
                // Генерация случайной транзакции AluInTx
                tx = rndAluInTx();

                // Передача транзакции драйверу ALU,
                // который управляет входами на основе данных в транзакции
                drv->drive(tx);

                // Мониторинг входного интерфейса
                inMon->monitor();

                // Мониторинг выходного интерфейса
                outMon->monitor();
            }
        }
        // конец обработки положительного фронта

        m_trace->dump(sim_time);
        sim_time++;
    }

    <...>
    delete dut;
    delete outMon;
    delete inMon;
    delete scb;
    delete drv;
    exit(EXIT_SUCCESS);
}
```

После создания блоков тестбенча (строки 14-17), симуляция входит в главный цикл на строке 19, который выполняется до конца симуляционного времени.

На каждой итерации цикла проверяется, наступил ли положительный фронт тактового сигнала (строка 25). Если да, тестбенч генерирует транзакцию ```AluInTx``` (строка 28).

Эта транзакция передаётся драйверу ```AluInDrv``` (строка 33), который управляет входными линиями АЛУ по информации из транзакции.

На этом же фронте монитор ```AluInMon``` наблюдает входные линии (строка 36) и из наблюдений формирует новый элемент ```AluInTx```, который записывается в табло.

Также на этом же фронте монитор ```AluOutMon``` следит за выходами АЛУ (строка 39), но транзакции ```AluOutTx``` пока не создаются из-за задержки в АЛУ по конвейеру — нужно минимум две итерации цикла, прежде чем результаты появятся.

После завершения симуляции все блоки тестбенча удаляются для освобождения памяти (строки 46-50).

## 4.6 Симуляция

Для запуска симуляции, достаточно выполнить ```make``` в каталоге проекта — это соберёт и запустит тестбенч. Никакого интересного вывода не будет, потому что АЛУ и тестбенч работают корректно, тест проходит без ошибок.

Но это не очень информативно, поэтому можно посмотреть, что будет, если что-то пойдёт не так.

## 4.7 Плохие результаты АЛУ

Легко обнаружить, если АЛУ выдаёт неправильные результаты, табло сразу пожалуется. Если моделировать АЛУ вот так:

```verilog
out       <= 6'h5; // должно быть "<= result"
out_valid <= in_valid_r;
```

Тогда табло тут же засечёт ошибку:

```verilog
AluScb: add mismatch
  Expected: 15  Actual: 5
  Simtime: 204

AluScb: sub mismatch
  Expected: 11  Actual: 5
  Simtime: 234

AluScb: add mismatch
  Expected: 17  Actual: 5
  Simtime: 236
```

## 4.8 Неожиданный out_valid в АЛУ

Если сделать так, чтобы АЛУ всегда сигнализировало валидный выход:

```verilog
out       <= result;
out_valid <= 1'b1; // должно быть "<= in_valid_r"
```

Тогда тестовый стенд немедленно завершит работу с фатальной ошибкой при первом обнаружении некорректного корректного вывода:

```verilog
./obj_dir/Valu +verilator+rand+reset+2 
Fatal Error in AluScb: empty AluInTx queue
make: *** [Makefile:23: waveform.vcd] Error 1
```
Это потому что табло не ожидает увидеть выходные данные, если на вход ранее не подавалась команда.

## 4.9 Графическое представление

С помощью GTKWave, можно выполнить ```make waves```, чтобы посмотреть на случайно сгенерированные транзакции в виде волн.

![alt text](../Images/image-41.png)

Рисунок 20 - Графическое представление
