- [Лабораторная работа № 3 - Исследование программного процессора biRISC-V](#лабораторная-работа--3---исследование-программного-процессора-birisc-v)
  - [Цели и задачи](#цели-и-задачи)
  - [1 Введение в стандарт RISC-V](#1-введение-в-стандарт-risc-v)
    - [1.1 Принципиальные различия между вариантами ISA, основанные на разрядности и числе регистров](#11-принципиальные-различия-между-вариантами-isa-основанные-на-разрядности-и-числе-регистров)
    - [1.2 Принцип адресации и представления данных в RISC-V](#12-принцип-адресации-и-представления-данных-в-risc-v)
    - [1.3 Классификация и структура форматов инструкций](#13-классификация-и-структура-форматов-инструкций)
      - [1.3.1 Форматы инструкций](#131-форматы-инструкций)
      - [1.3.2 Структурные компоненты команд: opcode, регистры, стандартные расширения](#132-структурные-компоненты-команд-opcode-регистры-стандартные-расширения)
        - [1.3.2.1 Наборы регистров](#1321-наборы-регистров)
        - [1.3.2.2 Стандартные расширения](#1322-стандартные-расширения)
        - [1.3.2.3 Условные обозначения в таблицах опкодов](#1323-условные-обозначения-в-таблицах-опкодов)
    - [1.4 Инструкции целочисленной арифметики](#14-инструкции-целочисленной-арифметики)
      - [1.4.1 Инструкции целочисленной арифметики](#141-инструкции-целочисленной-арифметики)
      - [1.4.2 Инструкции логических операций](#142-инструкции-логических-операций)
      - [1.4.3 Инструкции сдвига](#143-инструкции-сдвига)
      - [1.4.4 Инструкции сравнения](#144-инструкции-сравнения)
      - [1.4.5 Инструкции генерации констант](#145-инструкции-генерации-констант)
      - [1.4.6 Безусловные инструкции перехода](#146-безусловные-инструкции-перехода)
      - [1.4.7 Условные инструкции перехода](#147-условные-инструкции-перехода)
      - [1.4.8 Инструкции загрузки и сохранения данных](#148-инструкции-загрузки-и-сохранения-данных)
      - [1.4.9 Инструкции упорядочивания памяти](#149-инструкции-упорядочивания-памяти)
      - [1.4.10 Инструкции вызова окружения и точки останова](#1410-инструкции-вызова-окружения-и-точки-останова)
      - [1.4.11 Прочие инструкции](#1411-прочие-инструкции)
      - [1.4.12 Инструкции HINT](#1412-инструкции-hint)
    - [1.5 Расширение регистров управления и статуса (CSR)](#15-расширение-регистров-управления-и-статуса-csr)
      - [1.5.1 Инструкции чтения и записи CSR](#151-инструкции-чтения-и-записи-csr)
      - [1.5.2 Инструкции установки CSR](#152-инструкции-установки-csr)
    - [1.6 Расширение умножения и деления целых чисел](#16-расширение-умножения-и-деления-целых-чисел)
    - [1.7 Расширение атомарных инструкций](#17-расширение-атомарных-инструкций)
      - [1.7.1 Инструкции атомарных операций с памятью](#171-инструкции-атомарных-операций-с-памятью)
      - [1.7.2 Инструкции Load-Reserved / Store-Conditional](#172-инструкции-load-reserved--store-conditional)
    - [1.8 Расширение для одинарной точности с плавающей запятой](#18-расширение-для-одинарной-точности-с-плавающей-запятой)
      - [1.8.1 Инструкции загрузки и записи с плавающей запятой одинарной точности](#181-инструкции-загрузки-и-записи-с-плавающей-запятой-одинарной-точности)
      - [1.8.2 Инструкции вычислений с плавающей запятой одинарной точности](#182-инструкции-вычислений-с-плавающей-запятой-одинарной-точности)
      - [1.8.3 Инструкции внедрения знака для чисел с плавающей запятой одинарной точности](#183-инструкции-внедрения-знака-для-чисел-с-плавающей-запятой-одинарной-точности)
      - [1.8.4 Инструкции преобразования чисел с плавающей запятой одинарной точности](#184-инструкции-преобразования-чисел-с-плавающей-запятой-одинарной-точности)
      - [1.8.5 Инструкции сравнения чисел с плавающей запятой одинарной точности](#185-инструкции-сравнения-чисел-с-плавающей-запятой-одинарной-точности)
      - [1.8.6 Инструкции классификации чисел с плавающей запятой одинарной точности](#186-инструкции-классификации-чисел-с-плавающей-запятой-одинарной-точности)
      - [1.8.7 Инструкции перемещения чисел с плавающей запятой одинарной точности](#187-инструкции-перемещения-чисел-с-плавающей-запятой-одинарной-точности)
    - [1.9 Расширение двойной точности для чисел с плавающей запятой](#19-расширение-двойной-точности-для-чисел-с-плавающей-запятой)
      - [1.9.1 Инструкции загрузки и сохранения чисел с плавающей запятой двойной точности](#191-инструкции-загрузки-и-сохранения-чисел-с-плавающей-запятой-двойной-точности)
      - [1.9.2 Инструкции вычислений с числами с плавающей запятой двойной точности](#192-инструкции-вычислений-с-числами-с-плавающей-запятой-двойной-точности)
      - [1.9.3 Инструкции внедрения знака для чисел с плавающей запятой двойной точности](#193-инструкции-внедрения-знака-для-чисел-с-плавающей-запятой-двойной-точности)
      - [1.9.4 Инструкции преобразования для чисел с плавающей запятой двойной точности](#194-инструкции-преобразования-для-чисел-с-плавающей-запятой-двойной-точности)
      - [1.9.5 Инструкции сравнения чисел с плавающей запятой двойной точности](#195-инструкции-сравнения-чисел-с-плавающей-запятой-двойной-точности)
      - [1.9.6 Инструкции классификации чисел с плавающей запятой двойной точности](#196-инструкции-классификации-чисел-с-плавающей-запятой-двойной-точности)
    - [1.10 Расширение для чисел с плавающей запятой четверной точности](#110-расширение-для-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.1 Инструкции загрузки и сохранения чисел с плавающей запятой четверной точности](#1101-инструкции-загрузки-и-сохранения-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.2 Инструкции вычислений для чисел с плавающей запятой четверной точности](#1102-инструкции-вычислений-для-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.3 Инструкции инъекции знака для чисел с плавающей запятой четверной точности](#1103-инструкции-инъекции-знака-для-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.4 Инструкции преобразования чисел с плавающей запятой четверной точности](#1104-инструкции-преобразования-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.5 Инструкции сравнения чисел с плавающей запятой четверной точности](#1105-инструкции-сравнения-чисел-с-плавающей-запятой-четверной-точности)
      - [1.10.6 Инструкция классификации чисел с плавающей запятой четверной точности](#1106-инструкция-классификации-чисел-с-плавающей-запятой-четверной-точности)
    - [1.11 Расширение для сжатых инструкций (16-битные опкоды)](#111-расширение-для-сжатых-инструкций-16-битные-опкоды)
      - [1.11.1 Сжатые инструкции целочисленной арифметики](#1111-сжатые-инструкции-целочисленной-арифметики)
      - [1.11.2 Сжатые логические инструкции](#1112-сжатые-логические-инструкции)
      - [1.11.3 Сжатые инструкции сдвига](#1113-сжатые-инструкции-сдвига)
      - [1.11.4 Сжатые инструкции генерации констант](#1114-сжатые-инструкции-генерации-констант)
      - [1.11.5 Сжатые безусловные инструкции перехода](#1115-сжатые-безусловные-инструкции-перехода)
      - [1.11.6 Сжатые условные инструкции перехода](#1116-сжатые-условные-инструкции-перехода)
      - [1.11.7 Сжатые инструкции загрузки и записи](#1117-сжатые-инструкции-загрузки-и-записи)
      - [1.11.8 Разные сжатые инструкции](#1118-разные-сжатые-инструкции)
      - [1.11.9 Сжатые инструкции с плавающей точкой](#1119-сжатые-инструкции-с-плавающей-точкой)
      - [1.11.10 Сжатые инструкции HINT](#11110-сжатые-инструкции-hint)
      - [1.12 Расширение для манипуляции битами](#112-расширение-для-манипуляции-битами)
      - [1.12.1 Инструкции логических операций с инверсией (Logic-With-Negate)](#1121-инструкции-логических-операций-с-инверсией-logic-with-negate)
      - [1.12.2 Инструкции сдвига и вращения](#1122-инструкции-сдвига-и-вращения)
      - [1.12.3 Инструкции для работы с одним битом](#1123-инструкции-для-работы-с-одним-битом)
      - [1.12.4 Инструкции знакового расширения](#1124-инструкции-знакового-расширения)
      - [1.12.5 Инструкции реверса (реверсирования)](#1125-инструкции-реверса-реверсирования)
      - [1.12.6 Инструкции упаковки](#1126-инструкции-упаковки)
    - [1.13 Инструкция отладки](#113-инструкция-отладки)
  - [2 Описание процессора biRISC-V](#2-описание-процессора-birisc-v)
    - [Описание и ключевые особенности процессора](#описание-и-ключевые-особенности-процессора)
    - [Архитектура (реализация) процессора](#архитектура-реализация-процессора)
      - [Общие компоненты](#общие-компоненты)
        - [Ядро процессора](#ядро-процессора)
          - [1 frontend](#1-frontend)
          - [1.1 npc](#11-npc)
          - [1.2 fetch](#12-fetch)
          - [1.3 decode](#13-decode)
          - [2 issue](#2-issue)
          - [2.1 pipe\_ctrl](#21-pipe_ctrl)
          - [2.1.1 trace\_sim](#211-trace_sim)
          - [2.2 regfile](#22-regfile)
          - [2.2.1 xilinx\_2r1w](#221-xilinx_2r1w)
          - [3 divider](#3-divider)
          - [4 lsu](#4-lsu)
          - [5 mmu](#5-mmu)
          - [6 csr](#6-csr)
          - [6.1 biriscv\_csr\_regfile](#61-biriscv_csr_regfile)
          - [7 multiplier](#7-multiplier)
          - [8 exec](#8-exec)
          - [8.1 alu](#81-alu)
      - [Реализация с TCM памятью](#реализация-с-tcm-памятью)
        - [tcm\_top](#tcm_top)
          - [1 tcm\_mem](#1-tcm_mem)
          - [1.1 tcm\_mem\_pmem](#11-tcm_mem_pmem)
          - [1.2 tcm\_mem\_ram](#12-tcm_mem_ram)
          - [2 dport\_mux](#2-dport_mux)
          - [3 dport\_axi](#3-dport_axi)
      - [Реализация с ОЗУ](#реализация-с-озу)
        - [top](#top)
          - [1 icache](#1-icache)
          - [1.1 icache\_tag\_ram](#11-icache_tag_ram)
          - [1.2 icache\_data\_ram](#12-icache_data_ram)
          - [2 dcache](#2-dcache)
          - [2.1 dcache\_if\_pmem](#21-dcache_if_pmem)
          - [2.2 dcache\_pmem\_mux](#22-dcache_pmem_mux)
          - [2.3 dcache\_mux](#23-dcache_mux)
          - [2.4 dcache\_core](#24-dcache_core)
          - [2.4.1 dcache\_core\_tag\_ram](#241-dcache_core_tag_ram)
          - [2.4.2 dcache\_core\_data\_ram](#242-dcache_core_data_ram)
          - [2.5 dcache\_axi](#25-dcache_axi)
          - [2.5.1 dcache\_axi\_axi](#251-dcache_axi_axi)
  - [3 Руководство по программированию](#3-руководство-по-программированию)
    - [3.0 Введение](#30-введение)
      - [3.0.1 Настройка окружения](#301-настройка-окружения)
    - [3.1 Запуск](#31-запуск)
      - [3.1.1 Компиляция](#311-компиляция)
      - [3.1.2 Линковка](#312-линковка)
        - [Статическая линковка](#статическая-линковка)
        - [Динамическая линковка](#динамическая-линковка)
        - [Конфигурационные файлы линковщика (.ld)](#конфигурационные-файлы-линковщика-ld)
        - [Что можно контролировать через `.ld`](#что-можно-контролировать-через-ld)
      - [3.1.3 Загрузка на устройство](#313-загрузка-на-устройство)
  - [4 Интеграционные тесты](#4-интеграционные-тесты)
    - [4.1 Общие компоненты](#41-общие-компоненты)
      - [4.1.1 Файлы сборщика](#411-файлы-сборщика)
        - [4.1.1.1 Makefile для генерации кода](#4111-makefile-для-генерации-кода)
        - [4.1.1.2 Makefile для сборки кода](#4112-makefile-для-сборки-кода)
        - [4.1.1.3 Makefile для запуска тестов](#4113-makefile-для-запуска-тестов)
      - [4.1.2 Скрипт настройки окружения](#412-скрипт-настройки-окружения)
      - [4.1.3 Тестовая микропрограмма](#413-тестовая-микропрограмма)
    - [4.2 Виды интеграционных тестов и их отличия](#42-виды-интеграционных-тестов-и-их-отличия)
      - [4.2.1 Тесты для реализации с ОЗУ](#421-тесты-для-реализации-с-озу)
        - [4.2.1.1 Файловая структура тестбенча](#4211-файловая-структура-тестбенча)
        - [4.2.1.2 Описание, ключевые компоненты и основной функционал файлов](#4212-описание-ключевые-компоненты-и-основной-функционал-файлов)
          - [4.2.1.2.1 Исходные файлы тестов](#42121-исходные-файлы-тестов)
          - [4.2.1.2.2 Заголовочные файлы](#42122-заголовочные-файлы)
      - [4.2.2 Тесты для реализации с TCM](#422-тесты-для-реализации-с-tcm)
        - [4.2.2.1 Файловая структура тестбенча](#4221-файловая-структура-тестбенча)
        - [4.2.2.2 Описание, ключевые компоненты и основной функционал файлов](#4222-описание-ключевые-компоненты-и-основной-функционал-файлов)
          - [4.2.2.2.1 Исходные файлы тестов](#42221-исходные-файлы-тестов)
          - [4.2.2.2.3 Заголовочные файлы](#42223-заголовочные-файлы)
  - [Приложение А - описание сигнальных линий модулей ядра biRISC-V](#приложение-а---описание-сигнальных-линий-модулей-ядра-birisc-v)
    - [Входные и выходные порты, внутренние сигналы модуля __riscv\_core__](#входные-и-выходные-порты-внутренние-сигналы-модуля-riscv_core)
    - [Входные и выходные порты, основные сигналы подмодуля __issue__](#входные-и-выходные-порты-основные-сигналы-подмодуля-issue)
    - [Входные и выходные порты, основные сигналы подмодуля __frontend__](#входные-и-выходные-порты-основные-сигналы-подмодуля-frontend)
    - [Входные и выходные порты подмодуля __exec__](#входные-и-выходные-порты-подмодуля-exec)
    - [Входные и выходные порты подмодуля __csr__](#входные-и-выходные-порты-подмодуля-csr)
    - [Входные и выходные порты и основные внутренние сигналы подмодуля __lsu__](#входные-и-выходные-порты-и-основные-внутренние-сигналы-подмодуля-lsu)
      - [Модуль LSU (Load-Store Unit)](#модуль-lsu-load-store-unit)
      - [Пояснения:](#пояснения)
        - [Маска записи (`mem_wr_o`):](#маска-записи-mem_wr_o)
        - [Коды исключений (`exception_code_o`):](#коды-исключений-exception_code_o)


# Лабораторная работа № 3 - Исследование программного процессора biRISC-V

## Цели и задачи
Ознакомление с архитектурой 32-битного RISC-процессора biRISC-V, изучение его системы команд и приобретение практических навыков программирования на процессорной архитектуры RISC-V.

## 1 Введение в стандарт RISC-V
### 1.1 Принципиальные различия между вариантами ISA, основанные на разрядности и числе регистров

Архитектура набора команд RISC-V (ISA) представляет собой семейство из четырех отдельных, но связанных базовых наборов команд. Эти четыре ISA имеют либо разную ширину регистров, либо разное количество регистров, но связаны тем, что все они используют одно и то же кодирование команд для большей части базового набора команд.

Четыре базовых набора команд называются RV32I (32-битный базовый целочисленный ISA), RV32E (32-битный базовый целочисленный встроенный ISA), RV64I (64-битный базовый целочисленный ISA) и RV128I (128-битный базовый целочисленный ISA). Из них только RV32I и RV64I на данный момент заморожены.
RV32I содержит 32 32-битных регистра и поддерживает 32-битное адресное пространство. Это базовый ISA, который мы будем реализовывать в представленном здесь проекте.

Единственное различие между RV32E и RV32I заключается в том, что RV32E содержит всего 16 32-битных регистров, а не 32 32-битных регистра, как RV32I. Руководство по набору команд RISC-V объясняет это различие, утверждая, что 16 регистров составляют 25% площади и требуют 25% мощности для ядра RISC-V, и что это сокращение необходимо для встроенных систем.

RV64I содержит 64-битные регистры и обрабатывает 64-битные адреса. Все инструкции, которые применимы к RV32I, также присутствуют в RV64I, за исключением того, что эти инструкции теперь работают с 64-битными величинами, а не с 32-битными величинами. Это означает, что один и тот же код может выполняться на обеих архитектурах, но результаты будут различаться. RV64I содержит отдельные инструкции для выполнения 32-битных операций, которые будут возвращать тот же результат, что и RV32I, в младшем слове регистра, и с расширением знака в старшем слове регистра. Руководство по набору команд RISC-V признает, что это могло быть ошибкой, но что сейчас уже слишком поздно что-либо менять.

### 1.2 Принцип адресации и представления данных в RISC-V

Память RISC-V адресуется по байтам и по своей природе является little-endian. Фактическая ширина шины памяти считается деталью реализации и может быть такой широкой или узкой, как требует приложение. В качестве напоминания, нумерация байтов для системы little-endian показана на рисунке 2.1, который показывает 32-битную ширину для данных.

![Numbering](/theory/birisc_v%20description/Images/Numbering.png)

Рисунок 1: Нумерация битов/байтов/полубайтов/слов.

RISC-V работает с числами в дополнительном коде, хотя предусмотрены возможности для беззнаковых чисел для адресов. Непосредственные данные почти всегда расширяются по знаку до полной ширины 32 бита перед использованием.

Все базовые архитектуры RISC-V используют фиксированный размер инструкции в 32 бита, и все инструкции должны быть выровнены по длине в памяти. Это означает, что два наименее значащих бита адреса инструкции должны быть равны нулю, иначе будет сгенерировано исключение "Неправильное выравнивание адреса инструкции". Однако Руководство по набору инструкций RISC-V также предусматривает переменные длины инструкций, где длина является кратной 16 битам, включая опцию 16-битных инструкций. В случае 16-битных инструкций только наименее значащий бит адреса инструкции должен быть равен нулю.

Длина инструкции RISC-V кодируется в наименее значащих битах инструкции. Хотя Руководство по набору инструкций RISC-V определяет метод кодирования инструкций длиной до 192 бит, в спецификации в настоящее время заморожены только 16-битные и 32-битные инструкции. Таблица 1 показывает кодирование длины инструкции.

Таблица 1: Кодирование длины инструкции

| Инструкция (младший значащий фрагмент) | Ширина инструкции             |
|----------------------------------------|-------------------------------|
| xxxxxxxx_xxxxxxx0                      | 16 бит                        |
| xxxxxxxx_xxxxxx01                      | 16 бит                        |
| xxxxxxxx_xxxxx011                      | 32 бит                        |
| xxxxxxxx_xxxx0111                      | 32 бит                        |
| xxxxxxxx_xxx01111                      | 32 бит                        |
| xxxxxxxx_xx011111                      | 48 бит                        |
| xxxxxxxx_x0111111                      | 64 бит                        |
| xnnnxxxx_x1111111                      | 80 + 16×nnn (nnn ≠ 111)       |
| x111xxxx_x1111111                      | зарезервировано для ≥ 192 бит |

### 1.3 Классификация и структура форматов инструкций

#### 1.3.1 Форматы инструкций

Почти все, в настоящее время определенные инструкции RISC-V, используют один из всего шести основных форматов инструкций длиной 32 бита, что значительно упрощает декодирование инструкций. Рисунок 2 показывает эти форматы инструкций.

![Instruction_formats](/theory/birisc_v%20description/Images/Instruction_formats.png)

Рисунок 2: Форматы инструкций

Формат инструкции типа R используется для операций «регистр-регистр» (Register-Register). В этом формате инструкция считывает два исходных операнда из регистров и записывает результат операции в другой регистр. Исходные операнды при этом не изменяются, если только один из исходных регистров не используется также как регистр назначения.

Формат инструкции типа I используется для операций «регистр-непосредственное значение» (Register-Immediate). В этом формате инструкции считывают один исходный операнд из регистра, второй операнд берут из поля непосредственного значения в коде операции и записывают результат операции в регистр. Исходный операнд при этом не изменяется, если только исходный регистр не используется также как регистр назначения. В формате инструкции типа I непосредственное значение имеет длину 12 бит и расширяется со знаком до полных 32 бит для использования в операции. Это обеспечивает диапазон от –2048 до +2047 для непосредственных данных. Безусловное расширение со знаком обычно весьма полезно, но в некоторых случаях может создавать неудобства, о чём будет рассказано далее.

Формат инструкции типа S используется исключительно для операций записи (Store), и непосредственные данные всегда являются смещением адреса. Как и в других случаях с непосредственными данными, 12-битное смещение всегда расширяется со знаком, что даёт диапазон смещений от –2048 до +2047 относительно базового адреса в регистре.

Формат инструкции типа B используется исключительно для команд перехода (Branch), и 12-битные непосредственные данные также являются смещением адреса. В этом формате смещение в инструкции расширяется со знаком и затем сдвигается влево на один бит, чтобы гарантировать, что оно является чётным, что даёт диапазон от –212 до +212 – 2 для перехода. Биты в смещении организованы таким образом, чтобы максимально совпадать с битами смещения в формате инструкций типа S.

Формат инструкции типа U используется для команд, которым требуются более широкие непосредственные данные. В этом формате непосредственные операнды имеют ширину 20 бит и заполняют старшие биты (самые значащие) 32-битного слова, при этом младшие 12 бит этого слова устанавливаются в ноль.

Формат инструкции типа J используется исключительно для одного типа команд перехода (Jump), и 12-битные непосредственные данные также являются смещением адреса. В этом формате смещение в инструкции расширяется со знаком и затем сдвигается влево на один бит, чтобы гарантировать, что оно является чётным, что даёт диапазон от –212 до +212 – 2 для прыжка. Биты в смещении организованы таким образом, чтобы максимально совпадать с битами смещений в форматах инструкций типа U и I.

#### 1.3.2 Структурные компоненты команд: opcode, регистры, стандартные расширения

Таблица 2 показывает позиции битов для непосредственных данных в тех инструкциях, которые содержат непосредственные данные. В большинстве случаев требуется только двухвходовый мультиплексор для выбора целевого бита непосредственных данных. Это упрощает необходимую логику, но значительно усложняет интерпретацию дампа памяти. Во всех случаях старший бит (наиболее значащий бит), который будет расширяться со знаком, находится в одном и том же положении внутри кода операции (opcode).

Таблица 2: Формат инструкции Непосредственные данные

 Позиция битов инструкции

| Формат | 31  | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  |
|--------|-----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
| I-type | 11  | 10  | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1   | 0   |    |    |    |    |    |    |    |    |    |    |    |    |
| S-type | 11  | 10  | 9  | 8  | 7  | 6  | 5  |   |   |   |   |   |   |   |   |    |    |    |    |    | 4   | 3   | 2   | 1   |0
| B-type | 12  | 10  | 9  | 8  | 7  | 6  | 5  |   |   |   |   |   |   |   |   |    |    |    |    |    | 4   | 3   | 2   | 1   |11
| U-type | 31  | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20  | 19  | 18  | 17  |16  |15   |14  | 13 | 12 |    |    |    |    |
| J-type | 20  | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 11  | 19  | 18  | 17  |16  |15   |14  | 13 | 12 |    |    |    |    |

##### 1.3.2.1 Наборы регистров

Поля выбора регистров rd, rs1 и rs2 в инструкциях кодируются так, как показано в таблице 3. Регистры обозначаются именами от x0 до x31, при этом регистр x0 аппаратно зафиксирован и всегда содержит только значение ноль (только для чтения). Аппаратная фиксация x0 на нуле позволяет реализовать ряд псевдоинструкций, удобных для программирования на языке ассемблера.

В Руководстве по набору команд RISC-V также определён стандартный Application Binary Interface (ABI) с описательными именами регистров и стандартным их назначением. Большинство ассемблеров для RISC-V распознают или даже требуют использования этих описательных имён регистров.

Таблица 3: Набор регистров

| Кодировка (rd, rs1, rs2) | Имя регистра | ABI имя регистра | Описание ABI регистра             |
|-------------------------|--------------|------------------|-----------------------------------|
| 00000                   | x0           | zero             | Жёстко зафиксированный ноль        |
| 00001                   | x1           | ra               | Адрес возврата                    |
| 00010                   | x2           | sp               | Указатель стека                   |
| 00011                   | x3           | gp               | Глобальный указатель              |
| 00100                   | x4           | tp               | Указатель потока (потоков)         |
| 00101                   | x5           | t0               | Временный регистр 0               |
| 00110                   | x6           | t1               | Временный регистр 1               |
| 00111                   | x7           | t2               | Временный регистр 2               |
| 01000                   | x8           | s0/fp            | Сохраняемый регистр 0 / Указатель кадра |
| 01001                   | x9           | s1               | Сохраняемый регистр 1             |
| 01010                   | x10          | a0               | Возвращаемое значение функции 0   |
| 01011                   | x11          | a1               | Возвращаемое значение функции 1   |
| 01100                   | x12          | a2               | Аргумент функции 2                |
| 01101                   | x13          | a3               | Аргумент функции 3                |
| 01110                   | x14          | a4               | Аргумент функции 4                |
| 01111                   | x15          | a5               | Аргумент функции 5                |
| 10000                   | x16          | a6               | Аргумент функции 6                |
| 10001                   | x17          | a7               | Аргумент функции 7                |
| 10010                   | x18          | s2               | Сохраняемый регистр 2             |
| 10011                   | x19          | s3               | Сохраняемый регистр 3             |
| 10100                   | x20          | s4               | Сохраняемый регистр 4             |
| 10101                   | x21          | s5               | Сохраняемый регистр 5             |
| 10110                   | x22          | s6               | Сохраняемый регистр 6             |
| 10111                   | x23          | s7               | Сохраняемый регистр 7             |
| 11000                   | x24          | s8               | Сохраняемый регистр 8             |
| 11001                   | x25          | s9               | Сохраняемый регистр 9             |
| 11010                   | x26          | s10              | Сохраняемый регистр 10            |
| 11011                   | x27          | s11              | Сохраняемый регистр 11            |
| 11100                   | x28          | t3               | Временный регистр 3               |
| 11101                   | x29          | t4               | Временный регистр 4               |
| 11110                   | x30          | t5               | Временный регистр 5               |
| 11111                   | x31          | t6               | Временный регистр 6               |

##### 1.3.2.2 Стандартные расширения

Руководство по набору команд RISC-V также содержит ряд черновых или утверждённых стандартных расширений, выходящих за рамки базовых ISA RISC-V. Большинство из этих расширений обозначены одной буквой и показаны в таблице 4. Ряд стандартных расширений всё ещё находится в разработке и здесь рассматриваться не будет. Эти расширения выделены в таблице. Представленный здесь проект включает только часть  стандартных расширений, как показано в крайнем правом столбце таблицы.

Таблица 4: Стандартные расширения

| Идентификатор | Стандарт                                      | Статус          | Дизайн          |
|---------------|-----------------------------------------------|-----------------|-----------------|
| A             | Атомарные инструкции                          | Ратифицировано  | Частично        |
| B             | Манипуляции с битами                          | Черновик        | Частично        |
| C             | Сжатые инструкции                             | Ратифицировано  | Полностью       |
| Counters      | Счётчики                                      | Черновик        | Частично        |
| D             | Двойная точность с плавающей запятой          | Ратифицировано  |                 |
| F             | Одинарная точность с плавающей запятой        | Ратифицировано  |                 |
| H             | Гипервизорное расширение                      | Черновик        |                 |
| I             | Базовый набор инструкций                      | Ратифицировано  | Полностью       |
| J             | Динамически транслируемые языки               | Черновик        |                 |
| K             | Скалярная криптография                        | Черновик        |                 |
| L             | Десятичная арифметика с плавающей запятой     | Черновик        |                 |
| M             | Целочисленное умножение и деление             | Ратифицировано  |                 |
| N             | Прерывания на уровне пользователя             | Черновик        |                 |
| P             | Упакованный SIMD                              | Черновик        |                 |
| Q             | Четверная точность с плавающей запятой        | Ратифицировано  |                 |
| T             | Транзакционная память                         | Черновик        |                 |
| V             | Векторные операции                            | Черновик        |                 |
| Zam           | Невыравненные атомарные операции              | Черновик        | Полностью       |
| Zicsr         | Управляющие и статусные регистры              | Ратифицировано  | Полностью       |
| Zifencei      | Барьер выборки инструкций                     | Ратифицировано  | Полностью       |
| Zihintpause   | Подсказка паузы                                | Ратифицировано  |                 |
| Ztso          | Глобальный порядок записи                     | Заморожено      |                 |

##### 1.3.2.3 Условные обозначения в таблицах опкодов

В оставшейся части этой главы кодировка команд будет показана в таблицах, где различные поля разделены символом подчёркивания ( _ ), чтобы сделать поля более наглядными. Поля в кодировке команды перечислены с использованием сокращений для общих полей (опкодов). Эти сокращения в большинстве случаев должны быть понятны сами по себе, но для полноты приведены в таблице 5.

Таблица 5: Сокращения опкодов

| Опкод (opcode) | Сокращение (shortcut)         | Описание в ассемблере              | Расширение      |
|----------------|-------------------------------|------------------------------------|-----------------|
| ar aq          | and rl, 1-битные ограничения упорядочивания | A                |
| ccc...         | 12-битный адрес регистра управления и статуса (CSR) | Zicsr          |
| ddd            | rd’, выбор 3-битного регистра назначения | C                |
| ddddd          | rd, выбор 5-битного регистра назначения |                   |
| dnzdd          | rd, выбор 5-битного регистра назначения, x0 не допускается | C                |
| dn2dd          | rd, выбор 5-битного регистра назначения, x2 не допускается | C                |
| fmod           | fm, выбор 4-битного режима fence  |                   |
| iorw           | pred или succ, 4-битный выбор упорядочивания In/Out/Rd/Wr |                   |
| mm...          | imm, uimm, nzimm, nzuimm, offset или uoffset, непосредственные данные различных ширин (могут быть перемешаны) |                   |
| rnd            | rnd, 3-битный статический режим округления | F, D, Q           |
| sbsel          | sbsel, 5-битная константа (выбор бита) | B                |
| shamt          | shamt, 5-битная константа (сдвиг/вращение) |                   |
| sss            | rs1’, выбор 3-битного регистра источника 1 | C                |
| snzss          | rs1, выбор 5-битного регистра источника 1, x0 не допускается | C                |
| sssss          | rs1, выбор 5-битного регистра источника 1 |                   |
| ttt            | rs2’, выбор 3-битного регистра источника 2 | C                |
| tnztt          | rs2, выбор 5-битного регистра источника 2, x0 не допускается | C                |
| ttttt          | rs2, выбор 5-битного регистра источника 2 |                   |
| vvvvv          | rs3, выбор 5-битного регистра источника 3 | F, D, Q           |

### 1.4 Инструкции целочисленной арифметики

Базовый целочисленный набор инструкций RV32I содержит всего сорок инструкций. Эти сорок инструкций являются абсолютным минимумом для любой реализации RISC-V и достаточны для эмуляции почти всех текущих стандартных расширений RISC-V. Список этих сорока инструкций приведён в таблице 6 вместе с соответствующими опкодами. Эта таблица организована по типам опкодов, чтобы сделать информацию полезной в процессе проектирования, но отдельные инструкции будут описаны по функциональным группам.

Таблица 6: Базовый набор целочисленных инструкций

| Ассемблерная команда        | Формат опкода                                | Тип  |
|-----------------------------|-----------------------------------------------|------|
| Defined Illegal             | 1111111_11111_11111_111_11111_1111111         | R    |
| ADD rd, rs1, rs2            | 0000000_ttttt_sssss_000_ddddd_0110011         | R    |
| SUB rd, rs1, rs2            | 0100000_ttttt_sssss_000_ddddd_0110011         | R    |
| SLL rd, rs1, rs2            | 0000000_ttttt_sssss_001_ddddd_0110011         | R    |
| SLT rd, rs1, rs2            | 0000000_ttttt_sssss_010_ddddd_0110011         | R    |
| SLTU rd, rs1, rs2           | 0000000_ttttt_sssss_011_ddddd_0110011         | R    |
| XOR rd, rs1, rs2            | 0000000_ttttt_sssss_100_ddddd_0110011         | R    |
| SRL rd, rs1, rs2            | 0000000_ttttt_sssss_101_ddddd_0110011         | R    |
| SRA rd, rs1, rs2            | 0100000_ttttt_sssss_101_ddddd_0110011         | R    |
| OR rd, rs1, rs2             | 0000000_ttttt_sssss_110_ddddd_0110011         | R    |
| AND rd, rs1, rs2            | 0000000_ttttt_sssss_111_ddddd_0110011         | R    |
| LB rd, offset(rs1)          | mmmmmmm_mmmmm_sssss_000_ddddd_0000011         | I    |
| LH rd, offset(rs1)          | mmmmmmm_mmmmm_sssss_001_ddddd_0000011         | I    |
| LW rd, offset(rs1)          | mmmmmmm_mmmmm_sssss_010_ddddd_0000011         | I    |
| LBU rd, offset(rs1)         | mmmmmmm_mmmmm_sssss_100_ddddd_0000011         | I    |
| LHU rd, offset(rs1)         | mmmmmmm_mmmmm_sssss_101_ddddd_0000011         | I    |
| ADDI rd, rs1, imm           | mmmmmmm_mmmmm_sssss_000_ddddd_0010011         | I    |
| SLLI rd, rs1, shamt         | 0000000_shamt_sssss_001_ddddd_0010011         | I    |
| SLTI rd, rs1, imm           | mmmmmmm_mmmmm_sssss_010_ddddd_0010011         | I    |
| SLTIU rd, rs1, imm          | mmmmmmm_mmmmm_sssss_011_ddddd_0010011         | I    |
| XORI rd, rs1, imm           | mmmmmmm_mmmmm_sssss_100_ddddd_0010011         | I    |
| SRLI rd, rs1, shamt         | 0000000_shamt_sssss_101_ddddd_0010011         | I    |
| SRAI rd, rs1, shamt         | 0100000_shamt_sssss_101_ddddd_0010011         | I    |
| ORI rd, rs1, imm            | mmmmmmm_mmmmm_sssss_110_ddddd_0010011         | I    |
| ANDI rd, rs1, imm           | mmmmmmm_mmmmm_sssss_111_ddddd_0010011         | I    |
| JALR rd, offset(rs1)        | mmmmmmm_mmmmm_sssss_000_ddddd_1100111         | I    |
| FENCE fmodior_wiorw         | 00000_000_00000_0001111                       | I    |
| ECALL                       | 0000000_00000_00000_000_00000_1110011         | I    |
| EBREAK                      | 0000000_00001_00000_000_00000_1110011         | I    |
| SB rs2, offset(rs1)         | mmmmmmm_ttttt_sssss_000_mmmmm_0100011         | S    |
| SH rs2, offset(rs1)         | mmmmmmm_ttttt_sssss_001_mmmmm_0100011         | S    |
| SW rs2, offset(rs1)         | mmmmmmm_ttttt_sssss_010_mmmmm_0100011         | S    |
| BEQ rs1, rs2, offset        | mmmmmmm_ttttt_sssss_000_mmmmm_1100011         | B    |
| BNE rs1, rs2, offset        | mmmmmmm_ttttt_sssss_001_mmmmm_1100011         | B    |
| BLT rs1, rs2, offset        | mmmmmmm_ttttt_sssss_100_mmmmm_1100011         | B    |
| BGE rs1, rs2, offset        | mmmmmmm_ttttt_sssss_101_mmmmm_1100011         | B    |
| BLTU rs1, rs2, offset       | mmmmmmm_ttttt_sssss_110_mmmmm_1100011         | B    |
| BGEU rs1, rs2, offset       | mmmmmmm_ttttt_sssss_111_mmmmm_1100011         | B    |
| AUIPC rd, imm               | mmmmmmm_mmmmm_mmmmm_mmm_ddddd_0010111         | U    |
| LUI rd, imm                 | mmmmmmm_mmmmm_mmmmm_mmm_ddddd_0110111         | U    |
| JAL rd, offset              | mmmmmmm_mmmmm_mmmmm_mmm_ddddd_1101111         | J    |

#### 1.4.1 Инструкции целочисленной арифметики

Инструкции **ADD rd, rs1, rs2** (Сложение) и **SUB rd, rs1, rs2** (Вычитание) являются инструкциями арифметических операций "регистр-регистр". В соответствии с теоретическими основами RISC, эти арифметические операции генерируют только 32-битный результат, и если требуется проверка переноса или переполнения, это должно обрабатываться отдельно программно. Для вычитания регистр **rs2** вычитается из регистра **rs1**.

Для беззнаковых операндов переполнение совпадает с переносом или заимствованием из старшего разряда, и это можно проверить напрямую с помощью условной команды перехода сразу после операции, при условии, что исходные операнды не были изменены.

Для сложения проверка на переполнение требует двух дополнительных инструкций и условного перехода, а также использования двух временных регистров. Для вычитания проверка на переполнение требует трёх дополнительных инструкций и условного перехода, плюс использование двух временных регистров. В обоих случаях оригинальные исходные регистры могут быть использованы как временные, если операнды не нужно сохранять.

Существует одна псевдоинструкция, которая использует арифметическую инструкцию "регистр-регистр":

**NEG rd, rs** (Дополнение до двух или Инверсия знака) — это **SUB rd, x0, rs**.

**ADDI rd, rs1, imm** (Сложение с непосредственным операндом) — это единственная арифметическая инструкция "регистр-непосредственное значение". Безусловное знаковое расширение для непосредственных данных делает ненужным существование инструкции вычитания с непосредственным операндом.

Существует значительное количество комбинаций операндов инструкций, которые приведут к отсутствию операции со стороны процессора, но определённый стандартом код для No Operation (**NOP**) использует инструкцию **ADDI**. Инструкция **ADDI** также используется для реализации псевдоинструкции, которая копирует один регистр в другой.

**NOP** (Нет операции) — это просто **ADDI x0, x0, 0**.

**MV rd, rs** (Копирование регистра) — это просто **ADDI rd, rs, 0**.

#### 1.4.2 Инструкции логических операций

**AND rd, rs1, rs2** (Логическое И), **OR rd, rs1, rs2** (Логическое ИЛИ) и **XOR rd, rs1, rs2** (Логическое исключающее ИЛИ) — это инструкции логических операций "регистр-регистр". Как и раньше, поскольку в архитектуре RISC-V нет флагов, результат должен быть явно проверен на равенство нулю или на знак, если требуется такой тип состояния. Проверка результата на ноль или знак так же проста, как и условный переход.

**ANDI rd, rs1, imm** (Логическое И с непосредственным операндом), **ORI rd, rs1, imm** (Логическое ИЛИ с непосредственным операндом) и **XORI rd, rs1, imm** (Логическое исключающее ИЛИ с непосредственным операндом) — это инструкции логических операций "регистр-непосредственное значение".

Безусловное знаковое расширение непосредственных операндов полезно для операции AND, но менее полезно для операций OR и XOR. Например, попытка установить бит 11 с помощью операции OR приведёт к тому, что биты с 31-го по 11-й в непосредственном значении будут установлены, поэтому все эти биты также будут установлены в регистре rd.

Одна псевдоинструкция использует логическую инструкцию с непосредственным операндом:

**NOT rd, rs** (Дополнение до одного или Логическое НЕ) — это просто **XORI rd, rs, -1**.

#### 1.4.3 Инструкции сдвига

**SLL rd, rs1, rs2** (Логический сдвиг влево), **SRA rd, rs1, rs2** (Арифметический сдвиг вправо) и **SRL rd, rs1, rs2** (Логический сдвиг вправо) — это инструкции сдвига. Количество сдвига указывается в пяти младших разрядах регистра **rs2**, что позволяет выполнять сдвиги от нуля до тридцати одного бита. Остальные биты регистра **rs2** игнорируются.

Два логических сдвига вводят нули, тогда как арифметический сдвиг повторяет бит знака.

В наборе команд RV32I отсутствуют инструкции циклического сдвига, поэтому циклические сдвиги должны имитироваться путём комбинирования результата двух сдвигов с использованием двух временных регистров.

**SLLI rd, rs1, shamt** (Логический сдвиг влево с непосредственным значением), **SRAI rd, rs1, shamt** (Арифметический сдвиг вправо с непосредственным значением) и **SRLI rd, rs1, shamt** (Логический сдвиг вправо с непосредственным значением) — это инструкции сдвига с непосредственным операндом. Количество сдвига указывается пятью битами поля непосредственного значения в коде операции. Этот указатель сдвига является беззнаковым, что позволяет выполнять сдвиги от нуля до тридцати одного бита. Остальные биты в поле непосредственного значения используются как часть кода операции.

#### 1.4.4 Инструкции сравнения

**SLT rd, rs1, rs2** (Установить, если меньше) и **SLTU rd, rs1, rs2** (Установить, если меньше, беззнаковое) — это инструкции сравнения для знаковых и беззнаковых данных. Эти инструкции устанавливают регистр **rd** в 0x1, если сравнение (**rs1 < rs2**) истинно, и в 0x0 в противном случае. Эти операции предоставляют альтернативу выделенным флагам за счёт использования целого регистра.

Существует три псевдо-инструкции сравнения:

**SGTZ rd, rs** (Установить, если больше нуля) — это **SLT rd, x0, rs**

**SLTZ rd, rs** (Установить, если меньше нуля) — это **SLT rd, rs, x0**

**SNEZ rd, rs** (Установить, если не равно нулю) — это **SLTU rd, x0, rs**

**SLTI rd, rs1, imm** (Установить, если меньше чем непосредственное значение) и **SLTIU rd, rs1, imm** (Установить, если меньше чем непосредственное значение, беззнаковое) являются знаковыми и беззнаковыми инструкциями сравнения с непосредственным операндом. Эти инструкции устанавливают регистр rd в значение 0x1, если сравнение **(rs1 < imm)** истинно, и в 0x0 в противном случае. Непосредственный операнд всегда знаковорасширяется, даже для инструкции SLTIU.

Только одна инструкция сравнения с непосредственным операндом предоставляет полезную псевдо-инструкцию:

**SEQZ rd, rs** (Установить, если равно нулю) — это **SLTIU rd, rs, 1**.

#### 1.4.5 Инструкции генерации констант

Существует две инструкции генерации констант. В этих инструкциях непосредственные операнды шириной двадцать бит заполняют старшие биты 32-битного слова, при этом младшие 12 бит устанавливаются в ноль.

**AUIPC rd, imm** (Добавить старшие биты непосредственного операнда к PC) позволяет создавать 32-битные PC-относительные адреса для использования с загрузками, сохранениями и переходами, добавляя непосредственный операнд к счетчику команд (PC) этой инструкции и сохраняя результат в регистр rd.

**LUI rd, imm** (Загрузить старшие биты непосредственного операнда) позволяет создавать 32-битные константы или абсолютные адреса, загружая непосредственный операнд напрямую в регистр **rd**.

Эти две инструкции обычно сопровождаются инструкцией **ADDI** для загрузки младших 12 бит. Однако, поскольку непосредственный операнд инструкции **ADDI** знаковорасширяется перед сложением, требуется осторожность, чтобы компенсировать это знаковое расширение. Компенсация требует добавления старшего значащего бита операнда ADDI к 20-битному операнду в одной из этих инструкций.

Большинство ассемблеров RISC-V предоставляют пару псевдо-инструкций, которые автоматически разворачиваются в необходимую последовательность из двух инструкций для работы с 32-битным значением:

- **LI rd, imm** (Загрузить непосредственный операнд) загружает 32-битную константу или абсолютный адрес в регистр **rd**. Общая реализация будет состоять из инструкции **LUI rd, imm**[31:12] + **imm**[11], за которой следует **ADDI rd, x0, imm**[11:0]. Компоновщик выполнит сложение для значения непосредственного операнда **LUI** во время стадии компоновки (link phase). Некоторые ассемблеры достаточно умны, чтобы использовать только инструкцию LUI или только ADDI, если значение константы находится в нужном диапазоне.

- **LA rd, symbol** (Загрузить адрес) загружает 32-битный PC-относительный адрес в регистр **rd**. Общая реализация будет состоять из инструкции **AUIPC rd, imm**[31:12] + **imm**[11], за которой следует **ADDI rd, x0, imm**[11:0]. Компоновщик вычислит требуемое значение непосредственного операнда и затем выполнит сложение для значения непосредственного операнда **AUIPC** во время стадии компоновки.

#### 1.4.6 Безусловные инструкции перехода

Существует два типа безусловных инструкций перехода, и эти две инструкции могут реализовать большинство инструкций передачи управления, известных программистам на ассемблере.

В архитектуре RISC-V нет выделенного указателя стека, но эти две инструкции предоставляют регистр связи (link register), который аналогичен вершине стека возврата. Этот регистр должен быть сохранён подпрограммой в случае, если подпрограмма вызывает другую подпрограмму. В соглашении о вызовах RISC-V регистр x1 используется как этот регистр возвратного адреса, хотя эти инструкции могут использовать любой регистр для этой цели.

**JAL rd, offset** (Прыжок и связь) добавляет смещение из инструкции к счётчику команд (PC) этой инструкции. Одновременно счётчик команд для следующей инструкции записывается в регистр **rd**, используемый как регистр связи. 20-битное смещение в инструкции знаковорасширяется и затем сдвигается влево на один бит, чтобы гарантировать, что оно чётное, что даёт диапазон от –2²⁰ до +2²⁰ – 2 для прыжка. Чётное смещение требуется, потому что инструкции RISC-V должны быть выровнены по полуслову (2 байта).

**JALR rd, offset(rs1)** (Прыжок и связь через регистр) добавляет смещение из инструкции к содержимому регистра **rs1** и записывает результат в счётчик команд. Одновременно счётчик команд для следующей инструкции записывается в регистр **rd**. Смещение для этой инструкции составляет 12 бит, что даёт диапазон от –2¹¹ до +2¹¹ – 1 для смещения.

Одна из особенностей этой инструкции в том, что аппаратно должен быть установлен младший бит результата сложения в ноль, чтобы сделать целевой адрес чётным, перед его загрузкой в PC. Если этой инструкции предшествует либо **AUIPC**, либо **LUI**, то эффективный диапазон прыжка охватывает всё адресное пространство.

Существует две псевдо-инструкции PC-относительных переходов:

- **J offset** (Прыжок) — это  **JAL x0, offset**. Это обычный PC-относительный прыжок, без необходимости возврата.

- **JAL offset** (Прыжок и связь) — это  **JAL x1, offset**, следуя соглашению, что регистр x1 используется как регистр возвратного адреса. Это аналогично вызову подпрограммы с PC-относительным адресом.

Существует три псевдо-инструкции перехода, которые используют регистр для адреса:

- **JR rs** (Прыжок по регистру) — это  **JALR x0, 0(rs)**. Это обычный прыжок по абсолютному адресу, возврат не требуется.

- **JALR rs (Прыжок и связь через регистр)** — это **JALR x1, 0(rs)**. Это также обычный прыжок по абсолютному адресу, но с сохранением адреса возврата. Это может заменить специализированную инструкцию **CALL**, в зависимости от ассемблера.

- **RET** (Возврат из подпрограммы) — это **JALR x0, 0(x1)**. Эта инструкция возвращает счётчик команд (PC) к адресу, хранящемуся в регистре возвратного адреса.

Некоторые ассемблеры также распознают две другие псевдо-инструкции, которые используют регистр для адреса, хотя режим адресации на самом деле PC-относительный для поддержки позиционно-независимого кода:

- **CALL rd, symbol** (Вызов подпрограммы) разворачивается в последовательность из двух инструкций:
**AUIPC rd, imm**[31:12] + **imm**[11], за которой следует **JALR x1, imm**[11:0] **(rd)**.
Если **rd** опущен в коде на ассемблере, предполагается использование регистра x6.

- **TAIL rs, symbol** (Хвостовой вызов подпрограммы) разворачивается в последовательность из двух инструкций:
**AUIPC rs, imm**[31:12] + **imm**[11], за которой следует **JALR x0, imm**[11:0] (**rs**).
Если **rs** опущен в коде на ассемблере, обычно предполагается использование регистра x6, согласно соглашению о вызовах в RISC-V. В JALR здесь используется регистр x0, чтобы избежать повреждения стека возвратов.

#### 1.4.7 Условные инструкции перехода

Условные инструкции перехода сравнивают содержимое двух регистров, и если условие, заданное инструкцией, выполняется, то смещение из инструкции прибавляется к счётчику команд (PC) этой инструкции. 12-битное смещение в инструкции знаковорасширяется и затем сдвигается влево на один бит, чтобы гарантировать, что оно чётное, что даёт диапазон от –2¹² до +2¹² – 2 для перехода.

- **BEQ rs1, rs2, offset** (Переход, если равно) выполняет переход, если содержимое двух регистров идентично.

- **BNE rs1, rs2, offset** (Переход, если не равно) выполняет переход, если содержимое двух регистров различно.

- **BGE rs1, rs2, offset** (Переход, если больше или равно) выполняет переход, если содержимое регистра **rs1** больше либо равно содержимому регистра **rs2**, рассматривая оба как знаковые числа.

- **BGEU rs1, rs2, offset** (Переход, если больше или равно, беззнаковый) выполняет переход, если содержимое регистра **rs1** больше либо равно содержимому регистра **rs2**, рассматривая оба как беззнаковые числа.

- **BLT rs1, rs2, offset** (Переход, если меньше) выполняет переход, если содержимое регистра **rs1** меньше содержимого регистра **rs2**, рассматривая оба как знаковые числа.
  
- **BLTU rs1, rs2, offset** (Переход, если меньше, беззнаковый) выполняет переход, если содержимое регистра **rs1** меньше содержимого регистра **rs2**, рассматривая оба как беззнаковые числа.

Эти шесть инструкций достаточно для покрытия всех возможных случаев, потому что изменение порядка выбранных регистров создаёт противоположное условие теста. Это противоположное условие создаёт четыре псевдо-инструкции:

- **BGT rs, rt, offset** (Переход, если >) — это **BLT rt, rs, offset**;

- **BGTU rs, rt, offset** (Переход, если >, беззнаковый) — это **BLTU rt, rs, offset**;

- **BLE rs, rt, offset** (Переход, если ≤) — это **BGE rt, rs, offset**;

- **BLEU rs, rt, offset** (Переход, если ≤, беззнаковый) — это **BGEU rt, rs, offset**.

Когда запрограммированный ноль из регистра x0 используется в качестве одного из операндов, создаются ещё шесть псевдо-инструкций:

- **BEQZ rs, offset** (Переход, если = ноль) — это **BEQ rs, x0, offset**;

- **BNEZ rs, offset** (Переход, если ≠ ноль) — это **BNE rs, x0, offset**;

- **BGEZ rs, offset** (Переход, если ≥ ноль) — это **BGE rs, x0, offset**;

- **BLEZ rs, offset** (Переход, если ≤ ноль) — это **BGE x0, rs, offset**;

- **BGTZ rs, offset** (Переход, если > ноль) — это **BLT x0, rs, offset**;

- **BLTZ rs, offset** (Переход, если < ноль) — это **BLT rs, x0, offset**.

#### 1.4.8 Инструкции загрузки и сохранения данных

Основной принцип концепции RISC состоит в том, что только инструкции загрузки (load) и сохранения (store) обращаются к памяти, и обычно используют только один простой режим адресации. Все инструкции загрузки и сохранения в RISC-V используют режим адресации "база + смещение" (base+offset), при этом в инструкции доступно 12-битное смещение. Как и для других непосредственных данных, смещение всегда знаково расширяется, что даёт диапазон от –2¹¹ до +2¹¹ – 1 относительно базового адреса в регистре.

Руководство по набору инструкций RISC-V не накладывает никаких требований на выравнивание для загрузок и сохранений и явно допускает, что невыравненные доступы могут быть реализованы как в аппаратуре, так и в программном обеспечении. Беззнаковые версии загрузки байтов и полуслов (byte и halfword loads) очень полезны для реализации невыравненных загрузок в программном обеспечении.

- **LB rd, offset(rs1)** (Загрузка байта) загружает один байт из памяти в наименее значимый байт регистра **rd**, выполняя знаковое расширение байта для заполнения оставшихся трёх байт регистра.

- **LBU rd, offset(rs1)** (Загрузка байта, беззнаковая) загружает один байт из памяти в наименее значимый байт регистра **rd**, заполняя оставшиеся три байта регистра нулями.

- **LH rd, offset(rs1)** (Загрузка полуслова) загружает одно полуслово из памяти в младшую половину регистра **rd**, выполняя знаковое расширение полуслова для заполнения старшей половины регистра.

- **LHU rd, offset(rs1)** (Загрузка полуслова, беззнаковая) загружает одно полуслово из памяти в младшую половину регистра **rd**, заполняя старшую половину регистра нулями.

- **LW rd, offset(rs1)** (Загрузка слова) загружает одно слово из памяти в регистр **rd**.

- **SB rs2, offset(rs1)** (Сохранение байта) сохраняет наименее значимый байт регистра **rs2** в память.
  
- **SH rs2, offset(rs1)** (Сохранение полуслова) сохраняет наименее значимое полуслово регистра **rs2** в память.

- **SW rs2, offset(rs1)** (Сохранение слова) сохраняет содержимое регистра rs2 в память.

#### 1.4.9 Инструкции упорядочивания памяти

Инструкции упорядочивания памяти включены в базовый набор инструкций для поддержки суперскалярных, внеочередных (out-of-order) или многоядерных процессоров RISC-V. Описанный здесь дизайн не обладает этими характеристиками, поэтому для получения более подробной информации о порядке доступа к памяти необходимо обратиться к руководству по набору инструкций RISC-V.

**FENCE fm, pred, succ** (Барьер) — это инструкция, используемая для упорядочивания транзакций ввода с устройства, вывода на устройство, чтения из памяти и записи в память на внешней шине, если такие транзакции не гарантируются к выполнению в порядке программного кода. См. руководство по инструкциям RISC-V для значений различных полей этой инструкции.

**FENCE.I** (Барьер инструкций) — это инструкция, используемая для упорядочивания записей в память инструкций относительно выборки инструкций, для самомодифицирующегося кода. Эта инструкция ранее входила в базовый набор команд, но недавно была перемещена в отдельное стандартное расширение под названием «Zifenci» (Instruction-Fetch Fence extension). Эта инструкция обычно включена во все реализации и приведена здесь по этой причине.

#### 1.4.10 Инструкции вызова окружения и точки останова

Инструкции вызова окружения и точки останова включены в набор команд RV32I для поддержки доступа к системному программному обеспечению или службам. Обе эти инструкции генерируют исключение. Важно помнить, что при возникновении исключения сохраняется адрес инструкции, вызвавшей исключение, а не адрес следующей инструкции.

**ECALL** (Вызов окружения) генерирует исключение вызова окружения, что по сути является запросом на выполнение системной службы. В отличие от многих архитектур, инструкция **ECALL** не использует непосредственные данные в коде операции для передачи параметров этого запроса.

**EBREAK** (Точка останова окружения) генерирует исключение точки останова и вызывает возврат управления в отладочную среду.

#### 1.4.11 Прочие инструкции

Одна 32-битная инструкция не попадает ни в одну другую категорию, и на самом деле она не является инструкцией, а представляет собой битовую последовательность, которая гарантированно вызовет исключение «Недопустимая инструкция». Это полезно для обнаружения стёртой флеш-памяти, а также помогает декодеру сжатых опкодов, который может выводить этот шаблон для принудительного вызова исключения.

Определённая недопустимая инструкция — это просто 32 бита, все единицы.

#### 1.4.12 Инструкции HINT

Жёсткая привязка регистра x0 к нулю означает, что большое количество опкодов RISC-V становятся бесполезными, и руководство по набору инструкций RISC-V резервирует многие из этих кодировок как инструкции **HINT** (подсказки), которые могут "передавать подсказки по производительности микроархитектуре". На данный момент ни одна из этих инструкций не определена как выполняющая какое-либо действие. Поэтому поведение по умолчанию — ничего не делать — естественно вытекает из конструкции с регистром x0, который является только для чтения и всегда равен нулю, и нам не нужно уделять этим инструкциям особого внимания.

Псевдоинструкция **NOP** (No Operation — нет операции) закодирована с использованием одной из таких кодировок, которые в противном случае были бы **HINT**. В таблице 7 перечислены инструкции **HINT**. Большинство этих кодировок зарезервированы для будущего стандартного использования, но также есть достаточно много зарезервированных для пользовательского применения.

Таблица 7: HINT-инструкции RV32I

| Инструкция | Условие                                                        | Использование                |
|------------|----------------------------------------------------------------|------------------------------|
| ADD        | rd = x0                                                        |      Зарезервировано для стандартного использования                        |
| ADDI       | rd = x0 и (rs1 ≠ x0 или imm ≠ 0)                               |         Зарезервировано для стандартного использования                     | 
| AND        | rd = x0                                                        |   Зарезервировано для стандартного использования                           |
| ANDI       | rd = x0                                                        | Зарезервировано для стандартного использования                             |
| AUIPC      | rd = x0                                                        |     Зарезервировано для стандартного использования                         |
| FENCE      | pred = 0 или succ = 0                                          | Зарезервировано для стандартного использования                             |
| LUI        | rd = x0                                                        | Зарезервировано для стандартного использования                             |
| OR         | rd = x0                                                        | Зарезервировано для стандартного использования |
| ORI        | rd = x0                                                        | Зарезервировано для стандартного использования |
| SLL        | rd = x0                                                        | Зарезервировано для стандартного использования |
| SRA        | rd = x0                                                        | Зарезервировано для стандартного использования |
| SRL        | rd = x0                                                        | Зарезервировано для стандартного использования |
| SUB        | rd = x0                                                        | Зарезервировано для стандартного использования |
| XOR        | rd = x0                                                        | Зарезервировано для стандартного использования |
| XORI       | rd = x0                                                        | Зарезервировано для стандартного использования |
| SLLI       | rd = x0                                                        |Зарезервировано для пользовательского использования                              |
| SLT        | rd = x0                                                        |Зарезервировано для пользовательского использования                              |
| SLTI       | rd = x0                                                        |Зарезервировано для пользовательского использования                              |
| SLTU       | rd = x0                                                        | Зарезервировано для пользовательского использования |
| SLTIU      | rd = x0                                                        | Зарезервировано для пользовательского использования |
| SRAI       | rd = x0                                                        | Зарезервировано для пользовательского использования |
| SRAI       | rd = x0                                                        | Зарезервировано для пользовательского использования |

### 1.5 Расширение регистров управления и статуса (CSR)

Архитектура RISC-V предоставляет 12-битное адресное пространство для регистров управления и статуса (CSR), что в сумме даёт 4096 уникальных адресов CSR. Однако, несколько битов этих адресов зарезервированы для кодирования уровней доступа, поэтому фактическое количество доступных регистров CSR значительно меньше.

Изначально инструкции CSR входили в обязательную часть спецификации RISC-V, поскольку они были необходимы для доступа к трём 64-битным счётчикам производительности, которые также считались обязательными. Обязательность трёх 64-битных счётчиков не является проблемой для процессора RISC-V, работающего под управлением Linux. В результате, счётчики производительности и инструкции CSR были впоследствии перенесены в опциональное расширение, называемое «Zicsr» (расширение инструкций управления и статуса CSR).

На практике инструкции CSR всегда требуются, так как они необходимы для обработки прерываний и исключений. В таблице 8 приведены инструкции CSR.

Таблица 8: Инструкции управления и статуса (CSR)

| Ассемблерная команда  | Опкод                                | Тип  |
|-----------------------|---------------------------------------|------|
| CSRRW rd, csr, rs1    | ccccccc_ccccc_sssss_001_ddddd_1110011 | CI   |
| CSRRS rd, csr, rs1    | ccccccc_ccccc_sssss_010_ddddd_1110011 | CI   |
| CSRRC rd, csr, rs1    | ccccccc_ccccc_sssss_011_ddddd_1110011 | CI   |
| CSRRWI rd, csr, imm   | ccccccc_ccccc_mmmmm_101_ddddd_1110011 | CI*  |
| CSRRSI rd, csr, imm   | ccccccc_ccccc_mmmmm_110_ddddd_1110011 | CI*  |
| CSRRCI rd, csr, imm   | ccccccc_ccccc_mmmmm_111_ddddd_1110011 | CI*  |

Инструкции работы с регистрами CSR используют формат инструкции I-типа, при этом адрес CSR занимает поле непосредственных данных (immediate). В общем случае эти инструкции читают один операнд из регистра **rs1** и один операнд из CSR, затем записывают данные как в регистр **rd**, так и в CSR.
Если в инструкции указан регистр x0 в качестве **rd** или **rs1**, поведение этих инструкций изменяется, как описано ниже. Эти изменения усложняют проектирование логики.

Инструкции CSR-Immediate используют модифицированный формат I-типа, в котором поле **rs1** заменено на 5-битное непосредственное значение, расширяемое нулями для использования в инструкции. За исключением этой замены, такие инструкции работают аналогично соответствующим инструкциям работы с регистром CSR.
5-битное непосредственное значение означает, что только пять младших бит в регистре CSR могут быть установлены или очищены напрямую с помощью этих инструкций.

#### 1.5.1 Инструкции чтения и записи CSR

**CSRRW rd, csr, rs1** (Атомарное чтение и запись CSR) считывает указанный регистр CSR и записывает это значение в регистр **rd**. В то же время содержимое регистра **rs1** записывается в указанный CSR. Это атомарная операция, поэтому если поля **rd** и **rs1** указывают на один и тот же регистр, происходит обмен содержимым между регистром CSR и регистром **rd**.

Если в качестве операнда **rd** указан регистр x0, поведение инструкции CSRRW изменяется: чтение CSR не производится, а выполняется только запись в CSR. 

Это приводит к появлению псевдоинструкции:

**CSRW csr, rs** (Запись в CSR) — это **CSRRW x0, csr, rs**. Чтение CSR не происходит.

**CSRRWI rd, csr, imm** (Атомарное чтение и запись CSR с непосредственным значением) работает аналогично инструкции **CSRRW**, включая особый случай, когда в качестве **rd** указан регистр x0, за исключением того, что вместо регистра **rs1** используется непосредственное значение из инструкции.

Также возникает одна псевдоинструкция:

**CSRWI csr, imm** (Запись в CSR с непосредственным значением) — это **CSRRWI x0, csr, imm**. Чтение CSR не происходит.

#### 1.5.2 Инструкции установки CSR

**CSRRS rd, csr, rs1** (Атомарное чтение и установка бит в CSR) считывает указанный регистр CSR и записывает это значение в регистр **rd**. В то же время значение из регистра **rs1** используется как маска бит для установки битов в значении, считанном из CSR (единица означает установку бита), и результат записывается обратно в CSR. Это атомарная операция.

Если в качестве операнда **rs1** указан регистр x0, поведение инструкции CSRRS изменяется таким образом, что запись в CSR не происходит, и выполняется только чтение CSR. Есть пара псевдоинструкций, использующих инструкцию CSRRS, одна из которых использует это поведение:

- **CSRS csr, rs** (Установить биты в CSR) — это **CSRRS x0, csr, rs**. Эта инструкция устанавливает биты в CSR без сохранения исходных данных CSR в регистре.

- **CSRR rd, csr** (Чтение CSR) — это **CSRRS rd, csr, x0**. Запись в CSR не происходит.

Изначально спецификация RISC-V требовала наличия трех 64-битных счетчиков для всех реализаций. Эти счетчики теперь являются необязательной частью привилегированной архитектуры RISC-V, но многие ассемблеры по-прежнему реализуют специализированные псевдоинструкции для доступа к CSR, связанным с этими счетчиками:

- **RDCYCLE rd** (Чтение счетчика циклов) — это **CSRRS rd, 0xc00, x0**;

- **RDCYCLEH rd** (Чтение старшей половины счетчика циклов) — это **CSRRS rd, 0xc80, x0**;

- **RDINSTRET rd** (Чтение счетчика выполненных инструкций) — это **CSRRS rd, 0xc02, x0**.

- **RDINSTRETH rd** (Чтение старшей половины счетчика выполненных инструкций) — это просто **CSRRS rd, 0xc82, x0**.

**RDTIME rd** (Чтение таймера) — это просто **CSRRS rd, 0xc01, x0**.

**RDTIMEH rd** (Чтение старшей половины таймера) — это просто **CSRRS rd, 0xc80, x0**.

**CSRRSI rd, csr, imm** (Атомарное чтение и установка бит в CSR с непосредственным значением) работает аналогично инструкции CSRRS, за исключением того, что непосредственное значение в инструкции используется вместо значения из регистра **rs1**. Когда операнд imm равен нулю, поведение инструкции CSRRSI изменяется, так что запись в CSR не происходит, и выполняется только чтение CSR. Псевдоинструкции, использующие этот особый случай, нет.

Существует одна псевдоинструкция, использующая инструкцию **CSRRSI**:

**CSRSI csr, imm** (Установить CSR с непосредственным значением) — это  **CSRRSI x0, csr, imm**.

### 1.6 Расширение умножения и деления целых чисел

Стандартное расширение «M» для умножения и деления целых чисел добавляет операции умножения и деления в набор инструкций RISC-V. Как и в случае инструкций целочисленной арифметики, не предусмотрено аппаратного обнаружения переполнения или деления на ноль, и программное обеспечение отвечает за обнаружение этих условий. Руководство по набору инструкций RISC-V полностью определяет, какие результаты должны возвращаться для различных инструкций деления и остатка в случае ошибки, но не указывает, что должна возвращать инструкция умножения в случае переполнения.

Таблица 9 показывает полный набор инструкций умножения и деления целых чисел, все из которых используют формат инструкции типа R (R-type).

Таблица 9: Инструкции умножения и деления целых чисел

| Ассемблерная команда | Опкод                                | Тип  |
|----------------------|---------------------------------------|------|
| MUL rd, rs1, rs2     | 0000001_ttttt_sssss_000_ddddd_0110011 | R    |
| MULH rd, rs1, rs2    | 0000001_ttttt_sssss_001_ddddd_0110011 | R    |
| MULHSU rd, rs1, rs2  | 0000001_ttttt_sssss_010_ddddd_0110011 | R    |
| MULHU rd, rs1, rs2   | 0000001_ttttt_sssss_011_ddddd_0110011 | R    |
| DIV rd, rs1, rs2     | 0000001_ttttt_sssss_100_ddddd_0110011 | R    |
| DIVU rd, rs1, rs2    | 0000001_ttttt_sssss_101_ddddd_0110011 | R    |
| REM rd, rs1, rs2     | 0000001_ttttt_sssss_110_ddddd_0110011 | R    |
| REMU rd, rs1, rs2    | 0000001_ttttt_sssss_111_ddddd_0110011 | R    |

Четыре разные инструкции умножения охватывают все возможные случаи при умножении знаковых (в дополнительном коде) и беззнаковых чисел. Полное умножение 32-битного числа на 32-битное требует двух инструкций умножения, так как каждая инструкция может вернуть только 32 бита результата.

**MUL rd, rs1, rs2** (Умножение) — это базовая инструкция умножения, которая возвращает младшие 32 бита произведения регистра **rs1** и регистра **rs2**. Эта инструкция работает одинаково для любой комбинации знаковых и беззнаковых значений.

**MULH rd, rs1, rs2** (Умножение, старшие биты) — это вторая половина базовой инструкции умножения, которая возвращает старшие 32 бита произведения регистра **rs1** и регистра **rs2**, предполагая, что оба они являются знаковыми числами.

**MULHSU rd, rs1, rs2** (Умножение, старшие биты, знаковое-беззнаковое) возвращает старшие 32 бита произведения регистра **rs1** и регистра **rs2**, предполагая, что регистр **rs1** содержит знаковое число, а регистр **rs2** содержит беззнаковое число.

**MULHU rd, rs1, rs2** (Умножение, старшие биты, беззнаковое) возвращает старшие 32 бита произведения регистра **rs1** и регистра **rs2**, предполагая, что оба являются беззнаковыми числами.

Руководство по набору команд RISC-V не указывает результат, возвращаемый в случае переполнения, которое происходит только при использовании знаковых операндов, когда оба являются отрицательными числами.

В отличие от случая умножения, инструкции деления целых чисел допускают только операнды одного и того же типа. Но полное деление 32-битного числа на 32-битное также требует двух инструкций для получения полного результата, который состоит из частного и остатка.

**DIV rd, rs1, rs2** (Деление) возвращает 32-битное частное при делении регистра **rs1** (делимого) на регистр **rs2** (делитель), рассматривая оба как знаковые числа.

**DIVU rd, rs1, rs2** (Деление беззнаковое) возвращает 32-битное частное при делении регистра **rs1** на регистр **rs2**, рассматривая оба как беззнаковые числа.

**REM rd, rs1, rs2** (Остаток) возвращает 32-битный остаток при делении регистра **rs1** на регистр **rs2**, рассматривая оба как знаковые числа.

**REMU rd, rs1, rs2** (Остаток беззнаковый) возвращает 32-битный остаток при делении регистра **rs1** на регистр **rs2**, рассматривая оба как беззнаковые числа.

Руководство по набору команд RISC-V указывает, что эти инструкции деления округляют результат в сторону нуля и возвращают результаты, показанные в таблице 10, в случае деления на 0 или переполнения.

Таблица 10: Результаты ошибок при делении

| Условие                | Делимое | Делитель | DIV   | REM   | DIVU | REMU |
|------------------------|---------|----------|-------|-------|------|------|
| Деление на 0           | x       | 0        | -1    | x     | 2³¹-1  | x   |
| Переполнение (только для знаковых чисел) | -2³¹    | -1       | -2³¹  | 0     | -    | -    |

### 1.7 Расширение атомарных инструкций

Стандартное расширение «A» для атомарных инструкций в первую очередь предназначено для поддержки многопроцессорных систем на базе RISC-V. В отличие от остальной части набора команд RISC-V, эти инструкции выполняют операции непосредственно с памятью, поэтому некоторые из них будут полезны в встраиваемых приложениях при работе с памятью, отображённой на порты ввода-вывода (memory-mapped I/O).

Все атомарные инструкции используют формат инструкции типа R, но включают два бита в коде операции (opcode), называемые **aq** и **rl**, которые задают ограничения на упорядочение для атомарных операций с памятью. Ограничения по упорядочению требуются, когда транзакции с памятью могут выполняться вне порядка, и они важны для многопроцессорных систем RISC-V, но могут быть безопасно проигнорированы в проекте, представленном здесь. 

В таблице 11 показан полный набор атомарных инструкций, при этом инструкции, которые не будут реализованы в этой работе, выделены серым цветом. Синтаксис на языке ассемблера для атомарных инструкций отличается от остального набора команд RISC-V: к этим инструкциям добавляется суффикс "**.W**" (для операндов слова, т.е. 32 бит). Не все ассемблеры поддерживают эти инструкции, и неясно, как ограничения упорядочения **aq** и **rl** должны обрабатываться в ассемблерном коде, поэтому они не указаны в таблице.

Таблица 11: Атомарные инструкции.

| Ассемблерная команда      | Опкод                                    |
|---------------------------|------------------------------------------|
| AMOADD.W rd, rs2, (rs1)    | 00000ar_ttttt_sssss_010_ddddd_0101111    |
| AMOSWAP.W rd, rs2, (rs1)   | 00001ar_ttttt_sssss_010_ddddd_0101111    |
| LR.W rd, (rs1)             | 00010ar_00000_sssss_010_ddddd_0101111    |
| SC.W rd, rs2, (rs1)        | 00011ar_ttttt_sssss_010_ddddd_0101111    |
| AMOXOR.W rd, rs2, (rs1)    | 00100ar_ttttt_sssss_010_ddddd_0101111    |
| AMOOR.W rd, rs2, (rs1)     | 01000ar_ttttt_sssss_010_ddddd_0101111    |
| AMOAND.W rd, rs2, (rs1)    | 01100ar_ttttt_sssss_010_ddddd_0101111    |
| AMOMIN.W rd, rs2, (rs1)    | 10000ar_ttttt_sssss_010_ddddd_0101111    |
| AMOMAX.W rd, rs2, (rs1)    | 10100ar_ttttt_sssss_010_ddddd_0101111    |
| AMOMINU.W rd, rs2, (rs1)   | 11000ar_ttttt_sssss_010_ddddd_0101111    |
| AMOMAXU.W rd, rs2, (rs1)   | 11100ar_ttttt_sssss_010_ddddd_0101111    |

#### 1.7.1 Инструкции атомарных операций с памятью

Инструкции атомарных операций с памятью используют содержимое регистра **rs1** в качестве адреса памяти, считывая данные из памяти и записывая их в регистр **rd**. Одновременно эти считанные данные из памяти используются вместе с содержимым регистра **rs2** в операции, которая указана инструкцией. Результат этой операции затем записывается обратно в исходное место в памяти, при этом содержимое регистра **rs2** остается неизменным. Эта операция «чтение-модификация-запись» необходима для таких задач, как семафоры и регистры ввода-вывода, которые могут изменяться между чтением и записью.

Стандартное расширение «A» для атомарных инструкций содержит только операции с шириной слова, что указывается полем «010» в битах 14-12 кода операции (opcode). Это такое же кодирование, как используется для инструкций загрузки и записи (Load и Store), которые поддерживают полный набор доступных операндов любой ширины. Как мы увидим позже при описании реализации, добавление полного набора опций ширины для инструкций атомарных операций требует очень небольших затрат.

**AMOADD.W rd, rs2, (rs1)** (Атомарное сложение с памятью) выполняет сложение содержимого ячейки памяти и содержимого регистра **rs2**.

**AMOSWAP.W rd, rs2, (rs1)** (Атомарный обмен с памятью) обменивает содержимое ячейки памяти с содержимым регистра **rs2**.

**AMOAND.W rd, rs2, (rs1)** (Атомарное И с памятью), **AMOOR.W rd, rs2, (rs1)** (Атомарное ИЛИ с памятью) и **AMOXOR.W rd, rs2, (rs1)** (Атомарное исключающее ИЛИ с памятью) выполняют соответствующую логическую операцию между содержимым памяти и содержимым регистра **rs2**.

**AMOMAX.W rd, rs2, (rs1)** (Атомарное взятие максимума с памятью) и **AMOMAXU.W rd, rs2, (rs1)** (Атомарное взятие максимума с памятью, беззнаковое) выполняют сравнение, либо со знаком, либо без знака, между содержимым памяти и содержимым регистра **rs2**. Большее из двух значений (с учетом знака или без него) записывается обратно по адресу в памяти, тогда как содержимое регистра **rs2** остается неизменным.

**AMOMIN.W rd, rs2, (rs1)** (Атомарное взятие минимума с памятью) и **AMOMINU.W rd, rs2, (rs1)** (Атомарное взятие минимума с памятью, беззнаковое) выполняют сравнение, либо со знаком, либо без знака, между содержимым памяти и содержимым регистра **rs2**. Меньшее из двух значений (с учетом знака или без него) записывается обратно по адресу в памяти, тогда как содержимое регистра **rs2** остается неизменным.

#### 1.7.2 Инструкции Load-Reserved / Store-Conditional

Инструкции Load-Reserved (LR) и Store-Conditional (SC) позволяют создавать сложные атомарные операции с памятью, с возможностью выполнения последовательности инструкций между операцией резервирования и условной записью. Такой тип сложных атомарных операций с памятью используется для создания неблокирующих (lock-free) структур данных, в первую очередь в многопроцессорных системах.

**LR.W rd, (rs1)** (Загрузка слова с резервированием) использует адрес, содержащийся в регистре **rs1**, чтобы считать данные из памяти и загрузить их в регистр **rd**. Одновременно этот адрес памяти помечается как зарезервированный на уровне аппаратуры. Этот статус резервирования требует хранения адреса в аппаратных средствах, чтобы предотвратить доступ к зарезервированному адресу из других процессоров. Данный статус будет оставаться активным до тех пор, пока соответствующая инструкция SC.W не сбросит резервирование. 

**SC.W rd, rs2, (rs1)** (Условная запись слова) записывает содержимое регистра **rs2** по адресу в памяти, заданному содержимым регистра **rs1**, но только если на этот адрес существует действительное резервирование. При этом результат успешности или неудачи данной операции записи отражается в регистре **rd**. Если запись прошла успешно, в **rd** записывается ноль; в противном случае записывается код ошибки. В настоящий момент Руководство по набору инструкций RISC-V указывает значение 1 как код ошибки при неудаче и резервирует все остальные ненулевые значения кода ошибки для возможного использования в будущем.

### 1.8 Расширение для одинарной точности с плавающей запятой

Стандартное расширение «F» для работы с числами с плавающей запятой одинарной точности добавляет двадцать шесть инструкций, которые реализуют арифметический стандарт IEEE-754-2008 с использованием формата чисел с плавающей запятой binary32. Как уже упоминалось ранее, это расширение также добавляет 32 регистра с плавающей запятой шириной 32 бита, а также один 32-битный CSR (специальный регистр управления) в архитектуру RISC-V. Для этого требуется новый формат инструкции, поскольку инструкции умножения-сложения слиянием (fused multiply-add) требуют указания четырёх адресов регистров вместо обычных трёх. В таблице 12 приведён полный набор инструкций для работы с числами с плавающей запятой одинарной точности.

Таблица 12: Инструкции с плавающей запятой одинарной точности

| Ассемблерная команда    | Опкод                                      |
|-------------------------|--------------------------------------------|
| FLW rd, offset(rs1)     | mmmmmmm_mmmmm_sssss_010_ddddd_0000111     |
| FSW rs2, offset(rs1)    | mmmmmmm_ttttt_sssss_010_mmmmm_0100111     |
| FMADD.S rd, rs1, rs2, rs3 | vvvvv00_ttttt_sssss_rnd_ddddd_1000011     |
| FMSUB.S rd, rs1, rs2, rs3 | vvvvv00_ttttt_sssss_rnd_ddddd_1000111     |
| FNMSUB.S rd, rs1, rs2, rs3 | vvvvv00_ttttt_sssss_rnd_ddddd_1001011     |
| FNMADD.S rd, rs1, rs2, rs3 | vvvvv00_ttttt_sssss_rnd_ddddd_1001111     |
| FADD.S rd, rs1, rs2      | 0000000_ttttt_sssss_rnd_ddddd_1010011     |
| FSUB.S rd, rs1, rs2      | 0000100_ttttt_sssss_rnd_ddddd_1010011     |
| FMUL.S rd, rs1, rs2      | 0001000_ttttt_sssss_rnd_ddddd_1010011     |
| FDIV.S rd, rs1, rs2      | 0001100_ttttt_sssss_rnd_ddddd_1010011     |
| FMIN.S rd, rs1, rs2      | 0010100_ttttt_sssss_000_ddddd_1010011     |
| FMAX.S rd, rs1, rs2      | 0010100_ttttt_sssss_001_ddddd_1010011     |
| FSQRT.S rd, rs1         | 0101100_00000_sssss_rnd_ddddd_1010011     |
| FSGNJ.S rd, rs1, rs2     | 0010000_ttttt_sssss_000_ddddd_1010011     |
| FSGNJN.S rd, rs1, rs2    | 0010000_ttttt_sssss_001_ddddd_1010011     |
| FSGNJX.S rd, rs1, rs2    | 0010000_ttttt_sssss_010_ddddd_1010011     |
| FCVT.W.S rd, rs1        | 1100000_00000_sssss_rnd_ddddd_1010111     |
| FCVT.WU.S rd, rs1       | 1100000_00001_sssss_rnd_ddddd_1010011     |
| FCVT.S.W rd, rs1        | 1101000_00000_sssss_rnd_ddddd_1010011     |
| FCVT.S.WU rd, rs1       | 1101000_00001_sssss_rnd_ddddd_1010011     |
| FEQ.S rd, rs1, rs2      | 1010000_ttttt_sssss_010_ddddd_1010011     |
| FLT.S rd, rs1, rs2      | 1010000_ttttt_sssss_001_ddddd_1010011     |
| FLE.S rd, rs1, rs2      | 1010000_ttttt_sssss_000_ddddd_1010011     |
| FCLASS.S rd, rs1        | 1110000_00000_sssss_001_ddddd_1010011     |
| FMV.X.W rd, rs1         | 1110000_00000_sssss_000_ddddd_1010011     |
| FMV.W.X rd, rs1         | 1111000_00000_sssss_000_ddddd_1010011     |

За исключением различных инструкций преобразования, инструкции для чисел с плавающей запятой являются общими для разных форматов с плавающей запятой, при этом ширина указывается как поле в коде операции (opcode) и обычно отображается как суффикс в мнемонике инструкции. Суффикс «S» обозначает одинарную точность (single precision).

#### 1.8.1 Инструкции загрузки и записи с плавающей запятой одинарной точности

Инструкции загрузки и записи чисел с плавающей запятой одинарной точности используют обычный режим адресации база+смещение (base+offset) архитектуры RISC-V, где базовый адрес хранится в целочисленном регистре. Данные передаются из регистра с плавающей запятой или в него и состоят из одного 32-битного слова.

**FLW rd, offset(rs1)** (Загрузка слова с плавающей запятой) загружает одно слово из памяти в регистр с плавающей запятой **rd**.

**FSW rs2, offset(rs1)** (Запись слова с плавающей запятой) записывает содержимое регистра с плавающей запятой **rs2** в память.

#### 1.8.2 Инструкции вычислений с плавающей запятой одинарной точности

Инструкции вычислений одинарной точности используют исключительно регистровый файл с плавающей запятой.

**FADD.S rd, rs1, rs2** (Сложение с плавающей запятой) складывает содержимое регистра **rs1** и регистра **rs2** и сохраняет результат в регистр **rd**.

**FSUB.S rd, rs1, rs2** (Вычитание с плавающей запятой) вычитает **rs2** из **rs1** и сохраняет результат в **rd**.

**FMUL.S rd, rs1, rs2** (Умножение с плавающей запятой) умножает **rs1** на **rs2** и сохраняет результат в **rd**.

**FDIV.S rd, rs1, rs2** (Деление с плавающей запятой) делит **rs1** на **rs2** и сохраняет результат в **rd**.

**FSQRT.S rd, rs1** (Квадратный корень с плавающей запятой) вычисляет квадратный корень из **rs1** и сохраняет результат в **rd**.

**FMIN.S rd, rs1, rs2** (Минимум с плавающей запятой) сравнивает **rs1** и **rs2** и сохраняет меньшее из них в **rd**.

**FMAX.S rd, rs1, rs2** (Максимум с плавающей запятой) сравнивает **rs1** и **rs2** и сохраняет большее из них в **rd**.

Инструкции слияния умножения и сложения (fused multiply-add) одинарной точности принимают три операнда, что требует нового формата кода операции. Эти четыре инструкции охватывают все четыре возможные комбинации сложения и вычитания между умножением и сложением:

**FMADD.S rd, rs1, rs2, rs3** (Слитое умножение-сложение с плавающей запятой) умножает **rs1** на **rs2**, прибавляет **rs3** и сохраняет результат в **rd**.

**FMSUB.S rd, rs1, rs2, rs3** (Слитое умножение-вычитание с плавающей запятой) умножает **rs1** на **rs2**, вычитает **rs3** и сохраняет результат в **rd**.

**FNMADD.S rd, rs1, rs2, rs3** (Слитое умножение-отрицание-сложение с плавающей запятой) умножает **rs1** на **rs2**, инвертирует знак произведения, прибавляет **rs3** и сохраняет результат в **rd**.

**FNMSUB.S rd, rs1, rs2, rs3** (Слитое умножение-отрицание-вычитание с плавающей запятой) умножает **rs1** на **rs2**, инвертирует знак произведения, вычитает **rs3** и сохраняет результат в **rd**.

#### 1.8.3 Инструкции внедрения знака для чисел с плавающей запятой одинарной точности

Инструкции внедрения знака одинарной точности также используют исключительно регистровый файл с плавающей запятой. Эти инструкции изменяют только бит знака мантиссы (целое число фиксированной длины, которое представляет старшие разряды действительного числа) числа с плавающей запятой, оставляя остальные биты без изменений.

**FSGNJ.S rd, rs1, rs2** (Внедрение знака с плавающей запятой) заменяет бит знака в **rs1** битом знака из **rs2** и сохраняет результат в **rd**.

**FSGNJN.S rd, rs1, rs2** (Внедрение обратного знака с плавающей запятой) заменяет бит знака в **rs1** на дополнение бита знака из **rs2** и сохраняет результат в **rd**.

**FSGNJX.S rd, rs1, rs2** (Внедрение знака по XOR с плавающей запятой) заменяет бит знака в **rs1** на результат XOR этого бита и бита знака из **rs2**, и сохраняет результат в **rd**.

На основе этих инструкций создаются три псевдоинструкции:

- **FMV.S rd, rs** (Копирование регистра с плавающей запятой) — это **FSGNJ.S rd, rs, rs**.

- **FNEG.S rd, rs** (Инверсия знака с плавающей запятой) — это **FSGNJN.S rd, rs, rs**.

- **FABS.S rd, rs** (Модуль с плавающей запятой) — это **FSGNJX.S rd, rs, rs**.

#### 1.8.4 Инструкции преобразования чисел с плавающей запятой одинарной точности

Инструкции преобразования одинарной точности преобразуют между целыми значениями в целочисленных регистрах и числами с плавающей запятой в регистрах с плавающей запятой, и наоборот. Диапазоны значений для целых чисел и чисел с плавающей запятой различаются, и руководство по набору инструкций RISC-V описывает множество граничных случаев.

**FCVT.W.S rd, rs1** (Преобразование из одинарной точности в знаковое слово) преобразует число с плавающей запятой из регистра **rs1** в знаковое целое число и записывает в **rd**.

**FCVT.WU.S rd, rs1** (Преобразование из одинарной точности в беззнаковое слово) преобразует число с плавающей запятой из **rs1** в беззнаковое целое число и записывает в **rd**.

**FCVT.S.W rd, rs1** (Преобразование из слова в число с плавающей запятой одинарной точности) преобразует знаковое целое число из **rs1** в число с плавающей запятой и записывает в **rd**.

**FCVT.S.WU rd, rs1** (Преобразование из беззнакового слова в число с плавающей запятой одинарной точности) преобразует беззнаковое целое число из **rs1** в число с плавающей запятой и записывает в **rd**.

#### 1.8.5 Инструкции сравнения чисел с плавающей запятой одинарной точности

Инструкции сравнения чисел с плавающей запятой одинарной точности работают аналогично инструкциям сравнения целых чисел, за исключением того, что сравниваются регистры с плавающей запятой. Результат возвращается в целочисленный регистр **rd**.

**FEQ.S rd, rs1, rs2** (Сравнение на равенство с плавающей запятой) устанавливает целочисленный регистр **rd** в 0x1, если сравнение (**rs1 = rs2**) истинно, и в 0x0 в противном случае.

**FLT.S rd, rs1, rs2** (Сравнение на меньше с плавающей запятой) устанавливает rd в 0x1, если сравнение (**rs1 < rs2**) истинно, и в 0x0 в противном случае.

**FLE.S rd, rs1, rs2** (Сравнение на меньше или равно с плавающей запятой) устанавливает **rd** в 0x1, если сравнение (**rs1 ≤ rs2**) истинно, и в 0x0 в противном случае.

#### 1.8.6 Инструкции классификации чисел с плавающей запятой одинарной точности

**FCLASS.S rd, rs1** (Классификация числа с плавающей запятой) проверяет содержимое регистра с плавающей запятой **rs1** и записывает статусную информацию в целочисленный регистр **rd**. Статус состоит из десяти битов, из которых будет установлен только один, в младших разрядах регистра **rd**. Все остальные биты регистра **rd** будут сброшены.

#### 1.8.7 Инструкции перемещения чисел с плавающей запятой одинарной точности

**FMV.W.X rd, rs1** (Перемещение слова с плавающей запятой из целого) перемещает содержимое целочисленного регистра **rs1** в регистр с плавающей запятой **rd**. Если регистр с плавающей запятой шире 32 бит, то передаются только младшие 32 бита.

**FMV.X.W rd, rs1** (Перемещение слова с плавающей запятой в целое) перемещает содержимое регистра с плавающей запятой **rs1** в целочисленный регистр **rd**.

### 1.9 Расширение двойной точности для чисел с плавающей запятой

Стандартное расширение «D» для чисел с плавающей запятой двойной точности добавляет двадцать шесть инструкций, которые реализуют арифметический стандарт IEEE-754-2008 с форматом числа с плавающей запятой binary64. Это расширение требует наличия расширения «F» и также требует 64-битные регистры с плавающей запятой. Специальный регистр состояния CSR, выделенный для плавающей запятой, остаётся шириной 32 бита. 64-битные регистры с плавающей запятой всё ещё могут использоваться для представления 32-битных чисел одинарной точности с применением техники, называемой NAN-boxing.

Таблица 13 показывает полный набор инструкций для чисел с плавающей запятой двойной точности. Суффикс «D» обозначает двойную точность.

Таблица 13: Инструкции для чисел с плавающей запятой двойной точности.

| Ассемблерная команда    | Опкод                                      |
|-------------------------|--------------------------------------------|
| FLD rd, offset(rs1)     | mmmmmmm_mmmmm_sssss_011_ddddd_0000111     |
| FSD rs2, offset(rs1)    | mmmmmmm_ttttt_sssss_011_mmmmm_0100111     |
| FMADD.D rd, rs1, rs2, rs3 | vvvvv01_ttttt_sssss_rnd_ddddd_1000011     |
| FMSUB.D rd, rs1, rs2, rs3 | vvvvv01_ttttt_sssss_rnd_ddddd_1000111     |
| FNMSUB.D rd, rs1, rs2, rs3 | vvvvv01_ttttt_sssss_rnd_ddddd_1001011     |
| FNMADD.D rd, rs1, rs2, rs3 | vvvvv01_ttttt_sssss_rnd_ddddd_1001111     |
| FADD.D rd, rs1, rs2      | 0000001_ttttt_sssss_rnd_ddddd_1010011     |
| FSUB.D rd, rs1, rs2      | 0000101_ttttt_sssss_rnd_ddddd_1010011     |
| FMUL.D rd, rs1, rs2      | 0001001_ttttt_sssss_rnd_ddddd_1010011     |
| FDIV.D rd, rs1, rs2      | 0001101_ttttt_sssss_rnd_ddddd_1010011     |
| FSQRT.D rd, rs1         | 0101101_00000_sssss_rnd_ddddd_1010011     |
| FMIN.D rd, rs1, rs2      | 0010101_ttttt_sssss_000_ddddd_1010011     |
| FMAX.D rd, rs1, rs2      | 0010101_ttttt_sssss_001_ddddd_1010011     |
| FSGNJ.D rd, rs1, rs2     | 0010001_ttttt_sssss_000_ddddd_1010011     |
| FSGNJN.D rd, rs1, rs2    | 0010001_ttttt_sssss_001_ddddd_1010011     |
| FSGNJX.D rd, rs1, rs2    | 0010001_ttttt_sssss_010_ddddd_1010011     |
| FCVT.W.D rd, rs1        | 1100001_00000_sssss_rnd_ddddd_1010011     |
| FCVT.WU.D rd, rs1       | 1100001_00001_sssss_rnd_ddddd_1010011     |
| FCVT.D.W rd, rs1        | 1101001_00000_sssss_rnd_ddddd_1010011     |
| FCVT.D.WU rd, rs1       | 1101001_00001_sssss_rnd_ddddd_1010011     |
| FCVT.S.D rd, rs1        | 0100000_00001_sssss_rnd_ddddd_1010111     |
| FCVT.D.S rd, rs1        | 0100001_00000_sssss_rnd_ddddd_1010011     |
| FEQ.D rd, rs1, rs2      | 1010001_ttttt_sssss_010_ddddd_1010011     |
| FLT.D rd, rs1, rs2      | 1010001_ttttt_sssss_001_ddddd_1010011     |
| FLE.D rd, rs1, rs2      | 1010001_ttttt_sssss_000_ddddd_1010011     |
| FCLASS.D rd, rs1        | 1110001_00000_sssss_001_ddddd_1010011     |

#### 1.9.1 Инструкции загрузки и сохранения чисел с плавающей запятой двойной точности

Инструкции загрузки и сохранения чисел с плавающей запятой двойной точности используют стандартный режим адресации RISC-V типа «база + смещение», где базовый адрес хранится в целочисленном регистре. Данные передаются в регистр с плавающей запятой или из него и состоят из двух 32-битных слов.

**FLD rd, offset(rs1)** (Загрузка числа с плавающей запятой двойной точности) загружает два слова из памяти в регистр с плавающей запятой **rd**.

**FSD rs2, offset(rs1)** (Сохранение числа с плавающей запятой двойной точности) сохраняет содержимое регистра с плавающей запятой **rs2** в память.

#### 1.9.2 Инструкции вычислений с числами с плавающей запятой двойной точности

Инструкции вычислений для чисел с плавающей запятой двойной точности используют исключительно регистровый файл чисел с плавающей запятой. Эта группа инструкций идентична соответствующей группе инструкций для чисел одинарной точности.

**FADD.D rd, rs1, rs2** (Сложение чисел с плавающей запятой двойной точности) складывает регистр **rs1** с регистром **rs2** и сохраняет результат в **rd**.

**FSUB.D rd, rs1, rs2** (Вычитание чисел с плавающей запятой двойной точности) вычитает регистр **rs2** из регистра **rs1** и сохраняет результат в **rd**.

**FMUL.D rd, rs1, rs2** (Умножение чисел с плавающей запятой двойной точности) умножает регистр **rs1** на регистр **rs2** и сохраняет результат в **rd**.

**FDIV.D rd, rs1, rs2** (Деление чисел с плавающей запятой двойной точности) делит регистр **rs1** на регистр **rs2** и сохраняет результат в **rd**.

**FSQRT.D rd, rs1** (Квадратный корень числа с плавающей запятой двойной точности) вычисляет квадратный корень из регистра **rs1** и сохраняет результат в **rd**.

**FMIN.D rd, rs1, rs2** (Минимум из чисел с плавающей запятой двойной точности) сравнивает регистры **rs1** и **rs2** и сохраняет в **rd** тот, который меньше.

**FMAX.D rd, rs1, rs2** (Максимум из чисел с плавающей запятой двойной точности) сравнивает регистры **rs1** и **rs2** и сохраняет в **rd** тот, который больше.

Инструкции двойной точности для объединённого умножения с последующим сложением используют три операнда, что требует нового формата кода операции. Эти четыре инструкции покрывают все возможные комбинации сложения и вычитания между операцией умножения и сложения:

- **FMADD.D rd, rs1, rs2, rs3** (Объединённое умножение-сложение с плавающей запятой двойной точности) умножает регистр **rs1** на регистр **rs2**, прибавляет регистр **rs3** и сохраняет результат в **rd**.

- **FMSUB.D rd, rs1, rs2, rs3** (Объединённое умножение-вычитание с плавающей запятой двойной точности) умножает регистр **rs1** на регистр **rs2**, вычитает регистр **rs3** и сохраняет результат в **rd**.

- **FNMADD.D rd, rs1, rs2, rs3** (Объединённое умножение-сопряжение-сложение с плавающей запятой двойной точности) умножает регистр **rs1** на регистр **rs2**, инвертирует знак произведения, прибавляет регистр **rs3** и сохраняет результат в **rd**.

- **FNMSUB.D rd, rs1, rs2, rs3** (Объединённое умножение-сопряжение-вычитание с плавающей запятой двойной точности) умножает регистр **rs1** на регистр **rs2**, инвертирует знак произведения, вычитает регистр **rs3** и сохраняет результат в **rd**.

#### 1.9.3 Инструкции внедрения знака для чисел с плавающей запятой двойной точности

Инструкции внедрения знака для чисел с плавающей запятой двойной точности также используют исключительно регистровый файл чисел с плавающей запятой. Эти инструкции изменяют только бит знака мантиссы числа с плавающей запятой, оставляя остальные биты числа без изменений. Эта группа инструкций идентична соответствующей группе инструкций для чисел одинарной точности.

**FSGNJ.D rd, rs1, rs2** (Внедрение знака, двойная точность) заменяет бит знака в регистре **rs1** на бит знака из регистра **rs2** и сохраняет результат в **rd**.

**FSGNJN.D rd, rs1, rs2** (Внедрение инвертированного знака, двойная точность) заменяет бит знака в **rs1** на дополнение бита знака из **rs2** и сохраняет результат в **rd**.

**FSGNJX.D rd, rs1, rs2** (Внедрение знака через XOR, двойная точность) заменяет бит знака в **rs1** на XOR этого бита и бита знака из **rs2**, и сохраняет результат в **rd**.

С помощью этих инструкций внедрения знака создаются три псевдоинструкции:

- **FMV.D rd, rs** (Копирование регистра с плавающей запятой, двойная точность) эквивалентно **FSGNJ.D rd, rs, rs**.

- **FNEG.D rd, rs** (Изменение знака числа с плавающей запятой, двойная точность) эквивалентно **FSGNJN.D rd, rs, rs**.

- **FABS.D rd, rs** (Абсолютное значение числа с плавающей запятой, двойная точность) эквивалентно **FSGNJX.D rd, rs, rs**.

#### 1.9.4 Инструкции преобразования для чисел с плавающей запятой двойной точности

Инструкции преобразования для чисел с плавающей запятой двойной точности выполняют преобразование между целыми значениями в целочисленном регистре и значениями с плавающей запятой в регистре с плавающей запятой, и наоборот. Диапазоны значений для целых чисел и чисел с плавающей запятой различаются.

**FCVT.W.D rd, rs1** (Преобразование числа с плавающей запятой двойной точности в слово) преобразует число с плавающей запятой из регистра **rs1** в знаковое целое число и сохраняет его в **rd**.

**FCVT.WU.D rd, rs1** (Преобразование числа с плавающей запятой двойной точности в беззнаковое слово) преобразует число с плавающей запятой из регистра **rs1** в беззнаковое целое число и сохраняет его в **rd**.

**FCVT.D.W rd, rs1** (Преобразование из слова в число с плавающей запятой двойной точности) преобразует знаковое целое число из регистра **rs1** в число с плавающей запятой двойной точности и сохраняет его в **rd**.

**FCVT.D.WU rd, rs1** (Преобразование из беззнакового слова в число с плавающей запятой двойной точности) преобразует беззнаковое целое число из регистра **rs1** в число с плавающей запятой двойной точности и сохраняет его в **rd**.

Также существуют две инструкции для преобразования между числами одинарной и двойной точности. Эти инструкции работают с парами регистров с плавающей запятой:

- **FCVT.S.D rd, rs1** (Преобразование из двойной точности в одинарную) преобразует число двойной точности из регистра **rs1** в число одинарной точности и сохраняет его в **rd**.

- **FCVT.D.S rd, rs1** (Преобразование из одинарной точности в двойную) преобразует число одинарной точности из регистра **rs1** в число двойной точности и сохраняет его в **rd**.

#### 1.9.5 Инструкции сравнения чисел с плавающей запятой двойной точности

Инструкции сравнения чисел с плавающей запятой двойной точности работают аналогично целочисленным инструкциям сравнения, за исключением того, что сравниваются регистры с плавающей запятой. Результат возвращается в целочисленном регистре **rd**. Эта группа инструкций идентична соответствующей группе для чисел одинарной точности.

- **FEQ.D rd, rs1, rs2** (Проверка на равенство, двойная точность) устанавливает регистр **rd** в 0x1, если **rs1 = rs2**, и в 0x0 в противном случае.

- **FLT.D rd, rs1, rs2** (Меньше чем, двойная точность) устанавливает регистр **rd** в 0x1, если **rs1 < rs2**, и в 0x0 в противном случае.

- **FLE.D rd, rs1, rs2** (Меньше или равно, двойная точность) устанавливает регистр **rd** в 0x1, если **rs1 ≤ rs2**, и в 0x0 в противном случае.

#### 1.9.6 Инструкции классификации чисел с плавающей запятой двойной точности

**FCLASS.D rd, rs1** (Классификация числа с плавающей запятой, двойная точность) проверяет содержимое регистра с плавающей запятой **rs1** и записывает информацию о состоянии в целочисленный регистр **rd**. Статус состоит из десяти битов, только один из которых будет установлен в наименее значащих битах регистра **rd**. Все остальные биты регистра **rd** будут сброшены.

### 1.10 Расширение для чисел с плавающей запятой четверной точности

Стандартное расширение "Q" для чисел с плавающей запятой четверной точности добавляет двадцать восемь инструкций, реализующих арифметический стандарт IEEE-754-2008 с форматом числа binary128. Это расширение требует наличия расширения "D" и также требует 128-битных регистров с плавающей запятой. Управляющий регистр (CSR), предназначенный для чисел с плавающей запятой, остаётся 32-битным. 128-битные регистры с плавающей запятой всё ещё могут использоваться для представления чисел с одинарной и двойной точностью. Таблица 14 показывает полный набор инструкций для чисел с плавающей запятой четверной точности. 

Таблица 14: Инструкции для чисел с плавающей запятой четверной точности

| Ассемблерная команда    | Опкод                                      |
|-------------------------|--------------------------------------------|
| FLQ rd, offset(rs1)     | mmmmmmm_mmmmm_sssss_100_ddddd_0000111     |
| FSQ rs2, offset(rs1)    | mmmmmmm_ttttt_sssss_100_mmmmm_0100111     |
| FMADD.Q rd, rs1, rs2, rs3 | vvvvv11_ttttt_sssss_rnd_ddddd_1000011     |
| FMSUB.Q rd, rs1, rs2, rs3 | vvvvv11_ttttt_sssss_rnd_ddddd_1000111     |
| FNMSUB.Q rd, rs1, rs2, rs3 | vvvvv11_ttttt_sssss_rnd_ddddd_1001011     |
| FNMADD.Q rd, rs1, rs2, rs3 | vvvvv11_ttttt_sssss_rnd_ddddd_1001111     |
| FADD.Q rd, rs1, rs2      | 0000011_ttttt_sssss_rnd_ddddd_1010011     |
| FSUB.Q rd, rs1, rs2      | 0000111_ttttt_sssss_rnd_ddddd_1010011     |
| FMUL.Q rd, rs1, rs2      | 0001011_ttttt_sssss_rnd_ddddd_1010011     |
| FDIV.Q rd, rs1, rs2      | 0001111_ttttt_sssss_rnd_ddddd_1010011     |
| FSQRT.Q rd, rs1         | 0101111_00000_sssss_rnd_ddddd_1010011     |
| FMIN.Q rd, rs1, rs2      | 0010111_ttttt_sssss_000_ddddd_1010011     |
| FMAX.Q rd, rs1, rs2      | 0010111_ttttt_sssss_001_ddddd_1010011     |
| FSGNJ.Q rd, rs1, rs2     | 0010011_ttttt_sssss_000_ddddd_1010011     |
| FSGNJN.Q rd, rs1, rs2    | 0010011_ttttt_sssss_001_ddddd_1010011     |
| FSGNJX.Q rd, rs1, rs2    | 0010011_ttttt_sssss_010_ddddd_1010011     |
| FCVT.W.Q rd, rs1        | 1100011_00000_sssss_rnd_ddddd_1010011     |
| FCVT.WU.Q rd, rs1       | 1100011_00001_sssss_rnd_ddddd_1010011     |
| FCVT.D.Q rd, rs1        | 1101011_00000_sssss_rnd_ddddd_1010011     |
| FCVT.Q.WU rd, rs1       | 1101011_00001_sssss_rnd_ddddd_1010011     |
| FCVT.S.Q rd, rs1        | 0100000_00011_sssss_rnd_ddddd_1010111     |
| FCVT.Q.S rd, rs1        | 0100011_00000_sssss_rnd_ddddd_1010011     |
| FCVT.D.Q rd, rs1        | 0100001_00011_sssss_rnd_ddddd_1010111     |
| FCVT.Q.D rd, rs1        | 0100011_00001_sssss_rnd_ddddd_1010011     |
| FEQ.Q rd, rs1, rs2      | 1010011_ttttt_sssss_010_ddddd_1010011     |
| FLT.Q rd, rs1, rs2      | 1010011_ttttt_sssss_001_ddddd_1010011     |
| FLE.Q rd, rs1, rs2      | 1010011_ttttt_sssss_000_ddddd_1010011     |
| FCLASS.Q rd, rs1        | 1110011_00000_sssss_001_ddddd_1010011     |

#### 1.10.1 Инструкции загрузки и сохранения чисел с плавающей запятой четверной точности

Инструкции загрузки и сохранения чисел с плавающей запятой четверной точности используют обычный режим адресации RISC-V: база + смещение, где базовый адрес хранится в целочисленном регистре. Данные передаются из или в регистр с плавающей запятой и состоят из четырёх 32-битных слов.

- **FLQ rd, offset(rs1)** (Загрузка числа четверной точности с плавающей запятой) загружает четыре слова из памяти в регистр с плавающей запятой **rd**.

- **FSQ rs2, offset(rs1)** (Сохранение числа четверной точности с плавающей запятой) сохраняет содержимое регистра с плавающей запятой **rs2** в память.

#### 1.10.2 Инструкции вычислений для чисел с плавающей запятой четверной точности

Инструкции вычислений для чисел с плавающей запятой четверной точности используют исключительно регистровый файл чисел с плавающей запятой. Эта группа инструкций идентична соответствующей группе инструкций для чисел одинарной точности.

- **FADD.Q rd, rs1, rs2** (Сложение чисел с плавающей запятой, четверная точность) складывает содержимое регистра **rs1** с содержимым регистра **rs2** и сохраняет результат в **rd**.

- **FSUB.Q rd, rs1, rs2** (Вычитание чисел с плавающей запятой, четверная точность) вычитает содержимое регистра **rs2** из регистра **rs1** и сохраняет результат в **rd**.

- **FMUL.Q rd, rs1, rs2** (Умножение чисел с плавающей запятой, четверная точность) умножает содержимое регистра **rs1** на содержимое регистра **rs2** и сохраняет результат в **rd**.

- **FDIV.Q rd, rs1, rs2** (Деление чисел с плавающей запятой, четверная точность) делит содержимое регистра **rs1** на содержимое регистра **rs2** и сохраняет результат в **rd**.

- **FSQRT.Q rd, rs1** (Извлечение квадратного корня, четверная точность) вычисляет квадратный корень из содержимого регистра **rs1** и сохраняет результат в **rd**.

- **FMIN.Q rd, rs1, rs2** (Минимум из двух чисел с плавающей запятой, четверная точность) сравнивает содержимое регистров **rs1** и **rs2** и сохраняет в **rd** меньшее из двух.

- **FMAX.Q rd, rs1, rs2** (Максимум из двух чисел с плавающей запятой, четверная точность) сравнивает содержимое регистров **rs1** и **rs2** и сохраняет в **rd** большее из двух.

Инструкции умножения с накоплением (fused multiply-add) для чисел с плавающей запятой четверной точности принимают три операнда, что требует нового формата кода операции. Четыре инструкции охватывают все возможные комбинации сложения и вычитания между операциями умножения и сложения.

**FMADD.Q rd, rs1, rs2, rs3** (Умножение с накоплением, четверная точность) умножает содержимое регистра **rs1** на содержимое регистра **rs2**, прибавляет содержимое регистра **rs3** и сохраняет результат в **rd**.

**FMSUB.Q rd, rs1, rs2, rs3** (Умножение с вычитанием, четверная точность) умножает содержимое регистра **rs1** на содержимое регистра **rs2**, вычитает содержимое регистра **rs3** и сохраняет результат в **rd**.

**FNMADD.Q rd, rs1, rs2, rs3** (Слитное умножение с отрицанием и сложением, четверная точность) умножает содержимое регистра **rs1** на содержимое регистра **rs2**, инвертирует знак произведения, прибавляет содержимое регистра **rs3** и сохраняет результат в регистр rd.

**FNMSUB.Q rd, rs1, rs2, rs3** (Слитное умножение с отрицанием и вычитанием, четверная точность) умножает содержимое регистра **rs1** на содержимое регистра **rs2**, инвертирует знак произведения, вычитает содержимое регистра **rs3** и сохраняет результат в регистр **rd**.

#### 1.10.3 Инструкции инъекции знака для чисел с плавающей запятой четверной точности

Инструкции инъекции знака для чисел с плавающей запятой четверной точности также используют исключительно регистровый файл с плавающей запятой. Эти инструкции изменяют только бит знака мантиссы числа с плавающей запятой, оставляя остальные биты без изменений. Эта группа инструкций идентична соответствующим инструкциям одинарной точности.

**FSGNJ.Q rd, rs1, rs2** (Инъекция знака, четверная точность) заменяет бит знака в регистре **rs1** битом знака из регистра **rs2** и сохраняет результат в регистр **rd**.

**FSGNJN.Q rd, rs1, rs2** (Инъекция знака с инверсией, четверная точность) заменяет бит знака в регистре **rs1** на противоположный биту знака регистра **rs2** и сохраняет результат в rd.

**FSGNJX.Q rd, rs1, rs2** (Инъекция знака через XOR, четверная точность) заменяет бит знака в **rs1** результатом XOR этого бита и бита знака из **rs2**, сохраняя результат в **rd**.

С использованием этих инструкций инъекции знака созданы три псевдоинструкции:

- **FMV.Q rd, rs** (Копирование регистра с плавающей запятой, четверная точность) эквивалентно **FSGNJ.Q rd, rs, rs**;

- **FNEG.Q rd, rs** (Изменение знака числа с плавающей запятой, четверная точность) эквивалентно **FSGNJN.Q rd, rs, rs**;

- **FABS.Q rd, rs** (Модуль числа с плавающей запятой, четверная точность) эквивалентно **FSGNJX.Q rd, rs, rs**.

#### 1.10.4 Инструкции преобразования чисел с плавающей запятой четверной точности

Инструкции преобразования для чисел с плавающей запятой четверной точности выполняют преобразование между целыми значениями в целочисленных регистрах и числами с плавающей запятой в регистрах с плавающей запятой, и наоборот. Диапазоны значений для целых чисел и чисел с плавающей запятой различаются.

**FCVT.W.Q rd, rs1** (Преобразование из четверной точности в знаковое слово) преобразует число с плавающей запятой из регистра **rs1** в знаковое целое число в регистре **rd**.

**FCVT.WU.Q rd, rs1** (Преобразование из четверной точности в беззнаковое слово) преобразует число с плавающей запятой из регистра **rs1** в беззнаковое целое число в **rd**.

**FCVT.Q.W rd, rs1** (Преобразование из слова в четверную точность) преобразует знаковое целое число из регистра **rs1** в число с плавающей запятой в регистре **rd**.

**FCVT.Q.WU rd, rs1** (Преобразование из беззнакового слова в четверную точность) преобразует беззнаковое целое число из регистра **rs1** в число с плавающей запятой в **rd**.

Также существуют четыре инструкции для преобразования между одинарной, двойной и четверной точностью. Эти инструкции работают с парами регистров с плавающей запятой:

- **FCVT.S.Q rd, rs1** (Преобразование из четверной точности в одинарную) преобразует число четверной точности из регистра **rs1** в число одинарной точности в **rd**.

- **FCVT.Q.S rd, rs1** (Преобразование из одинарной точности в четверную) преобразует число одинарной точности из регистра **rs1** в число четверной точности в **rd**.

- **FCVT.D.Q rd, rs1** (Преобразование из четверной точности в двойную) преобразует число четверной точности из регистра **rs1** в число двойной точности в rd.

- **FCVT.Q.D rd, rs1** (Преобразование из двойной точности в четверную) преобразует число двойной точности из регистра **rs1** в число четверной точности в **rd**.

#### 1.10.5 Инструкции сравнения чисел с плавающей запятой четверной точности

Инструкции сравнения чисел с плавающей запятой четверной точности работают аналогично инструкциям сравнения целых чисел, за исключением того, что сравниваются регистры с плавающей запятой. Результат записывается в целочисленный регистр **rd**. Эта группа инструкций идентична инструкциям для чисел одинарной точности.

**FEQ.Q rd, rs1, rs2** (Проверка на равенство, четверная точность) устанавливает **rd** в 0x1, если **rs1** равно **rs2**, иначе устанавливает в 0x0.

**FLT.Q rd, rs1, rs2** (Меньше чем, четверная точность) устанавливает **rd** в 0x1, если **rs1** меньше **rs2**, иначе 0x0.

**FLE.Q rd, rs1, rs2** (Меньше либо равно, четверная точность) устанавливает **rd** в 0x1, если **rs1** меньше или равно **rs2**, иначе 0x0.

#### 1.10.6 Инструкция классификации чисел с плавающей запятой четверной точности

**FCLASS.Q rd, rs1** (Классификация числа, четверная точность) проверяет содержимое регистра с плавающей запятой **rs1** и записывает информацию о статусе в целочисленный регистр **rd**. Статус состоит из десяти битов, при этом только один из них будет установлен в младших разрядах регистра **rd**, а все остальные биты будут сброшены в 0.

### 1.11 Расширение для сжатых инструкций (16-битные опкоды)

Кодирование базового набора целочисленных инструкций довольно неэффективно, используя менее чем 228 из 232 возможных опкодов. Фактически, руководство по RISC-V отмечает, что кэш-память должна быть только 30 бит шириной при хранении обычных инструкций RISC-V, потому что два младших бита опкода всегда равны 11.

Оставшиеся три комбинации двух младших битов используются для обозначения 16-битных опкодов. Стандартное расширение для сжатых инструкций, называемое RISC-V Compressed (RVC), официально утверждено. Для 32-битного набора команд RISC-V это расширение называется RV32C и включает 35 инструкций, из которых восемь посвящены операциям с плавающей запятой. Целочисленные инструкции RV32C покрывают наиболее часто используемые команды из набора RV32I.

Инструкции RVC были выбраны на основе анализа тестов производительности SPEC 2006, ориентированных больше на ПК и серверные системы, что отражено в составе инструкций в RVC. Бенчмарк, ориентированный на встроенные системы, мог бы привести к другому составу инструкций.

Большинство инструкций RVC накладывают ограничения на доступные регистры. Поля выбора регистров rd’, rs1’ и rs2’ в инструкциях RVC кодируются, как показано в таблице 15. Во всех случаях, если есть регистр назначения, он также используется как один из исходных регистров, и чаще всего доступны только восемь из 32 обычных регистров RISC-V — это регистры x8 до x15 (или f8 до f15 для чисел с плавающей запятой), хотя некоторые инструкции специально используют x2 как указатель стека по умолчанию.

Таблица 15: Сжатые адреса и имена регистров.

| RV32I rd, rs1, rs2 | RVC rd', rs1', rs2' | Номер регистра | ABI имя регистра | Описание регистра             |
|--------------------|---------------------|----------------|------------------|-------------------------------|
| 01000              | 000                 | x8             | s0/fp            | Сохраняемый регистр/указатель кадра |
| 01001              | 001                 | x9             | s1               | Сохраняемый регистр           |
| 01010              | 010                 | x10            | a0               | Значение возврата функции     |
| 01011              | 011                 | x11            | a1               | Значение возврата функции     |
| 01100              | 100                 | x12            | a2               | Аргумент функции              |
| 01101              | 101                 | x13            | a3               | Аргумент функции              |
| 01110              | 110                 | x14            | a4               | Аргумент функции              |
| 01111              | 111                 | x15            | a5               | Аргумент функции              |


Девять различных форматов опкодов, используемых в RVC, показаны на рисунке 3. Метки, используемые на этом рисунке, совпадают с теми, что применяются в изначальной схеме формата опкодов, за исключением того, что rd’, rs1’ и rs2’ относятся к сокращённому набору регистров.

![RVC_Opcode_formats](/theory/birisc_v%20description/Images/RVC_Opcode_formats.png)

Рисунок 3: Форматы опкодов RVC

Каждая инструкция RVC однозначно отображается на существующую инструкцию RISC-V, что значительно упрощает трансляцию в полноценную 32-битную инструкцию. Выбор регистров x8–x15 для сокращённого набора также уменьшает сложность преобразования, так как кодировка регистра напрямую сопоставляется между 16-битным и 32-битным опкодом.

Как и в базовом наборе инструкций, существует ряд комбинаций операндов, которые приведут к отсутствию операции (no-op), и многие из таких комбинаций зарезервированы как HINT'ы (подсказки). В то же время, некоторые комбинации операндов определены как недопустимые и должны вызывать исключение Illegal Instruction (недопустимая инструкция). Это усложняет трансляцию из 16-битного опкода в 32-битный, как мы увидим позже при реализации архитектуры.
Опкод 32-битной недопустимой инструкции (Defined Illegal opcode) окажется полезным при трансляции, когда необходимо сгенерировать исключение Illegal Instruction.

Таблица 16 показывает инструкции RV32C с указанием опкода, возможных ограничений и формата инструкции. Эта таблица организована по квадрантам, где квадрант определяется комбинацией двух младших битов опкода. Перечисленные ограничения важны, поскольку при их нарушении обязательно должно генерироваться исключение Illegal Instruction.

Таблица 16: Сжатые (16-битные) инструкции.

| Ассемблерная команда         | Опкод                     | Ограничения      | Тип  |
|-----------------------------|---------------------------|------------------|------|
| Defined Illegal             | 000_000_000_00_000_00     |                  | CIW     |
| C.ADDI4SPN rd', nzimm       | 000_mmm_mmm_mm_ddd_00     | nzimm ≠ 0        | CIW  |
| C.FLD rd', uoffset(rs1')    | 001_mmm_sss_mm_ddd_00     |                  | CL   |
| C.LW rd', uoffset(rs1')     | 010_mmm_sss_mm_ddd_00     |                  | CL   |
| C.FLW rd', uoffset(rs1')    | 011_mmm_sss_mm_ddd_00     |                  | CL   |
| C.FSD rs2', uoffset(rs1')   | 101_mmm_sss_mm_ttt_00     |                  | CS   |
| C.SW rs2', uoffset(rs1')    | 110_mmm_sss_mm_ttt_00     |                  | CS   |
| C.FSW rs2', uoffset(rs1')   | 111_mmm_sss_mm_ttt_00     |                  | CS   |
| C.NOP                       | 000_0_00000_mmmmm_01      | imm = 0          | CI   |
| C.ADDI rd, nzimm            | 000_m_ddddd_nnnnnn_01     | nzimm ≠ 0        | CI   |
| C.JAL offset                | 001_nnnnnnnnnnnn_01       |                  | CI   |
| C.LI rd, imm                | 010_m_ddddd_mmmmm_01      |                  | CI   |
| C.ADDI16SP nzimm            | 011_000010_nnnnnn_01      | nzimm ≠ 0        | CI   |
| C.LUI rd, nzimm             | 011_m_dd2dd_nnnnnn_01     | nzimm ≠ 0        | CI   |
| C.SRLI rd', shamt           | 100_0_00_ddd_shamt_01     |                  | CI   |
| C.SRAI rd', shamt           | 100_0_01_ddd_shamt_01     |                  | CI   |
| C.ANDI rd', imm             | 100_1_10_ddd_mmmmm_01     |                  | CI   |
| C.SUB rd', rs2'             | 100_011_ddd_00_ttt_01     |                  | CA   |
| C.XOR rd', rs2'             | 100_011_ddd_01_ttt_01     |                  | CA   |
| C.OR rd', rs2'              | 100_011_ddd_10_ttt_01     |                  | CA   |
| C.AND rd', rs2'             | 100_011_ddd_11_ttt_01     |                  | CA   |
| C.J offset                  | 101_nnnnnnnnnnnn_01       |                  | CJ   |
| C.BEQZ rs1', offset         | 110_mmm_sss_mmmmm_01      |                  | CB   |
| C.BNEZ rs1', offset         | 111_mmm_sss_mmmmm_01      |                  | CB   |
| C.SLLI rd', shamt           | 000_0_ddddd_shamt_10      |                  | CI   |
| C.FLDSP rd, uoffset         | 001_m_ddddd_mmmmm_10      |                  | CI   |
| C.LWSP rd, uoffset          | 010_m_ddddd_mmmmm_10      |                  | CI   |
| C.FLWSP rd, uoffset         | 011_m_ddddd_mmmmm_10      |                  | CI   |
| C.JR rs1                    | 100_0_sssss_00000_10      |                  | CR   |
| C.MV rd, rs2                | 100_0_ddddd_tnttt_10      |                  | CR   |
| C.EBREAK                    | 100_1_00000_00000_10      |                  | CR   |
| C.JALR rs1                  | 100_1_sssss_00000_10      |                  | CR   |
| C.ADD rd, rs2               | 100_1_ddddd_tnttt_10      |                  | CR   |
| C.FSDSP rs2, uoffset        | 101_m_ttttt_mmmmm_10      |                  | CSS  |
| C.SWSP rs2, uoffset         | 110_m_ttttt_mmmmm_10      |                  | CSS  |
| C.FSWSP rs2, uoffset        | 111_m_ttttt_mmmmm_10      |                  | CSS  |

Как и в базовом наборе инструкций, непосредственные данные (immediate) перемешаны внутри опкода, чтобы упростить логику декодирования. С учётом увеличенного количества форматов опкодов, в RVC появляется ещё больше уникальных случаев, и Таблица 17 показывает эти различные варианты. Тот факт, что эта архитектура не включает поддержку плавающей запятой, сокращает число случаев, которые нужно обрабатывать, все они приведены в таблице для полноты.
Таблица 17: Позиции битов непосредственных данных в сжатых инструкциях.

| Формат   | Инструкции                | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 |
|----------|---------------------------|----|----|----|---|---|---|---|---|---|---|---|
| CI-тип   | все, кроме:               | 5  |    |    |   |   |  | 4 | 3 | 2  | 1  | 0  |
| CI-тип          | Сдвиги                    |    |    |    |   |   |  | 4 | 3 | 2  | 1  | 0  |
| CI-тип          | Stack-based               | 5  |    |    |   | |  | 4 | 3 | 2 | 7 | 6 |
|  CI-тип         | **C.FLDSP**               | 5  |    |    |   |  | |4 | 3 | 8 | 7 | 6 |  |
|  CI-тип         | **C.ADDI16SP**            | 9  |    |    |   |  | |4 | 6 | 8 | 7 | 5 |  |
|  CI-тип         | **C.LUI**                 | 17 |    |    |   |     | | 16|15 |14 |13 | 12|
| CSS-тип  | все, кроме:               | 5  | 4  | 3  | 2 | 7 | 6 |   |   |   |   |   |
| CSS-тип         | **C.FSDSP**               | 5  | 4  | 3  | 8 | 7 | 6 |   |   |   |   |   |
| CIW-тип  | все             | 5  | 4  | 9 | 8 | 7 | 6 | 2  | 3  |   |   |   |
| CL-тип   | все, кроме:               | 5  | 4  | 3  | | |   | 2  | 6  |   |   |   |
| CL-тип         | **C.FLD**               | 5  | 4  | 3  | | |   | 7  | 6  |   |   |   |
| CS-тип   | все, кроме:              | 5  | 4  | 3  | | |   | 2  | 6  |   |   |   |
| CS-тип         | **C.FSD**                 | 5  | 4  | 3  | | |   | 7  | 6  |   |   |   |

#### 1.11.1 Сжатые инструкции целочисленной арифметики

Все инструкции целочисленной арифметики имеют 16-битные версии опкодов, хотя и с некоторыми ограничениями. Используются разные форматы инструкций. Как упоминалось ранее, во всех случаях rd’ и rs2’ ограничены диапазоном от x8 до x15.

**C.ADD rd, rs2** сопоставляется с **ADD rd, rd, rs2**, так что весь набор регистров доступен, но случай **rs2 = x0** не допускается, поскольку используется для других сжатых инструкций, что усложняет декодирование.

**C.SUB rd’, rs2’** сопоставляется с **SUB rd’, rd’, rs2’** без дополнительных ограничений на **rd’** и **rs2’**.

**C.ADDI rd, nzimm** сопоставляется с **ADDI rd, rd, nzimm**, и весь набор регистров доступен. Непосредственное значение ограничено диапазоном от –32 до +31, причём значение 0 исключено. Случай **rd = x0** разрешён и трактуется как **HINT**, но только если **nzimm** ≠ 0. Случай **rd = x0** и **nzimm** = 0 используется для кодирования инструкции **C.NOP**.

Последние две инструкции арифметики работают с регистром **x2**, который обычно используется как указатель стека (**sp**). Обе инструкции изменяют значение регистра **sp**, что часто выполняется в начале и конце каждого вызова подпрограммы и при доступе к переменным на стеке.

**C.ADDI16SP nzuimm** сопоставляется с **ADDI rd’, x2, nzuimm**, но случай **nzuimm** = 0 является недопустимым. Непосредственное значение **nzuimm** содержит биты 9–4 добавляемого значения. Непосредственное значение знаковым образом расширяется до 32 бит и имеет диапазон от –512 до +496, при этом все значения кратны 16. Стандартное соглашение вызовов в RISC-V требует, чтобы регистр **sp** всегда был выровнен по 16 байтам, именно поэтому инструкция определена таким образом. Эта инструкция использует тот же опкод, что и **C.LUI**, но с полем регистра назначения, установленным в x2.

**C.ADDI4SPN rd’, nzuimm** сопоставляется с **ADDI rd’, x2, nzuimm**, но случай **nzuimm** = 0 является недопустимым. Непосредственное значение nzuimm содержит биты 9–2 добавляемого значения. В этом случае непосредственное значение расширяется нулями до 32 бит и имеет диапазон от +4 до +1020, при этом все значения кратны 4. Эта инструкция используется для создания указателя для доступа к переменной на стеке, поэтому непосредственное значение является беззнаковым.

#### 1.11.2 Сжатые логические инструкции

Все логические инструкции регистр-регистр имеют сжатые версии, но только **ANDI** доступна в сжатом варианте для операций с непосредственными данными. Инструкция **C.XORI** была бы полезна, так как позволяла бы реализовать псевдоинструкцию **C.NOT**.

**C.AND rd’, rs2’** сопоставляется с **AND rd’, rd’, rs2’** без дополнительных ограничений на **rd’** и **rs2’**.

**C.OR rd’, rs2’** сопоставляется с **OR rd’, rd’, rs2’** без дополнительных ограничений на **rd’** и **rs2’**.

**C.XOR rd’, rs2’** сопоставляется с **XOR rd’, rd’, rs2’** без дополнительных ограничений на **rd’** и **rs2’**.

**C.ANDI rd’, imm** сопоставляется с **ANDI rd’, rd’, imm** как для сжатых, так и для расширенных инструкций.

#### 1.11.3 Сжатые инструкции сдвига

Существуют три 16-битные инструкции сдвига, которые имеют в коде операции место для шести битов непосредственных данных (иммедиата), но для значения **shamt** в RV32C требуется только пять битов. Руководство по набору инструкций RISC-V указывает, что **shamt[5]**, находящийся в бите 12 кода операции, должен быть равен нулю, а все случаи, где **shamt[5]** = 1, зарезервированы для пользовательских расширений. Это было бы логичным местом для внедрения пользовательских инструкций **C.ORI** и **C.XORI** в 16-битный набор инструкций, даже если они ограничены 5-битными непосредственными данными.

Инструкция **C.SLLI rd, shamt** отображается как **SLLI rd, rd, shamt**, так что для этой инструкции доступен полный набор регистров. Случай, когда **rd = x0**, разрешён и рассматривается как **HINT**, как и случай, когда **shamt = 0**.

Инструкция **C.SRAI rd’, shamt** отображается как **SRAI rd’, rd’, shamt**, так что только ограниченный набор регистров доступен для этой инструкции. Случай, когда **shamt = 0**, является **HINT**.

Инструкция **C.SRLI rd’, shamt** отображается как **SRLI rd’, rd’, shamt**, так что только ограниченный набор регистров доступен для этой инструкции. Случай, когда **shamt =** 0, является **HINT**.

#### 1.11.4 Сжатые инструкции генерации констант

Две 16-битные инструкции для создания констант сильно ограничены из-за числа доступных битов для непосредственных данных в коде операции. Обе инструкции почти полностью поддерживают весь набор регистров.

Инструкция **C.LI rd, imm** отображается как **ADDI rd, x0, imm**, так что весь набор регистров доступен для этой инструкции, но случай, когда **rd = x0**, рассматривается как **HINT**. Диапазон создаваемых констант составляет от –32 до +31, что немного, но лучше, чем ничего.

Инструкция **C.LUI rd, nzimm** отображается как **LUI rd, nzimm**, но случай, когда **rd = x0**, рассматривается как **HINT**, а случай, когда **rd = x2**, используется для другой инструкции. Случай, когда **nzimm = 0**, является недопустимым, и непосредственное значение **nzimm** содержит биты с 17 по 12 значения, загружаемого в регистр **rd**. Непосредственное значение расширяется по знаку до полных 32 бит.

#### 1.11.5 Сжатые безусловные инструкции перехода

Всего существует четыре 16-битные безусловные инструкции перехода, использующие два разных формата кода операции. Две инструкции используют выделенный формат инструкции типа CJ, а другие две — формат инструкции типа CR. Все эти сжатые инструкции имеют ограничения по сравнению с версиями RV32I, но при этом покрывают наиболее часто встречающиеся случаи.

Инструкция **C.J offset** (прыжок) отображается как **JAL x0, offset**, что аналогично псевдоинструкции RV32I, за исключением того, что смещение ограничено диапазоном от –2¹¹ до +2¹¹ – 2.

Инструкция **C.JAL offset** (прыжок с сохранением ссылки) отображается как **JAL x1, offset**, что также аналогично псевдоинструкции RV32I, за исключением того, что смещение ограничено диапазоном от –2¹¹ до +2¹¹ – 2. Однако есть одно отличие, связанное с длиной инструкции. **JAL** записывает PC+4 в регистр **x1**, тогда как **C.JAL** записывает PC+2 в регистр **x1**. Это различие должно естественным образом проявляться в аппаратуре, так как это просто счётчик следующей инструкции, но различия проявляются программно.

Инструкция **C.JR rs1** (прыжок по регистру) отображается как **JALR x0, 0(rs1)**, как и псевдоинструкция RV32I. Случай, когда **rs1 = x0**, является недопустимым для инструкции **C.JR**.

Инструкция **C.JALR rs1** (прыжок с сохранением ссылки по регистру) отображается как **JALR x1, 0(rs1)**, как и псевдоинструкция RV32I. Как и в случае инструкции **C.JAL**, значение, записываемое в регистр **x1**, различается между инструкциями **C.JALR** и **JALR**. Случай, когда **rs1 = x0**, является недопустимым и используется для другой сжатой инструкции.

#### 1.11.6 Сжатые условные инструкции перехода

Существует только две 16-битные условные инструкции перехода, и они соответствуют паре псевдоинструкций RV32I для сравнения с нулём. Эти инструкции используют формат инструкции типа CB, который имеет место только для восьми битов смещения. 8-битное смещение в инструкции расширяется по знаку и затем сдвигается влево на один бит, чтобы гарантировать его чётность, что даёт диапазон от –28 до +28 – 2 для этих инструкций перехода.

**C.BEQZ rs1’, offset** (Переход если равно нулю) отображается как **BEQ rs1’, x0, offset**.

**C.BNEZ rs1’, offset** (Переход если не равно нулю) отображается как **BNE rs1’, x0, offset**.

#### 1.11.7 Сжатые инструкции загрузки и записи

Существуют четыре 16-битные инструкции предназначены для загрузки и записи данных. Доступны только загрузки и записи слов (word), что, вероятно, является следствием выбора тестов (бенчмарков), использованных при создании набора инструкций RVC. Каждая инструкция из этой группы использует разный формат инструкции. Все эти инструкции используют беззнаковое смещение адреса, что является отступлением от обычных знаковых смещений адреса в RISC-V.

**C.LW rd’, uoffset(rs1’)** (Загрузка слова) отображается как **LW rd’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +28 – 4 для загрузки. Эта инструкция использует формат типа CL.

**C.SW rs2’, uoffset(rs1’)** (Запись слова) отображается как **SW rs2’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +28 – 4 для записи. Эта инструкция использует формат типа CS.

**C.LWSP rd, uoffset** (Загрузка слова относительно указателя стека) отображается как **LW rd, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +28 – 4 для загрузки. Эта инструкция использует формат типа CI. Случай, когда **rd = x0**, является недопустимым.

**C.SWSP rs2, uoffset** (Запись слова относительно указателя стека) отображается как **SW rs2, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +28 – 4 для записи. Эта инструкция использует формат типа CSS.

#### 1.11.8 Разные сжатые инструкции

Существует несколько 16-битных инструкций, которые не попадают ни в одну из других категорий, поэтому они перечислены здесь. Две из них используют особый вариант кодировки, применяемый для другой 16-битной инструкции. Кроме того, определена специальная недопустимая 16-битная кодировка для выявления любых попыток выполнения в несуществующей памяти.

**C.MV rd, rs2** отображается как **ADD rd, x0, rs2**, что означает, что весь набор регистров доступен для этой инструкции. Случай, когда **rs2 = x0**, не допускается и используется для другой сжатой инструкции. 32-битная псевдоинструкция **MV** является псевдонимом для **ADDI**, но руководство по набору инструкций RISC-V указывает, что отображение **C.MV** в **ADD** упростит реализацию.

**C.NOP** (Нет операции) отображается как **ADDI x0, x0, 0**, как и в случае RV32I. Поскольку эта инструкция использует тот же базовый код операции, что и **C.ADDI**, не требуется специального преобразования.

**C.EBREAK** (Точка останова окружения) отображается как **EBREAK**. Эта инструкция использует особый случай кода операции **C.JALR**, поэтому для неё потребуется специальная обработка в логике преобразования.

**Определённая недопустимая инструкция** — это просто 0x0000, но это особый случай инструкции **C.ADDI4SPN**, поэтому она также потребует специальной обработки в логике преобразования.

#### 1.11.9 Сжатые инструкции с плавающей точкой

Восемь 16-битных инструкций предназначены для загрузки и записи чисел с плавающей точкой. Это является прямым следствием выбора тестов, использованных при создании набора инструкций RVC. Описываемая в данной работе архитектура не включает поддержку плавающей точки, поэтому ни одна из этих инструкций не будет реализована. Вполне возможно, что эти коды операций могут быть использованы для других функций, и на самом деле половина из них уже переиспользована в RV64C, а все они исчезают в RV128C.

Две из этих инструкций поддерживают общие загрузки чисел с плавающей точкой, используя формат инструкции типа CL, с 5-битным беззнаковым смещением адреса и ограниченным набором регистров (от **x8** до **x15** и от **f8** до **f15**).

**C.FLD rd’, uoffset(rs1’)** (Загрузка двойного слова с плавающей точкой) отображается как **FLD rd’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +2⁸ – 8 для загрузки, поскольку адрес должен быть выровнен по границе двойного слова.

**C.FLW rd’, uoffset(rs1’)** (Загрузка слова с плавающей точкой) отображается как **FLW rd’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +2⁸ – 4 для загрузки, поскольку адрес должен быть выровнен по границе слова.

Две из этих инструкций поддерживают общие записи чисел с плавающей точкой, используя формат инструкции типа CS, также с 5-битным беззнаковым смещением и ограниченным набором регистров.

**C.FSD rs2’, uoffset(rs1’)** (Запись двойного слова с плавающей точкой) отображается как **FSD rs2’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +2⁸ – 8 для записи.

**C.FSW rs2’, uoffset(rs1’)** (Запись слова с плавающей точкой) отображается как **FSW rs2’, uoffset(rs1’)**. Пять битов беззнакового смещения используют диапазон от +0 до +2⁸ – 4 для записи.

Две из этих инструкций поддерживают загрузки с плавающей точкой относительно указателя стека, используя формат инструкции типа CI.

**C.FLDSP rd, uoffset** (Загрузка двойного слова с плавающей точкой относительно указателя стека) отображается как **FLD rd, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +2⁹ – 8 для загрузки.

**C.FLWSP rd, uoffset** (Загрузка слова с плавающей точкой относительно указателя стека) отображается как **FLW rd, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +2⁸ – 4 для загрузки.

Последние две инструкции поддерживают запись чисел с плавающей точкой относительно указателя стека, используя формат инструкции типа CSS.

**C.FSDSP rs2, uoffset** (Запись двойного слова с плавающей точкой относительно указателя стека) отображается как **FSD rs2, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +2⁹ – 8 для записи.

**C.FSWSP rs2, uoffset** (Запись слова с плавающей точкой относительно указателя стека) отображается как **FSW rs2, uoffset(x2)**. Шесть битов беззнакового смещения используют диапазон от +0 до +2⁸ – 4 для записи.

#### 1.11.10 Сжатые инструкции HINT

Как и в базовом наборе целочисленных инструкций, существует ряд 16-битных опкодов, которые определены как **HINT** в руководстве по набору инструкций RISC-V. Все они либо используют регистр назначения **x0**, либо имеют непосредственное значение, равное нулю, поэтому их реализация не потребует особых усилий. В таблице 18 показаны случаи 16-битных опкодов типа **HINT**.

Таблица 18: 16-битные инструкции HINT.

| Инструкция | Условие                                      | Использование                 |
|------------|----------------------------------------------|-------------------------------|
| C.NOP      | imm ≠ 0                                      | Зарезервировано для стандартного использования                              |
| C.ADDI     | rd ≠ x0 или nzimm ≠ 0                        |Зарезервировано для стандартного использования                               |
| C.LI       | rd = x0                                      | Зарезервировано для стандартного использования |
| C.LUI      | rd = x0 и nzimm ≠ 0                          | Зарезервировано для стандартного использования |
| C.MV       | rd = x0 и rs2 ≠ x0                           | Зарезервировано для стандартного использования                              |
| C.ADD      | rd = x0 и rs2 ≠ x0                           |Зарезервировано для стандартного использования                               |
| C.SLLI     | rd = x0 или shamt = 0                        | Зарезервировано для пользовательского использования                              |
| C.SRLI     | shamt = 0                                    | Зарезервировано для пользовательского использования |
| C.SRAI     | shamt = 0                                    | Зарезервировано для пользовательского использования |

#### 1.12 Расширение для манипуляции битами

Стандартное расширение «B» для инструкций манипуляции битами, возможно, является самым полезным расширением для процессора, предназначенного для встроенной обработки. В таблице 2.19 показаны инструкции по манипулятивным битам.

Таблица 19: Инструкции по манипуляции битами.

| Ассемблерная команда        | Опкод                                        | Тип |
|----------------------------|-----------------------------------------------|-----|
| SLOI rd, rs1, shamt        | 001000_shamt_sssss_001_ddddd_0010011          | I   |
| BSETI rd, rs1, sbsel       | 0010100_sbsel_sssss_001_ddddd_0010011         | I   |
| BCLRI rd, rs1, sbsel       | 0010100_sbsel_sssss_010_ddddd_0010011         | I   |
| SEXT.B rd, rs1             | 0110000_00000_sssss_001_ddddd_0010011         | I   |
| SEXT.H rd, rs1             | 0110000_00001_sssss_001_ddddd_0010011         | I   |
| BINVI rd, rs1, sbsel       | 0110100_sbsel_sssss_001_ddddd_0010011         | I   |
| SROI rd, rs1, shamt        | 011000_shamt_sssss_101_ddddd_0010011          | I   |
| BEXTI rd, rs1, sbsel       | 0100100_sbsel_sssss_101_ddddd_0010011         | I   |
| RORI rd, rs1, shamt        | 011000_shamt_sssss_101_ddddd_0010011          | I   |
| REVB rd, rs1               | 0110101_00000_sssss_101_ddddd_0010011         | I   |
| REV rd, rs1                | 0110101_11111_sssss_101_ddddd_0010011         | I   |
| SLO rd, rs1, rs2           | 0010000_ttttt_sssss_001_ddddd_0110011         | R   |
| BSET rd, rs1, rs2          | 0010100_ttttt_sssss_001_ddddd_0110011         | R   |
| BCLR rd, rs1, rs2          | 0100100_ttttt_sssss_001_ddddd_0110011         | R   |
| ROL rd, rs1, rs2           | 0110000_ttttt_sssss_001_ddddd_0110011         | R   |
| BINV rd, rs1, rs2          | 0110100_ttttt_sssss_001_ddddd_0110011         | R   |
| PACK rd, rs1, rs2          | 0000100_ttttt_sssss_100_ddddd_0110011         | R   |
| XNOR rd, rs1, rs2          | 0100000_ttttt_sssss_100_ddddd_0110011         | R   |
| PACKU rd, rs1, rs2         | 0100100_ttttt_sssss_100_ddddd_0110011         | R   |
| SRO rd, rs1, rs2           | 0010000_ttttt_sssss_101_ddddd_0110011         | R   |
| BEXT rd, rs1, rs2          | 0100100_ttttt_sssss_101_ddddd_0110011         | R   |
| ROR rd, rs1, rs2           | 0110000_ttttt_sssss_101_ddddd_0110011         | R   |
| ORN rd, rs1, rs2           | 0100000_ttttt_sssss_110_ddddd_0110011         | R   |
| PACKH rd, rs1, rs2         | 0000100_ttttt_sssss_111_ddddd_0110011         | R   |
| ANDN rd, rs1, rs2          | 0100000_ttttt_sssss_111_ddddd_0110011         | R   |

#### 1.12.1 Инструкции логических операций с инверсией (Logic-With-Negate)

Инструкции Logic-With-Negate идентичны обычным логическим инструкциям, за исключением того, что один из входов инвертируется перед операцией. Доступны только версии инструкций регистр-регистр — операнд **rs2** инвертируется. Версии инструкций с непосредственным значением (регистр-непосредственное) недоступны, потому что непосредственное значение можно просто инвертировать в исходном коде. Однако этот аргумент не учитывает проблему с расширением знака, которая может возникать в случаях с OR и XOR.

**ANDN rd, rs1, rs2** (Логическое И с инверсией),
**ORN rd, rs1, rs2** (Логическое ИЛИ с инверсией) и
**XNOR rd, rs1, rs2** (Логическое исключающее ИЛИ с инверсией)
являются инструкциями Logic-With-Negate.

#### 1.12.2 Инструкции сдвига и вращения

Инструкции сдвига и вращения здесь дополняют то, что доступно в базовом наборе инструкций, чтобы охватить все возможные случаи.

**SLO rd, rs1, rs2** (Сдвиг влево с единицами) и **SRO rd, rs1, rs2** (Сдвиг вправо с единицами) идентичны обычным инструкциям **SLL** и **SRL**, но вместо сдвига с заполнением нулями эти инструкции сдвигают с заполнением единицами. Пять наименее значащих бит регистра **rs2** управляют величиной сдвига.

**SLOI rd, rs1, shamt** (Сдвиг влево с единицами — немедленный) и **SROI rd, rs1, shamt** (Сдвиг вправо с единицами — немедленный) идентичны обычным инструкциям **SLLI** и **SRLI**, за исключением того, что они сдвигают с заполнением единицами.

**ROL rd, rs1, rs2** (Вращение влево) и **ROR rd, rs1, rs2** (Вращение вправо) работают аналогично различным инструкциям сдвига, за исключением того, что биты перераспределяются (переносятся с одного конца на другой), а не отбрасываются. Пять наименее значащих бит регистра **rs2** управляют величиной вращения.

**RORI rd, rs1, shamt** (Вращение вправо — немедленный) является единственной инструкцией вращения типа регистр-непосредственное, поскольку величину вращения можно просто дополнить (вычесть из 32) в исходном коде.

#### 1.12.3 Инструкции для работы с одним битом

Инструкции для работы с одним битом чрезвычайно полезны во многих приложениях для встроенных систем управления. Доступны как версии регистр-регистр, так и регистр-непосредственное для установки, очистки, инверсии и тестирования бита.

**BCLR rd, rs1, rs2** (Очистка одного бита), **BSET rd, rs1, rs2** (Установка одного бита) и **BINV rd, rs1, rs2** (Инверсия одного бита) работают с одним битом в регистре **rs1**, записывая результат в регистр **rd**. Эти инструкции используют пять наименее значащих бит регистра **rs2** для выбора соответствующего бита, рассматривая это поле бит как беззнаковое число в диапазоне от 0 до 31.

**BCLRI rd, rs1, sbsel** (Очистка одного бита — немедленная), **BSETI rd, rs1, sbsel** (Установка одного бита — немедленная) и **BINVI rd, rs1, sbsel** (Инверсия одного бита — немедленная) также работают с одним битом в регистре **rs1**, записывая результат в регистр **rd**. Но эти инструкции используют 5-битное поле непосредственного значения для выбора нужного бита.

**BEXT rd, rs1, rs2** (Извлечение одного бита) переносит выбранный бит из регистра **rs1** в наименее значащий бит регистра **rd**, при этом очищая все остальные биты в регистре **rd**. Пять наименее значащих бит регистра **rs2** выбирают соответствующий бит, рассматривая это поле бит как беззнаковое число в диапазоне от 0 до 31.

**BEXTI rd, rs1, sbsel** (Извлечение одного бита — немедленная) работает идентично **BEXT**, за исключением того, что 5-битное поле непосредственного значения выбирает нужный бит.

#### 1.12.4 Инструкции знакового расширения

Знаковое расширение как для байтов, так и для полуслов (halfword) можно выполнить с помощью пары инструкций сдвига, но аппаратные затраты на специализированные инструкции невелики, поэтому они включены в это стандартное расширение.

**SEXT.B rd, rs1** (Знаковое расширение байта) преобразует наименее значащий байт в регистре **rs1** в 32-битное число и записывает этот результат в регистр **rd**.

**SEXT.H rd, rs1** (Знаковое расширение полуслова) преобразует наименее значащий полуслово в регистре **rs1** в 32-битное число и записывает этот результат в регистр **rd**.

#### 1.12.5 Инструкции реверса (реверсирования)

Реверс битов и байтов часто требуется при работе с данными, которые были переданы последовательно или поступили из big-endian системы, и реализовать такие операции в программном обеспечении затруднительно. В текущем предлагаемом стандарте расширения "B" предусмотрена обобщённая инструкция реверсирования, но на практике достаточно только этих четырёх конкретных случаев:

**REV8 rd, rs1** (Реверс байтов) читает байты в порядке ABCD из регистра **rs1** и записывает их в регистр **rd** в порядке DCBA. Это преобразует слово из little-endian в big-endian или наоборот.

**REV.B rd, rs1** (Реверс бит по байтам) читает слово из регистра **rs1** и записывает его с битами в обратном порядке по каждому байту в регистр **rd**. Иными словами, каждый байт записывается с обратным порядком битов.

**REV.H rd, rs1** (Реверс бит по полусловам) читает слово из регистра **rs1** и записывает его с битами в обратном порядке по каждому полуслову в регистр **rd**. То есть каждый полуслов записывается с обратным порядком битов.

**REV rd, rs1** (Реверс бит) читает слово из регистра **rs1** и записывает его с битами в обратном порядке целиком в регистр **rd**. Все биты всего слова реверсируются.

#### 1.12.6 Инструкции упаковки

Упаковка байтов или полуслов в слова — это ещё одна операция, которая довольно часто используется в некоторых прикладных областях. Как и с реверсом бит или байт, выполнять это гораздо проще на аппаратном уровне.

**PACK rd, rs1, rs2** (Упаковка полуслов) читает байты в порядке ABCD из регистра **rs1** и байты в порядке EFGH из регистра **rs2**, а затем записывает их в порядке GHCD в регистр **rd**. Эта операция упаковывает младшие полусловы из двух регистров в один регистр.

**PACKU rd, rs1, rs2** (Упаковка верхних полуслов) читает байты в порядке ABCD из регистра **rs1** и байты в порядке EFGH из регистра **rs2**, а затем записывает их в порядке EFAB в регистр **rd**. Эта операция упаковывает старшие полусловы из двух регистров в один регистр.

**PACKH rd, rs1, rs2** (Упаковка байтов в полуслово) читает байты в порядке ABCD из регистра **rs1** и байты в порядке EFGH из регистра **rs2**, а затем записывает их в порядке 00HD в регистр **rd**. Эта операция упаковывает наименее значащие байты из двух регистров в младшие полусловы регистра.

Существует одна псевдоинструкция, которая использует инструкцию упаковки, а расширение определяет ещё одну псевдоинструкцию на основе инструкции из базового набора:

- **ZEXT.H rd, rs** (Нулевое расширение полуслова) — это **PACK rd, rs, x0**.
  
- **ZEXT.B rd, rs** (Нулевое расширение байта) — это **ANDI rd, rs, 255**.

### 1.13 Инструкция отладки

Наконец, спецификация внешней отладки RISC-V добавляет одну инструкцию, помимо определения полного набора функций отладки. Эта инструкция приведена в таблице 20.

Таблица 20: Инструкции по отладке

| Ассемблерная команда | Опкод                                    | Тип |
|---------------------|-------------------------------------------|-----|
| DRET                | 0111101_10010_00000_000_00000_1110011     | I   |

Инструкция **DRET** необходима для возврата из режима отладки (Debug-mode), который является специальным режимом, предоставляющий неограниченный доступ ко всем функциям процессора для целей отладки. Эта реализация поддерживает минимальный набор функций, требуемый спецификацией внешней отладки RISC-V, включая инструкцию **DRET**. Инструкция **DRET** разрешена только в режиме отладки, и в противном случае вызовет исключение "недопустимая инструкция" (Illegal Instruction).

## 2 Описание процессора biRISC-V

В данном разделе представлено краткое описание архитектуры и модулей RTL дизайна процессора biRISC-V

### Описание и ключевые особенности процессора

[Содержание 2 главы](./birisc_v%20description/Chapter_2_Core_description.md)

biRISC-V это 32-битный суперскалярный процессор RISC-V  с возможностью выполнений двух инструкицй. Данный процессор поддерживает базовый набор целочисленных инструкций RV32IMZicsr, операции умножения и деления, а также работу с контрольными регистрами.
Архитектура процессора основана на конвейере с 6 или 7 этапами, что обеспечивает предсказуемость выполнения программ. Особенностью biriscv является реализация механизма dual-issue, позволяющего за один такт выпускать на исполнение две независимые инструкции. Для повышения эффективности работы с условными переходами в ядре используется гибридный алгоритм предсказания ветвлений, дополненный буфером адресов переходов и стеком возвратов. 
Дизайн процессора имеют высокофункциональное интегрированное окружение для программы Verilator, что позволяет гибко внедрять требуемый функционал.

Для дизайна процессора biRISC-V характерны следующие особенности:

- 32-разрядное процессорное ядро RISC-V ISA;
- Суперскалярная in-order микроархитектура с конфигурируемым 6/7-стадийным конвейером;
- Двухканальный (dual-issue) диспетчер инструкций;
- Поддержка целочисленных инструкций RISC-V (I), умножения и деления (M), а также расширения инструкций CSR (Z) (RV32IMZicsr);
- Гибридный предсказатель (bimodal/gshare) с настраиваемой глубиной целевого буфера ветвлений (BTB) и стека адреса возврата (RAS);
- 64-битная выборка инструкций, 32-битный доступ к данным;
- 2 x целочисленных ALU (операции: арифметические, сдвига и ветвления);
- 1 x блок хранения с загрузкой, 1 x внеконвейерный делитель;
- Выдача и выполнение до 2 независимых инструкций за цикл;
- Поддерживаются уровни привилегий пользователя, супервизора и машинного режима;
- Базовая поддержка модуля управления памятью (Memory Manage Unit - MMU) - возможность загрузки Linux с эмуляцией атомарных инструкции (RV-A);
- Реализованы базовая спецификация ISA v2.1 и привилегированная спецификация ISA v1.11;
- Верифицированный дизайн с помощью случайных последовательностей инструкций RISCV-DV от Google, используя косимуляцию с моделью ISA C++;
- Поддержка кэша инструкций/данных, интерфейсов шины AXI или тесно связанной памяти (TCM - памяти);
- Настраиваемое количество стадий конвейера, опции пересылки результатов и ресурсы предсказания ветвлений;
- Синтезируемый Verilog 2001, совместимый с Verilator и аппаратной реализации на FPGA;
- Производительность: Coremark: 4.1 CoreMark/МГц и Dhrystone: 1.9 DMIPS/MHz (Поддержка "legal compile options" для эталонных тестов / 337 инструкций на итерацию).

### Архитектура (реализация) процессора

Дизайн процессора biRISC-V реализован в двух вариантах:

1. С использованием тесно связанной памятью - TCM (Tightly Coupled Memory, TCM) с фиксированным временем доступа;
2. С использованием ОЗУ, кэша данных (__dcashe__) и кеша инструкции (__icashe__).  

#### Общие компоненты

Общим компонентом является само ядро процессора, оно имеет следующую структуру:

```
riscv_core
├── u_issue
│ ├── trace_sim
│ ├── regfile
│ └── pipe_ctrl
├── u_frontend
│ ├── npc
│ ├── fetch
│ └── decode
├── exec0
├── exec1
├── u_csr
│ └── biriscv_csr_regfile
├── u_lsu
│ └── biriscv_lsu_fifo
├── u_multiplier
├── u_divider
├── u_mmu
```

##### Ядро процессора

###### 1 frontend

Модуль `biriscv_frontend` является фронтенд-частью процессора biRISC-V, отвечающей за:

- Предвыборку инструкций
- Предсказание ветвлений
- Декодирование инструкций
- Управление кешем инструкций

###### 1.1 npc

Модуль `biriscv_npc` отвечает за предсказание следующего значения PC на этапе выборки инструкций. Использует классические механизмы предсказания ветвлений:

- **BTB (Branch Target Buffer)**
- **BHT (Branch History Table)**
- **RAS (Return Address Stack)**
- **Gshare**

Параметры модуля

| Параметр                     | Описание |
|------------------------------|----------|
| `SUPPORT_BRANCH_PREDICTION`  | Поддержка предсказания ветвлений |
| `SUPPORT_MULDIV`             | Поддержка инструкций умножения/деления |
| `SUPPORT_MMU`                | Поддержка MMU |
| `EXTRA_DECODE_STAGE`         | Дополнительный этап декодирования |
| `NUM_BTB_ENTRIES`            | Количество записей в BTB |
| `NUM_BHT_ENTRIES`           | Количество записей в BHT |
| `RAS_ENABLE`                | Включение Return Address Stack |
| `GSHARE_ENABLE`             | Включение Gshare-предсказателя |
| `BHT_ENABLE`                | Включение Branch History Table |
| `NUM_RAS_ENTRIES`           | Глубина Return Address Stack |

Входы

| Порт | Разрядность | Описание |
|------|-------------|----------|
| `clk_i` | 1 | Тактовый сигнал |
| `rst_i` | 1 | Сброс |
| `invalidate_i` | 1 | Инвалидация предсказаний |
| `branch_request_i` | 1 | Подтверждение перехода |
| `branch_is_taken_i` | 1 | Ветвление было взято |
| `branch_is_not_taken_i` | 1 | Ветвление не было взято |
| `branch_source_i` | 32 | Адрес ветвления |
| `branch_is_call_i` | 1 | Вызов подпрограммы |
| `branch_is_ret_i` | 1 | Возврат из подпрограммы |
| `branch_is_jmp_i` | 1 | Безусловный переход |
| `branch_pc_i` | 32 | Целевой адрес перехода |
| `pc_f_i` | 32 | Текущий PC выборки |
| `pc_accept_i` | 1 | Сигнал приема нового PC |

Выходы

| Порт | Разрядность | Описание |
|------|-------------|----------|
| `next_pc_f_o` | 32 | Предсказанный PC |
| `next_taken_f_o` | 2 | Тип перехода: `00` — нет, `01` — условный, `10` — безусловный |

Алгоритм работы

1. BTB проверяет наличие записи
2. BHT или Gshare делает предсказание
3. RAS используется для возвратов
4. На выход подаётся `next_pc_f_o` и `next_taken_f_o`

Особенности

- Инвалидация через `invalidate_i`
- Восстановление истории при ошибочном предсказании
- Работа в разных конфигурациях

###### 1.2 fetch

Модуль `biriscv_fetch` отвечает за выборку инструкций из кэш-памяти  с учётом механизма предсказания переходов, MMU, а также обработки сбоев выборки и страничных ошибок. Поддерживает буферизацию запросов и откатов при некорректных переходах.

Параметры

| Параметр         | Описание                                |
|------------------|-----------------------------------------|
| `SUPPORT_MMU`    | Включение поддержки MMU и уровней привилегий |

Входы

| Порт                   | Размерность     | Описание |
|------------------------|-----------------|----------|
| `clk_i`                | 1 бит           | Тактовый сигнал |
| `rst_i`                | 1 бит           | Сброс |
| `fetch_accept_i`       | 1 бит           | Прием текущей выборки |
| `icache_accept_i`      | 1 бит           | Кэш принял запрос |
| `icache_valid_i`       | 1 бит           | Данные из кэша валидны |
| `icache_error_i`       | 1 бит           | Ошибка при выборке из кэша |
| `icache_inst_i`        | 64 бита         | Инструкция из кэша |
| `icache_page_fault_i`  | 1 бит           | Ошибка страницы |
| `fetch_invalidate_i`   | 1 бит           | Инвалидация выборки |
| `branch_request_i`     | 1 бит           | Запрос перехода |
| `branch_pc_i`          | 32 бита         | Адрес перехода |
| `branch_priv_i`        | 2 бита          | Уровень привилегий |
| `next_pc_f_i`          | 32 бита         | Предсказанный PC от NPC |
| `next_taken_f_i`       | 2 бита          | Тип предсказанного перехода |

Выходы

| Порт                   | Размерность     | Описание |
|------------------------|-----------------|----------|
| `fetch_valid_o`        | 1 бит           | Инструкция готова |
| `fetch_instr_o`        | 64 бита         | Полученная инструкция |
| `fetch_pred_branch_o`  | 2 бита          | Предсказанный тип перехода |
| `fetch_fault_fetch_o`  | 1 бит           | Ошибка выборки |
| `fetch_fault_page_o`   | 1 бит           | Ошибка страницы |
| `fetch_pc_o`           | 32 бита         | Адрес текущей инструкции |
| `icache_rd_o`          | 1 бит           | Запрос на чтение из кэша |
| `icache_flush_o`       | 1 бит           | Сброс кэша инструкций |
| `icache_invalidate_o`  | 1 бит           | Инвалидация кэша инструкций |
| `icache_pc_o`          | 32 бита         | Адрес чтения из кэша |
| `icache_priv_o`        | 2 бита          | Привилегия запроса к кэшу |
| `pc_f_o`               | 32 бита         | Фактический PC выборки |
| `pc_accept_o`          | 1 бит           | Подтверждение приёма нового PC |

Алгоритм работы

1. Если пришёл `branch_request_i`, обновляется `pc_f_q` — адрес новой инструкции.
2. Если нет задержки выюлрки и модуль активен, формируется запрос к кэшу `icache_rd_o`.
3. Полученная инструкция буферизуется, если не может быть немедленно передана.
4. При ошибках (страничных или fetch) выставляются соответствующие флаги.
5. Если MMU включен, учитываются уровни привилегий.

Особенности

- Поддерживает разные режимы работы: с и без MMU.
- Выравнивает адрес при обращении к `icache`.
- Встроенный механизм очистки.
- Устойчив к конфликтным ситуациям с помощью `skid_buffer_q`.

###### 1.3 decode

Модуль `biriscv_decode` занимается дешифровкой инструкций и управлением потоком инструкций перед их выполнением. Он реализует стадию декодирования в процессоре biRISC-V и может работать в двух конфигурациях: с дополнительной стадией или без неё.

Параметры

| Параметр             | Описание                                                 |
|----------------------|----------------------------------------------------------|
| `SUPPORT_MULDIV`     | Включение поддержки инструкций умножения и деления       |
| `EXTRA_DECODE_STAGE` | Включение дополнительной стадии декодирования перед FIFO |

Входы

| Сигнал                    | Размерность | Описание                                         |
|---------------------------|-------------|--------------------------------------------------|
| `clk_i`                   | 1 бит       | Тактовый сигнал                                  |
| `rst_i`                   | 1 бит       | Сброс                                            |
| `fetch_in_valid_i`        | 1 бит       | Валидность входных инструкций                    |
| `fetch_in_instr_i`        | 64 бита     | Пара инструкций (две по 32 бита)                 |
| `fetch_in_pred_branch_i`  | 2 бита      | Предсказание ветвления                           |
| `fetch_in_fault_fetch_i`  | 1 бит       | Ошибка при извлечении                            |
| `fetch_in_fault_page_i`   | 1 бит       | Ошибка страницы                                  |
| `fetch_in_pc_i`           | 32 бита     | Адрес первой инструкции                          |
| `fetch_out0_accept_i`     | 1 бит       | Готовность принять первую инструкцию             |
| `fetch_out1_accept_i`     | 1 бит       | Готовность принять вторую инструкцию             |
| `branch_request_i`        | 1 бит       | Запрос на переход                                |
| `branch_pc_i`             | 32 бита     | Адрес перехода                                   |
| `branch_priv_i`           | 2 бита      | Уровень привилегий при переходе                  |

Выходы

| Сигнал                           | Размерность | Описание                                        |
|----------------------------------|-------------|-------------------------------------------------|
| `fetch_in_accept_o`              | 1 бит       | Модуль готов принять новую пару инструкций      |
| `fetch_out0_valid_o`             | 1 бит       | Валидность первой инструкции                    |
| `fetch_out0_instr_o`             | 32 бита     | Первая инструкция                               |
| `fetch_out0_pc_o`                | 32 бита     | Адрес первой инструкции                         |
| `fetch_out0_fault_fetch_o`       | 1 бит       | Ошибка при извлечении                           |
| `fetch_out0_fault_page_o`        | 1 бит       | Ошибка страницы                                 |
| `fetch_out0_instr_exec_o`        | 1 бит       | Инструкция общего назначения                    |
| `fetch_out0_instr_lsu_o`         | 1 бит       | Инструкция загрузки/сохранения                  |
| `fetch_out0_instr_branch_o`      | 1 бит       | Инструкция ветвления                            |
| `fetch_out0_instr_mul_o`         | 1 бит       | Инструкция умножения                            |
| `fetch_out0_instr_div_o`         | 1 бит       | Инструкция деления                              |
| `fetch_out0_instr_csr_o`         | 1 бит       | Инструкция работы с CSR                         |
| `fetch_out0_instr_rd_valid_o`    | 1 бит       | Инструкция записывает результат                 |
| `fetch_out0_instr_invalid_o`     | 1 бит       | Невалидная инструкция                           |
| `fetch_out1_valid_o`             | 1 бит       | Валидность второй инструкции                    |
| `fetch_out1_instr_o`             | 32 бита     | Вторая инструкция                               |
| `fetch_out1_pc_o`                | 32 бита     | Адрес второй инструкции                         |
| `fetch_out1_fault_fetch_o`       | 1 бит       | Ошибка при извлечении второй инструкции         |
| `fetch_out1_fault_page_o`        | 1 бит       | Ошибка страницы второй инструкции               |
| `fetch_out1_instr_exec_o`        | 1 бит       | Вторая инструкция общего назначения             |
| `fetch_out1_instr_lsu_o`         | 1 бит       | Вторая инструкция загрузки/сохранения           |
| `fetch_out1_instr_branch_o`      | 1 бит       | Вторая инструкция ветвления                     |
| `fetch_out1_instr_mul_o`         | 1 бит       | Вторая инструкция умножения                     |
| `fetch_out1_instr_div_o`         | 1 бит       | Вторая инструкция деления                       |
| `fetch_out1_instr_csr_o`         | 1 бит       | Вторая инструкция работы с CSR                  |
| `fetch_out1_instr_rd_valid_o`    | 1 бит       | Вторая инструкция записывает результат          |
| `fetch_out1_instr_invalid_o`     | 1 бит       | Невалидная вторая инструкция                    |

Внутренние компоненты

- `biriscv_decoder` - декодер инструкций. Определяет тип инструкции и устанавливает соответствующие флаги: ветвление, LSU, CSR, арифметика, умножение, деление, недопустимые инструкции и т.д.
- `fetch_fifo` - буферная очередь для хранения пар инструкций, их адресов и флагов. Поддерживает сброс при переходе .

Особенности

- При использовании дополнительной стадии декодирования инструкции сначала обрабатываются двумя декодерами, затем результат отправляется в FIFO для дальнейшего использования
- Без дополнительной стадии инструкции поступают напрямую в FIFO, декодер применяется позже, при извлечении инструкций из очереди.
- Модуль поддерживает параллельную обработку двух инструкций
- Предусмотрена очистка очереди при переходе

###### 2 issue

Модуль biriscv_issue является критически важным компонентом суперскалярного процессора biRISC-V, выполняющим функцию __диспетчера инструкций__ (instruction scheduler). Его основное назначение и ключевые функции:

1. Основная задача

    Управление конвейерной обработкой инструкций:  
    1.1 Выборка и распределение инструкций по исполнительным устройствам (ALU, LSU, MUL/DIV и др.)  
    1.2 Контроль зависимостей между инструкциями  
    1.3 Реализация двухпоточного исполнения (dual-issue)  

2. Ключевые функции

    2.1 Декодирование - анализ поступающих инструкций и определение их типа (ALU, LSU, Branch и т.д.);
    2.2 Распределение - назначение инструкций свободным исполнительным блокам;
    2.3 Управление зависимостями - отслеживание RAW/WAW-зависимостей;
    2.4 Обходные пути - формирование bypass-путей для результатов операций;
    2.5 Контроль потока - обработка ветвлений, исключений и прерываний.

Таблица сигналов модуля biriscv_issue

Параметры модуля biriscv_issue

| Параметр                  | Значение по умолчанию | Описание                                      |
|---------------------------|-----------------------|-----------------------------------------------|
| SUPPORT_MULDIV            | 1                     | Поддержка операций умножения/деления          |
| SUPPORT_DUAL_ISSUE        | 1                     | Поддержка двухпоточного исполнения            |
| SUPPORT_LOAD_BYPASS       | 1                     | Поддержка обхода загрузки                     |
| SUPPORT_MUL_BYPASS        | 1                     | Поддержка обхода умножения                    |
| SUPPORT_REGFILE_XILINX    | 0                     | Использование регистрового файла Xilinx       |

Ключевые особенности:

1. **Двухпоточная архитектура**: Поддержка одновременной выдачи двух инструкций (dual-issue)
2. **Регистровый файл**: 2 порта записи и 4 порта чтения (2W4R)
3. **Обходные пути**: Поддержка обхода результатов операций для минимизации простоев
4. **Управление конвейером**: Сложная логика остановок и сбросов конвейера
5. **Поддержка исключений**: Обработка ошибок выполнения и страничных нарушений

> Примечание: Все сигналы данных и адресов используют 32-битную разрядность, соответствующую архитектуре RV32

###### 2.1 pipe_ctrl

Модуль `biriscv_pipe_ctrl` управляет продвижением инструкций по стадиям конвейера в процессоре BiRISCV. Он контролирует остановки (`stall`), сбросы стадий (`squash`), обработку исключений и прерываний, а также выполнение и приоритет операций типа CSR, LSU, умножения и деления.

Параметры

| Параметр             | Описание                                 |
|----------------------|-------------------------------------------|
| `SUPPORT_LOAD_BYPASS`| Включает bypass для инструкций загрузки   |
| `SUPPORT_MUL_BYPASS` | Включает bypass для инструкций умножения |

Входы

| Сигнал                     | Размерность | Описание                                      |
|----------------------------|-------------|-----------------------------------------------|
| `clk_i`                    | 1 бит       | Тактовый сигнал                               |
| `rst_i`                    | 1 бит       | Сброс                                         |
| `issue_valid_i`            | 1 бит       | Инструкция готова к выдаче                    |
| `issue_accept_i`           | 1 бит       | Инструкция принята                            |
| `issue_stall_i`            | 1 бит       | Stall на стадии issue                         |
| `issue_lsu_i`              | 1 бит       | Инструкция — LSU                              |
| `issue_csr_i`              | 1 бит       | Инструкция — CSR                              |
| `issue_div_i`              | 1 бит       | Инструкция — деление                          |
| `issue_mul_i`              | 1 бит       | Инструкция — умножение                        |
| `issue_branch_i`           | 1 бит       | Инструкция — переход                          |
| `issue_rd_valid_i`         | 1 бит       | Регистр назначения валиден                    |
| `issue_rd_i`               | 5 бит       | Номер регистра назначения                     |
| `issue_exception_i`        | 1 бит       | Инструкция вызывает исключение                |
| `take_interrupt_i`         | 1 бит       | Прерывание                                    |
| `issue_branch_taken_i`     | 1 бит       | Ветка взята                                   |
| `issue_branch_target_i`    | 32 бита     | Адрес перехода                                |
| `issue_pc_i`               | 32 бита     | PC инструкции                                 |
| `issue_opcode_i`           | 32 бита     | Код операции                                  |
| `issue_operand_ra_i`       | 32 бита     | Операнд A                                     |
| `issue_operand_rb_i`       | 32 бита     | Операнд B                                     |
| `alu_result_e1_i`          | 32 бита     | Результат ALU со стадии E1                    |
| `csr_result_value_e1_i`    | 32 бита     | Значение CSR                                  |
| `csr_result_write_e1_i`    | 1 бит       | Нужно записать в CSR                          |
| `csr_result_wdata_e1_i`    | 32 бита     | Данные для записи в CSR                       |
| `csr_result_exception_e1_i`| 1 бит       | Исключение в CSR                              |
| `mem_complete_i`           | 1 бит       | Операция памяти завершена                     |
| `mem_result_e2_i`          | 32 бита     | Результат операции памяти                     |
| `mem_exception_e2_i`       | 1 бит       | Исключение на памяти                          |
| `mul_result_e2_i`          | 32 бита     | Результат умножения                           |
| `div_complete_i`           | 1 бит       | Деление завершено                             |
| `div_result_i`             | 32 бита     | Результат деления                             |
| `squash_e1_e2_i`           | 1 бит       | Squash стадий E1 и E2                         |
| `squash_wb_i`              | 1 бит       | Squash стадии WB                              |

Выходы

Стадия E1

| Сигнал             | Размерность | Описание                         |
|--------------------|-------------|----------------------------------|
| `load_e1_o`        | 1 бит       | Является ли загрузкой            |
| `store_e1_o`       | 1 бит       | Является ли записью в память     |
| `mul_e1_o`         | 1 бит       | Умножение                        |
| `branch_e1_o`      | 1 бит       | Переход                          |
| `rd_e1_o`          | 5 бит       | Регистр назначения               |
| `pc_e1_o`          | 32 бита     | PC                               |
| `opcode_e1_o`      | 32 бита     | Opcode                           |
| `operand_ra_e1_o`  | 32 бита     | Операнд A                        |
| `operand_rb_e1_o`  | 32 бита     | Операнд B                        |

Стадия E2

| Сигнал             | Размерность | Описание                     |
|--------------------|-------------|------------------------------|
| `load_e2_o`        | 1 бит       | Загрузка                     |
| `mul_e2_o`         | 1 бит       | Умножение                    |
| `rd_e2_o`          | 5 бит       | Регистр назначения           |
| `result_e2_o`      | 32 бита     | Результат                    |

Writeback

| Сигнал              | Размерность | Описание                         |
|---------------------|-------------|----------------------------------|
| `valid_wb_o`        | 1 бит       | Данные WB валидны                |
| `csr_wb_o`          | 1 бит       | Операция CSR                     |
| `rd_wb_o`           | 5 бит       | Регистр назначения               |
| `result_wb_o`       | 32 бита     | Результат                        |
| `pc_wb_o`           | 32 бита     | PC                               |
| `opcode_wb_o`       | 32 бита     | Opcode                           |
| `operand_ra_wb_o`   | 32 бита     | Операнд A                        |
| `operand_rb_wb_o`   | 32 бита     | Операнд B                        |
| `exception_wb_o`    | 1 бит       | Признак исключения               |
| `csr_write_wb_o`    | 1 бит       | Запись в CSR                     |
| `csr_waddr_wb_o`    | 12 бита     | Адрес CSR                        |
| `csr_wdata_wb_o`    | 32 бита     | Данные для записи в CSR          |

Управление

| Сигнал             | Размерность | Описание                  |
|--------------------|-------------|---------------------------|
| `stall_o`          | 1 бит       | Сигнал остановки конвейера|
| `squash_e1_e2_o`   | 1 бит       | Squash стадий E1 и E2     |

- **E1**: принимает инструкцию, запоминает её, передаёт тип, операнды и PC. Проверяет исключения и переходы.
- **E2**: обрабатывает данные из ALU, LSU, MUL, DIV и CSR; формирует `result_e2_o`.
- **WB**: выдает результат, исключения, операции CSR и сигналы записи в регистр.
- **Stall/Squash**: обеспечивает корректную приостановку или сброс конвейера.

Особенности

- Поддержка bypass для загрузки и умножения (если включены параметрами).
- Обработка прерываний и исключений на стадии issue.
- Гибкое управление стадиями и приоритетами операций.
- Полноценная поддержка CSR и взаимодействия с памятью.

###### 2.1.1 trace_sim

Модуль `biriscv_trace_sim` используется для трассировки инструкций внутри симуляции. Он декодирует входящую инструкцию, определяет её тип и формирует строковое описание операции, а также имён регистров-операндов и значений немедленных операндов.

Этот модуль активен только при компиляции с Verilator и применяется для отладки.

Интерфейсы

| Порт      | Разрядность | Описание                      |
|-----------|-------------|-------------------------------|
| `valid_i` | 1 бит       | Флаг валидности инструкции    |
| `pc_i`    | 32 бита     | Текущий адрес инструкции      |
| `opcode_i`| 32 бита     | Код операции                  |

Внутренние регистры

| Имя            | Разрядность | Назначение                                 |
|----------------|-------------|--------------------------------------------|
| `dbg_inst_str` | 80 бит      | Название инструкции                        |
| `dbg_inst_ra`  | 80 бит      | Имя регистра `rs1`                         |
| `dbg_inst_rb`  | 80 бит      | Имя регистра `rs2`                         |
| `dbg_inst_rd`  | 80 бит      | Имя регистра `rd`                          |
| `dbg_inst_imm` | 32 бита     | Немедленное значение                       |
| `dbg_inst_pc`  | 32 бита     | PC текущей инструкции                      |

Логика работы

Если `valid_i` активен:

- Считываются регистры `rs1`, `rs2`, `rd` из полей инструкции `opcode_i`.
- Значения конвертируются в строковые имена через функцию `get_regname_str`.
- Инструкция сопоставляется с шаблонами через маски `INST_*`.
  - При совпадении определяются:
    - тип инструкции (`dbg_inst_str`),
    - имя регистров (`dbg_inst_ra`, `dbg_inst_rb`, `dbg_inst_rd`),
    - значение немедленного значения (`dbg_inst_imm`), если применимо.

Поддерживаемые инструкции

Поддерживаются все основные типы RISC-V инструкций:

- **I**: `addi`, `andi`, `ori`, `xori`, `slti`, `sltiu`, `jalr`, `lb`, `lh`, `lw`, ...
- **R**: `add`, `sub`, `and`, `or`, `xor`, `sll`, `srl`, `sra`, `mul`, `div`, `rem`, ...
- **U**: `lui`, `auipc`
- **J**: `jal`
- **B**: `beq`, `bne`, `blt`, `bge`, ...
- **S-**: `sb`, `sh`, `sw`, ...
- **CSR**: `csrrw`, `csrrs`, `csrrc`, `csrrwi`, `csrrsi`, `csrrci`
- **Прочее**: `ecall`, `ebreak`, `eret`, `fence.i`

Константы-иммедиаты

| Имя               | Формат и описание                                           |
|-------------------|-------------------------------------------------------------|
| `DBG_IMM_IMM20`   | `opcode_i[31:12] << 12` — 20-битное немедленное значение    |
| `DBG_IMM_IMM12`   | Sign-extended `opcode_i[31:20]` — 12-битное немедленное     |
| `DBG_IMM_BIMM`    | Сформировано из полей для ветвлений                         |
| `DBG_IMM_JIMM20`  | Сформировано из полей `jal`                                 |
| `DBG_IMM_STOREIMM`| Для инструкций хранения                                     |
| `DBG_IMM_SHAMT`   | Смещение — 5 бит                                            |

###### 2.2 regfile

Модуль `biriscv_regfile` реализует регистровый файл, поддерживющий dual-issue архитектуру. В зависимости от параметров компиляции может использоваться реализация с Xilinx RAM или простая модель на триггерах.

Параметры

| Параметр                 | Описание                                           |
|--------------------------|----------------------------------------------------|
| `SUPPORT_REGFILE_XILINX` | Включение специализированной реализации для Xilinx |
| `SUPPORT_DUAL_ISSUE`     | Поддержка двухпотоковой архитектуры                |

Порты

Входы

| Имя            | Разрядность | Описание                                      |
|----------------|--------------|----------------------------------------------|
| `clk_i`        | 1 бит        | Тактовый сигнал                              |
| `rst_i`        | 1 бит        | Сброс                                        |
| `rd0_i`        | 5 бит        | Номер регистра для записи потока 0           |
| `rd1_i`        | 5 бит        | Номер регистра для записи потока 1           |
| `rd0_value_i`  | 32 бита      | Значение для записи в регистр потока 0       |
| `rd1_value_i`  | 32 бита      | Значение для записи в регистр потока 1       |
| `ra0_i`        | 5 бит        | Номер регистра A для чтения потока 0         |
| `rb0_i`        | 5 бит        | Номер регистра B для чтения потока 0         |
| `ra1_i`        | 5 бит        | Номер регистра A для чтения потока 1         |
| `rb1_i`        | 5 бит        | Номер регистра B для чтения потока 1         |

Выходы

| Имя            | Разрядность  | Описание                                      |
|----------------|--------------|-----------------------------------------------|
| `ra0_value_o`  | 32 бита      | Прочитанное значение из регистра A потока 0   |
| `rb0_value_o`  | 32 бита      | Прочитанное значение из регистра B потока 0   |
| `ra1_value_o`  | 32 бита      | Прочитанное значение из регистра A потока 1   |
| `rb1_value_o`  | 32 бита      | Прочитанное значение из регистра B потока 1   |

Описание работы

Модуль реализует регистровый файл с поддержкой одновременного чтения двух регистров и записи в два регистра. Он имеет три варианта реализации:

Если включены параметры `SUPPORT_REGFILE_XILINX = 1` и `SUPPORT_DUAL_ISSUE = 1`, то создаются четыре экземпляра модуля `biriscv_xilinx_2r1w`. Для разрешения конфликтов записи используется дополнительная логика на базе регистра `reg_src_q`, определяющего последнее записанное значение.

Если включен только `SUPPORT_REGFILE_XILINX`, но `SUPPORT_DUAL_ISSUE = 0`, используется один экземпляр `biriscv_xilinx_2r1w`, а выходы второго потока устанавливаются в ноль.

Если `SUPPORT_REGFILE_XILINX = 0`, используется простая симуляционная модель на триггерах. Все 31 пользовательских регистра (x1 – x31) представлены отдельными регистровыми переменными. Запись в регистры происходит синхронно, при этом приоритет отдаётся потоку 0. Регистр x0 всегда возвращает ноль.

Примечания

- Регистр `x0` всегда равен 0 и не может быть перезаписан.
- Записи в регистры выполняются синхронно на положительном фронте `clk_i`.
- Используемая реализация зависит от параметров и может быть адаптирована под целевую FPGA или симуляцию.

###### 2.2.1 xilinx_2r1w

Модуль `biriscv_xilinx_2r1w` представляет собой реализацию регистрового файла с одной портовой записью и двумя портами чтения. Он оптимизирован под FPGA Xilinx и использует  `RAM16X1D` для реализации двухпортовой памяти. Поддерживает до 32 регистров шириной 32 бита.

Порты

Входы

| Имя            | Разрядность | Описание                                      |
|----------------|--------------|----------------------------------------------|
| `clk_i`        | 1 бит        | Тактовый сигнал                              |
| `rst_i`        | 1 бит        | Сброс                                        |
| `rd0_i`        | 5 бит        | Номер регистра для записи                    |
| `rd0_value_i`  | 32 бита      | Значение, записываемое в регистр             |
| `ra_i`         | 5 бит        | Номер регистра для чтения A                  |
| `rb_i`         | 5 бит        | Номер регистра для чтения B                  |

Выходы

| Имя            | Разрядность  | Описание                                     |
|----------------|--------------|----------------------------------------------|
| `ra_value_o`   | 32 бита      | Значение регистра A                          |
| `rb_value_o`   | 32 бита      | Значение регистра B                          |

Особенности

- Один порт записи, два независимых порта чтения.
- Использует два банка: банк 0 (регистры 0–15) и банк 1 (регистры 16–31).
- Значение регистра `x0` всегда возвращает `0`.
- Чтение и запись осуществляются асинхронно по чтению и синхронно по записи.
- Специальная модель `RAM16X1D` для симуляции с Verilator.
- Регистры разделены на два блока по 16 регистров.
- Каждый регистр состоит из 32 независимых битовых RAM-блоков.
- Поддерживается одновременное чтение двух разных регистров, независимо от текущей операции записи.
- Регистр `x0` всегда возвращает `0`, даже при попытке записи.

###### 3 divider

Модуль `biriscv_divider` реализует операции деления и вычисления остатка для процессора biRISC-V в соответствии со стандартом RISC-V. Поддерживает все варианты операций деления, включая знаковые и беззнаковые версии.

Входные сигналы

| Сигнал                  | Размерность | Описание |
|-------------------------|-------------|----------|
| `clk_i`, `rst_i`       | 1 бит       | Такт и сброс |
| `opcode_*`             | Различная   | Информация о текущей инструкции |
| `opcode_ra_operand_i`  | 32 бита     | Делимое (rs1) |
| `opcode_rb_operand_i`  | 32 бита     | Делитель (rs2) |

Выходные сигналы

| Сигнал               | Размерность | Описание |
|----------------------|-------------|----------|
| `writeback_valid_o`  | 1 бит       | Флаг валидности результата |
| `writeback_value_o`  | 32 бита     | Результат операции |

Поддерживаемые инструкции

| Инструкция | Описание |
|------------|----------|
| `DIV`      | Знаковое деление |
| `DIVU`     | Беззнаковое деление |
| `REM`      | Знаковый остаток от деления |
| `REMU`     | Беззнаковый остаток от деления |

Внутренняя структура

Ключевые регистры:

- `dividend_q` - текущее делимое
- `divisor_q` - текущий делитель (сдвигаемый)
- `quotient_q` - накапливаемое частное
- `q_mask_q` - маска для построения частного
- `div_busy_q` - флаг выполнения операции
- `wb_result_q` - результат для записи

Основные логические блоки:

1. **Декодирование инструкций**:
   - Определение типа операции (деление/остаток, знаковое/беззнаковое)
   - Установка флагов `signed_operation_w` и `div_operation_w`

2. **Подготовка операндов**:
   - Для знаковых операций: вычисление модулей операндов при необходимости
   - Установка флага `invert_res_q` для коррекции знака результата

3. **Алгоритм деления**:
   - Итерационный алгоритм с восстановлением остатка
   - На каждом шаге:
     - Сравнение делителя с текущим остатком
     - Вычитание и обновление частного при необходимости
     - Сдвиг делителя и маски

4. **Коррекция результата**:
   - Инверсия знака результата при необходимости
   - Выбор между частным и остатком

Особенности реализации

1. **Оптимизация повторных операций**:
   - Запоминание последних операндов и типа операции
   - Пропуск вычислений при повторении тех же параметров

2. **Обработка знаков**:
   - Работа с модулями чисел при знаковых операциях
   - Коррекция знака результата на последнем этапе

3. **Управление состоянием**:
   - Сигнал `div_busy_q` указывает на выполнение операции
   - Сигнал `div_complete_w` отмечает завершение вычислений

4. **Конвейеризация**:
   - Результат сохраняется в регистр `wb_result_q`
   - Сигнал `writeback_valid_o` указывает на готовность результата

5. **Обработка особых случаев**:
   - Корректная обработка знаковых операций
   - Оптимизация для повторяющихся вычислений

Модуль обеспечивает полную поддержку стандарта RISC-V для операций деления и вычисления остатка, с эффективной реализацией итерационного алгоритма деления.

###### 4 lsu

Модуль `biriscv_lsu` отвечает за:

- Обработку инструкций загрузки (load) и сохранения (store)
- Работу с памятью через интерфейс кэша данных
- Обработку невыровненных (unaligned) доступов
- Генерацию исключений при ошибках доступа к памяти
- Управление операциями с кэшем (инвалидация, сброс и др.)

Параметры модуля

| Параметр                | Описание |
|-------------------------|----------|
| `MEM_CACHE_ADDR_MIN`    | Минимальный адрес кэшируемой памяти |
| `MEM_CACHE_ADDR_MAX`    | Максимальный адрес кэшируемой памяти |

Основные функции

1. Обработка инструкций загрузки/сохранения
   Поддерживает все стандартные инструкции RISC-V:
   - Загрузки: `LB`, `LH`, `LW`, `LBU`, `LHU`, `LWU`
   - Сохранения: `SB`, `SH`, `SW`
   - Обрабатывает знаковые и беззнаковые варианты
2. Работа с памятью
   - Формирует адреса для доступа
   - Генерирует маски записи для операций разной ширины
   - Обрабатывает ответы от подсистемы памяти

3. Обработка невыровненных доступов
   - Обнаруживает невыровненные доступы (для полуслов и слов)
   - Генерирует соответствующие исключения

4. Управление кэшем
   - Поддерживает операции:
     - Инвалидация (`mem_invalidate_o`)
     - Запись обратно (`mem_writeback_o`)
     - Полный сброс (`mem_flush_o`)
   - Определяет кэшируемость адресов (`mem_cacheable_o`)

5. Генерация исключений
   - Ошибки выравнивания:
     - `EXCEPTION_MISALIGNED_LOAD`
     - `EXCEPTION_MISALIGNED_STORE`
   - Ошибки страниц:
     - `EXCEPTION_PAGE_FAULT_LOAD`
     - `EXCEPTION_PAGE_FAULT_STORE`
   - Ошибки шины:
     - `EXCEPTION_FAULT_LOAD`
     - `EXCEPTION_FAULT_STORE`

Внутренняя структура

Подмодули:

**biriscv_lsu_fifo** - FIFO буфер для отслеживания запросов:
    - Глубина 2 записи
    - Хранит информацию о выполняемых операциях

Ключевые внутренние сигналы:

- `pending_lsu_e2_q` - флаг ожидания завершения запроса
- `mem_unaligned_e1_q` - флаг невыровненного доступа
- `mem_load_q` - флаг операции загрузки
- `mem_xb_q`, `mem_xh_q` - флаги операций с байтами и полусловами

Особенности реализации

1. **Обработка запросов**:
   - Поддерживает конвейеризацию запросов
   - Обеспечивает правильное упорядочивание операций

2. **Формирование результата**:
   - Для операций загрузки выполняет расширение знака
   - Корректно обрабатывает доступы к разным байтам слова

3. **Управление потоком**:
   - Генерирует сигнал `stall_o` при необходимости остановки конвейера
   - Обрабатывает задержки ответов от памяти

4. **Специальные операции**:
   - Поддерживает CSR-инструкции для управления кэшем
   - Обрабатывает барьеры памяти

Модуль обеспечивает полную поддержку стандарта RISC-V для операций загрузки и сохранения с эффективным управлением памятью и обработкой ошибок

###### 5 mmu

Модуль `biriscv_mmu` реализует механизм виртуальной памяти для процессора biRISC-V, обеспечивая:

- Трансляцию виртуальных адресов в физические
- Защиту памяти через систему привилегий
- Кэширование таблиц страниц (TLB)
- Обработку исключений доступа к памяти

Параметры модуля

| Параметр                | Описание |
|-------------------------|----------|
| `MEM_CACHE_ADDR_MIN`    | Минимальный адрес кэшируемой памяти |
| `MEM_CACHE_ADDR_MAX`    | Максимальный адрес кэшируемой памяти |
| `SUPPORT_MMU`           | Флаг поддержки MMU (1 - включено) |

Входные сигналы

Управление и конфигурация

| Сигнал              | Размерность | Описание |
|---------------------|-------------|----------|
| `clk_i`, `rst_i`    | 1 бит       | Такт и сброс |
| `priv_d_i`          | 2 бита      | Текущий режим привилегий (для данных) |
| `sum_i`             | 1 бит       | Разрешение доступа супервизора к пользовательским страницам |
| `mxr_i`             | 1 бит       | Разрешение исполнения при чтении (Make eXecutable Readable) |
| `flush_i`           | 1 бит       | Сигнал сброса TLB |
| `satp_i`            | 32 бита     | Регистр управления виртуальной памятью |

Интерфейс выборки инструкций

| Сигнал                 | Размерность | Описание |
|------------------------|-------------|----------|
| `fetch_in_*`           | Различная   | Запросы на выборку инструкций |
| `fetch_out_*`          | Различная   | Ответы от кэша инструкций |

Интерфейс загрузки/сохранения

| Сигнал                 | Размерность | Описание |
|------------------------|-------------|----------|
| `lsu_in_*`             | Различная   | Запросы LSU (Load/Store Unit) |
| `lsu_out_*`            | Различная   | Ответы от кэша данных |

Выходные сигналы

Интерфейс выборки инструкций

| Сигнал                 | Размерность | Описание |
|------------------------|-------------|----------|
| `fetch_in_*`           | Различная   | Ответы на запросы выборки |
| `fetch_out_*`          | Различная   | Запросы к кэшу инструкций |

Интерфейс загрузки/сохранения

| Сигнал                 | Размерность | Описание |
|------------------------|-------------|----------|
| `lsu_in_*`             | Различная   | Ответы LSU |
| `lsu_out_*`            | Различная   | Запросы к кэшу данных |
| `lsu_in_load_fault_o`  | 1 бит       | Ошибка загрузки (страничное нарушение) |
| `lsu_in_store_fault_o` | 1 бит       | Ошибка сохранения (страничное нарушение) |

Основные функции

1. Трансляция адресов
    - Поддержка двухуровневой таблицы страниц (SV32)
    - Обработка 4MB суперстраниц и 4KB страниц
    - Кэширование результатов трансляции в TLB

2. TLB (Translation Lookaside Buffer)
    - Отдельные TLB для инструкций (ITLB) и данных (DTLB)
    - Инвалидация по сигналу `flush_i`
    - Автоматическое обновление при промахах

3. Проверка прав доступа
    - Контроль прав на чтение/запись/исполнение
    - Учет текущего режима привилегий (`priv_d_i`)
    - Обработка флагов `sum_i` и `mxr_i`

4. Обработка исключений
    - Страничные нарушения (page faults)
    - Нарушения прав доступа
    - Ошибки выравнивания

5. Интерфейс с кэшами
    - Трансляция адресов для кэша инструкций
    - Трансляция адресов для кэша данных
    - Управление кэшируемостью областей памяти

Внутренняя структура

Ключевые компоненты:

1. **ITLB (Instruction TLB)**
   - Кэш трансляций для выборки инструкций
   - Проверка прав на исполнение

2. **DTLB (Data TLB)**
   - Кэш трансляций для операций загрузки/сохранения
   - Проверка прав на чтение/запись

3. **Page Table Walker**
   - Аппаратный обход таблицы страниц
   - Поддержка двухуровневой структуры
   - Обработка суперстраниц

4. **Интерфейс запросов**
   - Арбитраж между запросами MMU и процессора
   - Управление приоритетами

Особенности реализации

1. **Конвейеризация**:
   - Перекрытие обработки TLB-промахов с обычными операциями
   - Оптимизированные пути для частых случаев

2. **Оптимизации**:
   - Предварительная проверка TLB-попаданий
   - Быстрая обработка машинного режима (когда MMU отключен)

3. **Безопасность**:
   - Строгая проверка прав доступа
   - Изоляция пространств пользователя и супервизора

4. **Гибкость**:
   - Возможность отключения MMU через параметр `SUPPORT_MMU`
   - Настраиваемые области кэшируемой памяти

Модуль обеспечивает полную поддержку виртуальной памяти согласно спецификации RISC-V Privileged Architecture.

###### 6 csr

Модуль `biriscv_csr` отвечает за:

- Управление регистрами состояния и контроля (CSR)
- Обработку исключений и прерываний
- Управление привилегированными режимами работы
- Взаимодействие с MMU (Memory Management Unit)
- Обработку специальных инструкций (ECALL, EBREAK, ERET и др.)

Параметры модуля

| Параметр            | Описание |
|---------------------|----------|
| `SUPPORT_MULDIV`    | Поддержка инструкций умножения/деления |
| `SUPPORT_SUPER`     | Поддержка супервизорного режима (S-mode) |

Основные функции

1. Обработка CSR-инструкций
   Поддерживает все стандартные CSR-инструкции RISC-V:
   - `CSRRW`, `CSRRS`, `CSRRC` - чтение/запись CSR
   - `CSRRWI`, `CSRRSI`, `CSRRCI` - чтение/запись CSR с immediate-значением
   - Проверяет привилегии доступа к CSR

2. Обработка специальных инструкций
   - `ECALL` - вызов исключения
   - `EBREAK` - точка останова
   - `ERET` - возврат из исключения
   - `WFI` - ожидание прерывания
   - `FENCE`, `SFENCE`, `IFENCE` - барьеры памяти

3. Управление прерываниями и исключениями
   - Формирует сигнал `take_interrupt_o` для обработки прерываний
   - Генерирует коды исключений:
     - `EXCEPTION_ECALL`
     - `EXCEPTION_ERET`
     - `EXCEPTION_BREAKPOINT`
     - `EXCEPTION_ILLEGAL_INSTRUCTION`
     - `EXCEPTION_FENCE`

4. Управление привилегиями
   Поддерживает 3 уровня привилегий (M/S/U режимы):
   - Контролирует переходы между режимами
   - Проверяет права доступа к CSR
   - Управляет регистром `mstatus`

5. Взаимодействие с MMU
   - Управляет регистром `satp` (режим трансляции адресов)
   - Формирует сигналы:
     - `mmu_priv_d_o` - текущий режим привилегий для MMU
     - `mmu_satp_o` - значение регистра SATP
     - `mmu_flush_o` - запрос на сброс TLB
     - `mmu_sum_o`, `mmu_mxr_o` - флаги доступа к памяти

Модуль обеспечивает полную поддержку стандарта RISC-V для работы с CSR и обработки исключений, с возможностью конфигурации через параметры.

###### 6.1 biriscv_csr_regfile

Это регистровый файл CSR, который:

- Содержит все стандартные CSR регистры RISC-V
- Обрабатывает чтение/запись регистров
- Управляет прерываниями и исключениями

Ключевые внутренние сигналы:

- `current_priv_w` - текущий уровень привилегий
- `status_reg_w` - значение регистра статуса
- `satp_reg_w` - значение регистра SATP
- `interrupt_w` - маска прерываний

Особенности реализации

1. **Обработка исключений**:
   - Исключения обнаруживаются на стадии E1 (раннее декодирование)
   - Сохраняют контекст в соответствующих CSR регистрах

2. **Управление ветвлениями**:
   - Обрабатывает ветвления по исключениям и прерываниям
   - Формирует целевой адрес перехода (`branch_csr_pc_o`)

3. **Барьеры памяти**:
   - `FENCE` - синхронизация памяти
   - `SFENCE` - сброс TLB
   - `IFENCE` - сброс конвейера инструкций

###### 7 multiplier

Модуль `biriscv_multiplier` реализует операции умножения для процессора biRISC-V, поддерживая все варианты умножения согласно стандарту RISC-V:

- Обычное умножение (MUL)
- Умножение с получением старшей части результата (MULH)
- Смешанные знаковые варианты (MULHSU)
- Беззнаковое умножение (MULHU)

Параметры модуля

| Параметр         | Описание |
|------------------|----------|
| `MULT_STAGES`    | Количество конвейерных стадий (2 или 3) |

Входные сигналы

| Сигнал                | Размерность | Описание                        |
|-----------------------|-------------|---------------------------------|
| `clk_i`, `rst_i`      | 1 бит       | Такт и сброс                    |
| `opcode_*`            | Различная   | Информация о текущей инструкции |
| `opcode_ra_operand_i` | 32 бита     | Первый операнд (rs1)            |
| `opcode_rb_operand_i` | 32 бита     | Второй операнд (rs2)            |
| `hold_i`              | 1 бит       | Сигнал остановки конвейера      |

Выходные сигналы

| Сигнал               | Размерность | Описание            |
|----------------------|-------------|---------------------|
| `writeback_value_o`  | 32 бита     | Результат умножения |

Поддерживаемые инструкции

| Инструкция | Описание |
|------------|----------|
| `MUL`      | Умножение (младшие 32 бита) |
| `MULH`     | Умножение со знаком (старшие 32 бита) |
| `MULHSU`   | Умножение rs1 со знаком, rs2 без знака (старшие 32 бита) |
| `MULHU`    | Умножение без знака (старшие 32 бита) |

Внутренняя структура

Ключевые регистры:

- `operand_a_e1_q`, `operand_b_e1_q` - входные операнды (33 бита с учетом знака)
- `mulhi_sel_e1_q` - флаг выбора старшей части результата
- `result_e2_q`, `result_e3_q` - конвейерные регистры результата

Основные логические блоки:

1. **Подготовка операндов**:
   - Для `MULHSU`: rs1 со знаком (33 бита), rs2 без знака (32 бита + 0)
   - Для `MULH`: оба операнда со знаком (33 бита)
   - Для `MUL`/`MULHU`: оба операнда без знака (32 бита + 0)

2. **Умножение**:
   - 33-битные операнды расширяются до 65 бит с учетом знака
   - Выполняется умножение 65x65 бит (`mult_result_w`)

3. **Выбор результата**:
   - Для `MUL`: младшие 32 бита (`mult_result_w32 бита`)
   - Для остальных инструкций: старшие 32 бита (`mult_result_w[63:32]`)

Особенности реализации

1. **Конвейеризация**:
   - Поддерживает 2 или 3 стадии конвейера (задается параметром `MULT_STAGES`)
   - Регистры `result_e2_q` и `result_e3_q` обеспечивают конвейерную обработку

2. **Обработка знаков**:
   - Корректно обрабатывает все комбинации знаковых и беззнаковых операндов
   - Использует расширение знака при необходимости

3. **Управление потоком**:
   - Учитывает сигнал `hold_i` для остановки конвейера
   - Сбрасывает промежуточные регистры по сигналу `rst_i`

4. **Эффективность**:
   - Оптимизированная реализация умножения с минимальным количеством стадий
   - Поддерживает все варианты умножения RISC-V в одном модуле

Модуль обеспечивает полную поддержку стандарта RISC-V для операций умножения с гибкой настройкой глубины конвейера.

###### 8 exec

Модуль biriscv_exec отвечает за выполнение инструкций в процессоре biRISC-V. Он реализует основные арифметико-логические операции и определяет поведение ветвлений, включая переходы, вызовы подпрограмм и возвраты.

Входные сигналы

| Название сигнала         | Разрядность | Описание                                                       |
|--------------------------|-------------|----------------------------------------------------------------|
| `clk_i`                  | 1 бит       | Тактовый сигнал                                                |
| `rst_i`                  | 1 бит       | Сброс                                                          |
| `opcode_valid_i`         | 1 бит       | Флаг валидности инструкции                                     |
| `opcode_opcode_i`        | 32 бита     | Код инструкции                                                 |
| `opcode_pc_i`            | 32 бита     | Программный счётчик                                            |
| `opcode_invalid_i`       | 1 бит       | Флаг невалидной инструкции                                     |
| `opcode_rd_idx_i`        | 5 бит       | Индекс регистра назначения (rd)                                |
| `opcode_ra_idx_i`        | 5 бит       | Индекс исходного регистра A (ra)                               |
| `opcode_rb_idx_i`        | 5 бит       | Индекс исходного регистра B (rb)                               |
| `opcode_ra_operand_i`    | 32 бита     | Операнд из регистра A                                          |
| `opcode_rb_operand_i`    | 32 бита     | Операнд из регистра B                                          |
| `hold_i`                 | 1 бит       | Удержание/заморозка канала                                     |

Выходные сигналы

| Название сигнала         | Разрядность | Описание                                                       |
|--------------------------|-------------|----------------------------------------------------------------|
| `branch_request_o`       | 1 бит       | Запрос на переход                                              |
| `branch_is_taken_o`      | 1 бит       | Переход будет выполнен                                         |
| `branch_is_not_taken_o`  | 1 бит       | Переход не будет выполнен                                      |
| `branch_source_o`        | 32 бита     | Адрес источника перехода                                       |
| `branch_is_call_o`       | 1 бит       | Признак вызова подпрограммы                                    |
| `branch_is_ret_o`        | 1 бит       | Признак возврата из подпрограммы                               |
| `branch_is_jmp_o`        | 1 бит       | Признак безусловного перехода                                  |
| `branch_pc_o`            | 32 бита     | Адрес назначения перехода                                      |
| `branch_d_request_o`     | 1 бит       | Запрос отложенного перехода                                    |
| `branch_d_pc_o`          | 32 бита     | Адрес назначения отложенного перехода                          |
| `branch_d_priv_o`        | 2 бита      | Уровень привилегий отложенного перехода                        |
| `writeback_value_o`      | 32 бита     | Значение для записи в регистр                                  |

Поддерживаемые инструкции

Арифметико-логические

- `ADD`, `SUB`, `AND`, `OR`, `XOR`
- `SLT`, `SLTU`
- `SLL`, `SRL`, `SRA`
- `ADDI`, `ANDI`, `ORI`, `XORI`, `SLTI`, `SLTIU`
- `SLLI`, `SRLI`, `SRAI`
- `LUI`, `AUIPC`

Ветвления и переходы

- `BEQ`, `BNE`, `BLT`, `BGE`, `BLTU`, `BGEU`
- `JAL`, `JALR`

###### 8.1 alu

Модуль `biriscv_alu` реализует арифметико-логическое устройство (ALU) для процессора biRISC-V. Он поддерживает основные арифметические, логические и сдвиговые операции, а также операции сравнения. ALU выбирает нужную операцию на основе входного сигнала `alu_op_i` и производит вычисление над операндами `alu_a_i` и `alu_b_i`.

Входные сигналы

| Сигнал      | Разрядность | Описание                                           |
|-------------|-------------|----------------------------------------------------|
| `alu_op_i`  | 4 бита      | Код операции ALU                                   |
| `alu_a_i`   | 32 бита     | Первый операнд                                     |
| `alu_b_i`   | 32 бита     | Второй операнд                                     |

Выходные сигналы

| Сигнал      | Разрядность | Описание                                           |
|-------------|-------------|----------------------------------------------------|
| `alu_p_o`   | 32 бита     | Результат операции                                 |

Поддерживаемые операции

- `ALU_SHIFTL` — логический сдвиг влево  
- `ALU_SHIFTR` — логический сдвиг вправо  
- `ALU_SHIFTR_ARITH` — арифметический сдвиг вправо (с заполнением старших битов)  
- `ALU_ADD` — сложение  
- `ALU_SUB` — вычитание  
- `ALU_AND` — побитовая И  
- `ALU_OR` — побитовая ИЛИ  
- `ALU_XOR` — побитовая исключающая ИЛИ  
- `ALU_LESS_THAN` — сравнение «меньше» без учета знака  
- `ALU_LESS_THAN_SIGNED` — сравнение «меньше» с учетом знака  

 Особенности реализации

- Сдвиги реализуются вручную с помощью каскада регистров, что обеспечивает точный контроль над заполнением бит при логических и арифметических сдвигах.  
- Арифметические операции выполняются напрямую через стандартные операторы Verilog.  
- Сравнения учитывают знаковость операндов и используют результат вычитания для определения результата.  
- При неопознанном коде операции ALU возвращает значение первого операнда (`alu_a_i`) по умолчанию.  

Данный модуль используется для выполнения арифметических, логических и сдвиговых операций в процессе исполнения инструкций ALU в ядре процессора biRISC-V.

#### Реализация с TCM памятью

##### tcm_top

###### 1 tcm_mem

Управляет TCM-памятью, включая доступ к данным (RAM) и инструкциям (PMEM). Поддерживает интерфейсы для ядра и AXI.

Входные сигналы

| Сигнал                  | Разрядность | Описание                                                                 |
|-------------------------|-------------|--------------------------------------------------------------------------|
| `clk_i`                 | 1 бит       | Тактовый сигнал                                                         |
| `rst_i`                 | 1 бит       | Асинхронный сброс (активный высокий уровень)                            |
| `mem_i_rd_i`            | 1 бит       | Запрос чтения инструкции                                                |
| `mem_i_flush_i`         | 1 бит       | Сигнал сброса кэша инструкций                                           |
| `mem_i_invalidate_i`    | 1 бит       | Инвалидация кэша инструкций                                             |
| `mem_i_pc_i`            | 32 бита     | Адрес инструкции (Program Counter)                                      |
| `mem_d_addr_i`          | 32 бита     | Адрес данных                                                            |
| `mem_d_data_wr_i`       | 32 бита     | Данные для записи                                                       |
| `mem_d_rd_i`            | 1 бит       | Флаг чтения данных                                                      |
| `mem_d_wr_i`            | 4 бита      | Маска записи (по байтам)                                                |
| `mem_d_cacheable_i`     | 1 бит       | Флаг кешируемости                                                       |
| `mem_d_req_tag_i`       | 11 бит      | Тег запроса                                                             |
| `mem_d_invalidate_i`    | 1 бит       | Инвалидация кэша данных                                                 |
| `mem_d_writeback_i`     | 1 бит       | Запрос обратной записи (writeback)                                      |
| `mem_d_flush_i`         | 1 бит       | Сброс кэша данных                                                       |
| `axi_awvalid_i`         | 1 бит       | Валидность адреса записи AXI                                            |
| `axi_awaddr_i`          | 32 бита     | AXI-адрес записи                                                        |
| `axi_awid_i`            | 4 бита      | AXI-ID транзакции записи                                                |
| `axi_awlen_i`           | 8 бит       | Длина burst-записи                                                      |
| `axi_awburst_i`         | 2 бита      | Тип burst-записи (00-FIXED, 01-INCR, 10-WRAP)                           |
| `axi_wvalid_i`          | 1 бит       | Валидность данных записи                                                |
| `axi_wdata_i`           | 32 бита     | AXI-данные записи                                                       |
| `axi_wstrb_i`           | 4 бита      | Маска записи AXI                                                        |
| `axi_wlast_i`           | 1 бит       | Флаг последнего пакета в burst                                          |
| `axi_bready_i`          | 1 бит       | Готовность принять ответ записи                                         |
| `axi_arvalid_i`         | 1 бит       | Валидность адреса чтения AXI                                            |
| `axi_araddr_i`          | 32 бита     | AXI-адрес чтения                                                        |
| `axi_arid_i`            | 4 бита      | AXI-ID транзакции чтения                                                |
| `axi_arlen_i`           | 8 бит       | Длина burst-чтения                                                      |
| `axi_arburst_i`         | 2 бита      | Тип burst-чтения                                                        |
| `axi_rready_i`          | 1 бит       | Готовность принять данные чтения                                        |

ВЫходные сигналы

| Сигнал                  | Разрядность | Описание                                                                |
|-------------------------|-------------|-------------------------------------------------------------------------|
| `mem_i_accept_o`        | 1 бит       | Подтверждение приёма запроса                                            |
| `mem_i_valid_o`         | 1 бит       | Валидность данных инструкции                                            |
| `mem_i_error_o`         | 1 бит       | Ошибка при чтении инструкции                                            |
| `mem_i_inst_o`          | 64 бита     | Прочитанная инструкция (64-бит для поддержки сдвоенных инструкций)      |
| `mem_d_data_rd_o`       | 32 бита     | Прочитанные данные                                                      |
| `mem_d_accept_o`        | 1 бит       | Подтверждение приёма запроса                                            |
| `mem_d_ack_o`           | 1 бит       | Подтверждение выполнения операции                                       |
| `mem_d_error_o`         | 1 бит       | Ошибка при операции с данными                                           |
| `mem_d_resp_tag_o`      | 11 бит      | Тег ответа                                                              |
| `axi_awready_o`         | 1 бит       | Готовность принять адрес записи                                         |
| `axi_wready_o`          | 1 бит       | Готовность принять данные записи                                        |
| `axi_bvalid_o`          | 1 бит       | Валидность ответа записи                                                |
| `axi_bresp_o`           | 2 бита      | Статус ответа записи (00-OK, 01-ERR, 10-SLVERR, 11-DECERR)              |
| `axi_bid_o`             | 4 бита      | ID ответа записи                                                        |
| `axi_arready_o`         | 1 бит       | Готовность принять адрес чтения                                         |
| `axi_rvalid_o`          | 1 бит       | Валидность данных чтения                                                |
| `axi_rdata_o`           | 32 бита     | AXI-данные чтения                                                       |
| `axi_rresp_o`           | 2 бита      | Статус чтения                                                           |
| `axi_rid_o`             | 4 бита      | ID ответа чтения                                                        |
| `axi_rlast_o`           | 1 бит       | Флаг последнего пакета в burst-чтении                                   |

Логика работы:
Мультиплексирует доступ к RAM между ядром и AXI.
Инструкции читаются через отдельный порт (mem_i_pc_i).

###### 1.1 tcm_mem_pmem

Dual-port RAM (64 КБ) для хранения данных. Один порт — для ядра, второй — для AXI.

Входные сигналы:

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| clk_i               | 1 бит       | Тактовый сигнал                   |
| rst_i               | 1 бит       | Сигнал сброса                     |
| axi_awaddr_i        | 32 бита     | AXI-адрес записи                  |
| axi_arlen_i         | 8 бит       | Длина burst-чтения                |
| axi_awburst_i       | 2 бита      | Тип burst-записи                  |

Выходные сигналы

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| ram_addr_o          | 32 бита     | Адрес для RAM                     |
| ram_wr_o            | 4 бита      | Маска записи                      |
| axi_rdata_o         | 32 бита     | Данные чтения AXI                 |

###### 1.2 tcm_mem_ram

Обрабатывает AXI-транзакции для TCM-памяти. Поддерживает burst-доступ (INCR, WRAP).

Входные сигналы:

| Сигнал               | Разрядность | Описание                          |
|----------------------|-------------|-----------------------------------|
| clk0_i               | 1 бит       | Такт порта 0                      |
| clk1_i               | 1 бит       | Такт порта 1                      |
| addr0_i              | 13 бит      | Адрес порта 0                     |
| addr1_i              | 13 бит      | Адрес порта 1                     |
| wr1_i                | 8 бит       | Маска записи порта 1              |

Выходные сигналы

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| data0_o             | 64 бита     | Данные порта 0                    |
| data1_o             | 65 бита     | Данные порта 1                    |

Логика работы:

Обрабатывает AXI-запросы, преобразуя их в последовательные обращения к RAM.
Поддерживает приоритет между чтением и записью (round-robin).

###### 2 dport_mux

Назначение:
Мультиплексирует доступ к памяти между TCM (Tightly Coupled Memory) и внешней памятью (через AXI). Определяет, куда направлять запросы: в быструю TCM-память или внешнюю шину.

Входные сигналы:

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| clk_i               | 1 бит       | Тактовый сигнал                   |
| rst_i               | 1 бит       | Сигнал сброса                     |
| mem_addr_i          | 32 бита     | Адрес памяти от ядра              |
| mem_rd_i            | 1 бит       | Флаг чтения                       |
| mem_wr_i            | 4 бита      | Маска записи                      |
| mem_cacheable_i     | 1 бит       | Флаг кешируемости                 |
| mem_tcm_data_rd_i   | 32 бита     | Данные из TCM                     |
| mem_ext_data_rd_i   | 32 бита     | Данные из внешней памяти          |

Выходные сигналы

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| mem_data_rd_o       | 32 бита     | Результирующие данные             |
| mem_accept_o        | 1 бит       | Подтверждение приёма              |
| mem_tcm_rd_o        | 1 бит       | Чтение TCM                        |
| mem_ext_rd_o        | 1 бит       | Чтение внешней памяти             |

Логика работы:

Проверяет адрес mem_addr_i на принадлежность к TCM (TCM_MEM_BASE).
Направляет запросы в TCM, если адрес в её диапазоне, иначе — во внешнюю память.
Поддерживает очередь pending-запросов для избежания конфликтов.

###### 3 dport_axi

Адаптирует интерфейс процессора (чтение/запись) к AXI-шине для доступа к внешней памяти. Поддерживает буферизацию запросов.

Ключевые сигналы:

| Сигнал              | Разрядность | Описание                          |
|---------------------|-------------|-----------------------------------|
| clk_i               | 1 бит       | Тактовый сигнал                   |
| rst_i               | 1 бит       | Сигнал сброса                     |
| mem_addr_i          | 32 бита     | Адрес запроса                     |
| mem_data_wr_i       | 32 бита     | Данные для записи                 |
| mem_rd_i            | 1 бит       | Флаг чтения                       |
| axi_rdata_i         | 32 бита     | Данные чтения AXI                 |
| mem_data_rd_o       | 32 бита     | Данные для процессора             |
| axi_awvalid_o       | 1 бит       | Валидность адреса записи          |
| axi_awaddr_o        | 32 бита     | AXI-адрес записи                  |
| axi_wdata_o         | 32 бита     | AXI-данные записи                 |

Логика работы:

- Использует FIFO (u_req, u_resp) для буферизации запросов и ответов.
- Поддерживает 1 outstanding-транзакцию (ожидающий запрос).
- Преобразует простые запросы в AXI-транзакции (чтение/запись, burst-доступ).

#### Реализация с ОЗУ

##### top

Архитектура RTL-процессора имеет следующую иерархическую структуру:

riscv_core[с общими модулями]
├── dcache
│ ├── dcache_if_pmem
│ │ └── dcache_if_pmem_fifo
│ ├── dcache_mux
│ ├── dcache_core
│ │ ├── dcache_core_tag_ram_0
│ │ ├── dcache_core_tag_ram_1
│ │ ├── dcache_core_data_ram_0
│ │ └── dcache_core_data_ram_1
│ ├── dcache_axi
│ │ ├──        dcache_axi_fifo
│ │ └──        dcache_axi_axi
│ └── dcache_pmem_mux
└── icache
    ├── icache_tag_ram_0
    ├── icache_tag_ram_1
    ├── icache_data_ram_0
    └── icache_data_ram_1

###### 1 icache

Модуль `icache` реализует 2-канальный кэш инструкций объемом 16 КБ с размером строки 32 байта. Используется ограниченная псевдослучайная стратегия вытеснения. Поддерживаются функции чтения инструкций, очистки кэша и инвалидирования по адресу.

Параметры

| Имя параметра | Разрядность | Описание                     |
|---------------|-------------|------------------------------|
| `AXI_ID`      | 4 бита      | Идентификатор AXI транзакции |

Входы

| Сигнал             | Разрядность | Описание                               |
|--------------------|-------------|----------------------------------------|
| `clk_i`            | 1 бит       | Тактовый сигнал                        |
| `rst_i`            | 1 бит       | Асинхронный сброс                      |
| `req_rd_i`         | 1 бит       | Запрос на чтение инструкции            |
| `req_flush_i`      | 1 бит       | Запрос на полную очистку кеша          |
| `req_invalidate_i` | 1 бит       | Запрос на инвалидирование по адресу    |
| `req_pc_i`         | 32 бита     | Адрес инструкции                       |
| `axi_awready_i`    | 1 бит       | AXI: готовность принять адрес записи   |
| `axi_wready_i`     | 1 бит       | AXI: готовность принять данные записи  |
| `axi_bvalid_i`     | 1 бит       | AXI: данные записи валидны             |
| `axi_bresp_i`      | 2 бита      | AXI: ответ записи                      |
| `axi_bid_i`        | 4 бита      | AXI: ID ответа записи                  |
| `axi_arready_i`    | 1 бит       | AXI: готовность принять адрес чтения   |
| `axi_rvalid_i`     | 1 бит       | AXI: данные чтения валидны             |
| `axi_rdata_i`      | 32 бита     | AXI: принятые данные                   |
| `axi_rresp_i`      | 2 бита      | AXI: ответ чтения                      |
| `axi_rid_i`        | 4 бита      | AXI: ID ответа чтения                  |
| `axi_rlast_i`      | 1 бит       | AXI: признак последнего слова          |

Выходы

| Сигнал             | Разрядность | Описание                                |
|--------------------|-------------|-----------------------------------------|
| `req_accept_o`     | 1 бит       | Запрос принят                           |
| `req_valid_o`      | 1 бит       | Данные инструкции валидны               |
| `req_error_o`      | 1 бит       | Произошла ошибка                        |
| `req_inst_o`       | 64 бита     | Полученная инструкция                   |
| `axi_awvalid_o`    | 1 бит       | AXI: адрес записи валиден               |
| `axi_awaddr_o`     | 32 бита     | AXI: адрес записи                       |
| `axi_awid_o`       | 4 бита      | AXI: ID запроса записи                  |
| `axi_awlen_o`      | 8 бит       | AXI: длина burst-записи                 |
| `axi_awburst_o`    | 2 бита      | AXI: тип burst-записи                   |
| `axi_wvalid_o`     | 1 бит       | AXI: данные записи валидны              |
| `axi_wdata_o`      | 32 бита     | AXI: данные записи                      |
| `axi_wstrb_o`      | 4 бита      | AXI: маска записи                       |
| `axi_wlast_o`      | 1 бит       | AXI: последняя запись                   |
| `axi_bready_o`     | 1 бит       | AXI: готовность принять ответ записи    |
| `axi_arvalid_o`    | 1 бит       | AXI: адрес чтения валиден               |
| `axi_araddr_o`     | 32 бита     | AXI: адрес чтения                       |
| `axi_arid_o`       | 4 бита      | AXI: ID запроса чтения                  |
| `axi_arlen_o`      | 8 бит       | AXI: длина burst-чтения                 |
| `axi_arburst_o`    | 2 бита      | AXI: тип burst-чтения                   |
| `axi_rready_o`     | 1 бит       | AXI: готовность принять данные чтения   |

###### 1.1 icache_tag_ram

Модуль `icache_tag_ram` представляет собой однопортовую синхронную RAM, реализующую хранение тегов кэша инструкций.

Назначение

Хранит 256 записей тегов, каждая длиной 20 бит. Обеспечивает доступ к тегу по адресу.

Входы

| Сигнал   | Разрядность | Описание                                  |
|----------|-------------|-------------------------------------------|
| `clk_i`  | 1 бит       | Тактовый сигнал                           |
| `rst_i`  | 1 бит       | Сброс                                     |
| `addr_i` | 8 бит      | Адрес строки в кэше                       |
| `data_i` | 20 бит      | Данные для записи                         |
| `wr_i`   | 1 бит       | Сигнал записи                             |

Выходы

| Сигнал   | Разрядность | Описание                                  |
|----------|-------------|-------------------------------------------|
| `data_o` | 20 бит      | Прочитанные данные из памяти              |

###### 1.2 icache_data_ram

Модуль `icache_data_ram` реализует однопортовую RAM объёмом 8 КБ для хранения данных кэша инструкций.всего 1024 строки.

Входы

| Сигнал   | Разрядность | Описание                                      |
|----------|-------------|-----------------------------------------------|
| `clk_i`  | 1 бит       | Тактовый сигнал                               |
| `rst_i`  | 1 бит       | Сброс                                         |
| `addr_i` | 10 бит      | Адрес строки данных кеша                      |
| `data_i` | 64 бита     | Данные для записи                             |
| `wr_i`   | 1 бит       | Сигнал записи                                 |

Выходы

| Сигнал   | Разрядность | Описание                                      |
|----------|-------------|-----------------------------------------------|
| `data_o` | 64 бита     | Прочитанные данные из памяти                  |

###### 2 dcache

`dcache` — это модуль кэша данных, который обслуживает запросы от процессора. Он разделяет запросы на кэшируемые и некэшируемые, обрабатывает их соответствующими подмодулями и взаимодействует с внешней памятью через AXI-интерфейс.

Параметры

| Сигнал   | Описание                |
|----------|-------------------------|
| AXI_ID   | ID для AXI-интерфейса   |

Входы

| Сигнал              | Размерность | Описание                                 |
|---------------------|-------------|------------------------------------------|
| `clk_i`             | 1 бит       | Тактовый сигнал                          |
| `rst_i`             | 1 бит       | Сигнал сброса                            |
| `mem_addr_i`        | 32 бита     | Адрес памяти                             |
| `mem_data_wr_i`     | 32 бита     | Данные для записи                        |
| `mem_rd_i`          | 1 бит       | Флаг запроса на чтение                   |
| `mem_wr_i`          | 4 бита      | Байт-энейблы для записи                  |
| `mem_cacheable_i`   | 1 бит       | Флаг: кэшируемый ли доступ               |
| `mem_req_tag_i`     | 11 бит      | Тег запроса                              |
| `mem_invalidate_i`  | 1 бит       | Запрос инвалидации кэша                  |
| `mem_writeback_i`   | 1 бит       | Запрос writeback                         |
| `mem_flush_i`       | 1 бит       | Запрос flush                             |

Выходы

| Сигнал              | Размерность | Описание                                 |
|---------------------|-------------|------------------------------------------|
| `mem_data_rd_o`     | 32 бита     | Данные, считанные из памяти              |
| `mem_accept_o`      | 1 бит       | Готовность к приему нового запроса       |
| `mem_ack_o`         | 1 бит       | Подтверждение завершения операции        |
| `mem_error_o`       | 1 бит       | Ошибка при выполнении запроса            |
| `mem_resp_tag_o`    | 11 бит      | Тег ответа                               |

###### 2.1 dcache_if_pmem

Модуль `dcache_if_pmem` выступает в роли интерфейса между кэшом данных (`dcache`) и внешним AXI-интерфейсом, обеспечивая передачу некэшируемых транзакций. Поддерживает одну активную транзакцию одновременно, но может буферизовать до 2 запросов.

Входы

| Сигнал                 | Размерность | Описание                                    |
|------------------------|-------------|---------------------------------------------|
| `clk_i`                | 1 бит       | Тактовый сигнал                             |
| `rst_i`                | 1 бит       | Сброс                                       |
| `mem_addr_i`           | 32 бита     | Адрес запроса от CPU                        |
| `mem_data_wr_i`        | 32 бита     | Данные для записи                           |
| `mem_rd_i`             | 1 бит       | Флаг чтения                                 |
| `mem_wr_i`             | 4 бита      | Байт-энейблы для записи                     |
| `mem_cacheable_i`      | 1 бит       | Флаг кэшируемости                           |
| `mem_req_tag_i`        | 11 бит      | Тег запроса от CPU                          |
| `mem_invalidate_i`     | 1 бит       | Инвалидация                                 |
| `mem_writeback_i`      | 1 бит       | Writeback                                   |
| `mem_flush_i`          | 1 бит       | Flush                                       |
| `outport_accept_i`     | 1 бит       | Готовность интерфейса принять команду       |
| `outport_ack_i`        | 1 бит       | Подтверждение завершения операции           |
| `outport_error_i`      | 1 бит       | Флаг ошибки от внешнего интерфейса          |
| `outport_read_data_i`  | 32 бита     | Прочитанные данные от внешнего интерфейса   |

Выходы

| Сигнал                 | Размерность | Описание                                    |
|------------------------|-------------|---------------------------------------------|
| `mem_data_rd_o`        | 32 бита     | Данные, прочитанные из памяти               |
| `mem_accept_o`         | 1 бит       | Готовность модуля принять новый запрос      |
| `mem_ack_o`            | 1 бит       | Подтверждение завершения запроса            |
| `mem_error_o`          | 1 бит       | Флаг ошибки выполнения запроса              |
| `mem_resp_tag_o`       | 11 бит      | Ответный тег, совпадает с `mem_req_tag_i`   |
| `outport_wr_o`         | 4 бита      | Байт-энейблы для записи                     |
| `outport_rd_o`         | 1 бит       | Сигнал чтения                               |
| `outport_len_o`        | 8 бит       | Длина транзакции                            |
| `outport_addr_o`       | 32 бита     | Адрес доступа                               |
| `outport_write_data_o` | 32 бита     | Данные для записи                           |

Особенности

- Поддержка до **2 буферизованных** запросов
- Только **1 активная транзакция**
- Автоматическая обработка команд `invalidate`, `flush`, `writeback`
- Простая логика чтения/записи через FIFO и регистры
- Независимость от флага `mem_cacheable_i`

###### 2.2 dcache_pmem_mux

Модуль `dcache_pmem_mux` — мультиплексор, который переключает два входных интерфейса данных и управления  на один выходной интерфейс, а также распределяет ответы и ошибки обратно к соответствующему входу в зависимости от сигнала выбора `select_i`.

Входы

| Сигнал                  | Разрядность    | Описание                            |
|-------------------------|----------------|-------------------------------------|
| `clk_i`                 | 1 бит          | Тактовый сигнал                     |
| `rst_i`                 | 1 бит          | Сигнал сброса                       |
| `outport_accept_i`      | 1 бит          | Прием запроса внешним интерфейсом   |
| `outport_ack_i`         | 1 бит          | Подтверждение от внешнего интерфейса|
| `outport_error_i`       | 1 бит          | Ошибка от внешнего интерфейса       |
| `outport_read_data_i`   | 32 бита        | Данные чтения от внешнего интерфейса|

Выходы

| Сигнал                  | Разрядность    | Описание                            |
|-------------------------|----------------|-------------------------------------|
| `outport_wr_o`          | 4 бита         | Маска байтов записи                 |
| `outport_rd_o`          | 1 бит          | Запрос на чтение                    |
| `outport_len_o`         | 8 бит          | Длина данных                        |
| `outport_addr_o`        | 32 бита        | Адрес доступа                       |
| `outport_write_data_o`  | 32 бита        | Данные для записи                   |

###### 2.3 dcache_mux

Модуль `dcache_mux` выполняет маршрутизацию запросов между кэшируемыми и некэшируемыми интерфейсами памяти. Он определяет направление запроса на основе сигнала `mem_cacheable_i`, а также отслеживает активность и состояние запросов. Входящие команды направляются как в кэш, так и в обход кэша, а выходные ответы — мультиплексируются обратно к процессоору.

Входы

| Сигнал                      | Разрядность | Описание                                                   |
|-----------------------------|-------------|------------------------------------------------------------|
| `clk_i`                     | 1 бит       | Тактовый сигнал                                            |
| `rst_i`                     | 1 бит       | Сигнал синхронного сброса                                  |
| `mem_addr_i`                | 32 бита     | Адрес памяти запроса                                       |
| `mem_data_wr_i`             | 32 бита     | Данные для записи                                          |
| `mem_rd_i`                  | 1 бит       | Сигнал чтения                                              |
| `mem_wr_i`                  | 4 бита      | Маска байтов записи                                        |
| `mem_cacheable_i`           | 1 бит       | Признак кэшируемости запроса                               |
| `mem_req_tag_i`             | 11 бит      | Тег запроса                                                |
| `mem_invalidate_i`          | 1 бит       | Запрос на инвалидирование кэша                             |
| `mem_writeback_i`           | 1 бит       | Запрос на запись из кэша в память                          |
| `mem_flush_i`               | 1 бит       | Запрос на очистку кэша                                     |
| `mem_cached_data_rd_i`      | 32 бита     | Данные от кэшируемого интерфейса памяти                    |
| `mem_cached_accept_i`       | 1 бит       | Готовность принять запрос от кэшируемого интерфейса        |
| `mem_cached_ack_i`          | 1 бит       | Подтверждение от кэшируемого интерфейса                    |
| `mem_cached_error_i`        | 1 бит       | Ошибка от кэшируемого интерфейса                           |
| `mem_cached_resp_tag_i`     | 11 бит      | Тег ответа от кэшируемого интерфейса                       |
| `mem_uncached_data_rd_i`    | 32 бита     | Данные от некэшируемого интерфейса памяти                  |
| `mem_uncached_accept_i`     | 1 бит       | Готовность принять запрос от некэшируемого интерфейса      |
| `mem_uncached_ack_i`        | 1 бит       | Подтверждение от некэшируемого интерфейса                  |
| `mem_uncached_error_i`      | 1 бит       | Ошибка от некэшируемого интерфейса                         |
| `mem_uncached_resp_tag_i`   | 11 бит      | Тег ответа от некэшируемого интерфейса                     |

Выходы

| Сигнал                       | Разрядность | Описание                                      |
|------------------------------|-------------|-----------------------------------------------|
| `mem_data_rd_o`              | 32 бита     | Данные ответа для процессора                  |
| `mem_accept_o`               | 1 бит       | Готовность интерфейса принять запрос          |
| `mem_ack_o`                  | 1 бит       | Подтверждение завершения запроса              |
| `mem_error_o`                | 1 бит       | Сигнал ошибки запроса                         |
| `mem_resp_tag_o`             | 11 бит      | Тег ответа для идентификации запроса          |
| `cache_active_o`             | 1 бит       | Признак того, что активен кэш                 |
| `mem_cached_addr_o`          | 32 бита     | Адрес запроса                                 |
| `mem_cached_data_wr_o`       | 32 бита     | Данные для записи                             |
| `mem_cached_rd_o`            | 1 бит       | Сигнал чтения                                 |
| `mem_cached_wr_o`            | 4 бита      | Маска записи                                  |
| `mem_cached_cacheable_o`     | 1 бит       | Признак кэшируемости запроса                  |
| `mem_cached_req_tag_o`       | 11 бит      | Тег запроса                                   |
| `mem_cached_invalidate_o`    | 1 бит       | Сигнал на инвалидирование                     |
| `mem_cached_writeback_o`     | 1 бит       | Сигнал на запись из кэша                      |
| `mem_cached_flush_o`         | 1 бит       | Сигнал на очистку кэша                        |
| `mem_uncached_addr_o`        | 32 бита     | Адрес запроса                                 |
| `mem_uncached_data_wr_o`     | 32 бита     | Данные для записи                             |
| `mem_uncached_rd_o`          | 1 бит       | Сигнал чтения                                 |
| `mem_uncached_wr_o`          | 4 бита      | Маска записи                                  |
| `mem_uncached_cacheable_o`   | 1 бит       | Признак кэшируемости запроса                  |
| `mem_uncached_req_tag_o`     | 11 бит      | Тег запроса                                   |
| `mem_uncached_invalidate_o`  | 1 бит       | Сигнал на инвалидирование                     |
| `mem_uncached_writeback_o`   | 1 бит       | Сигнал на запись из кэша                      |
| `mem_uncached_flush_o`       | 1 бит       | Сигнал на очистку кэша                        |

- На основе сигнала `mem_cacheable_i` запрос направляется либо в кэш (`mem_cached_*`), либо в обход кэша (`mem_uncached_*`).
- Сигнал `hold_w` предотвращает смену типа запроса, пока не завершена предыдущая операция (проверка по `pending_q`).
- Переменная `cache_access_q` запоминает, к какому интерфейсу был отправлен текущий запрос.
- Ответы (`mem_data_rd_o`, `mem_ack_o`, `mem_error_o`, `mem_resp_tag_o`) выбираются в зависимости от источника запроса.
- Счётчик `pending_q` отслеживает количество активных запросов.
- Выход `cache_active_o` указывает, активен ли кэш сейчас, в зависимости от текущих или последних запросов.

###### 2.4 dcache_core

Модуль `dcache_core` реализует кэш данных с поддержкой операций чтения, записи, инвалидации и очистки. Он взаимодействует с процессором и внешней памятью.

Входы

| Сигнал                 | Ширина   | Описание                                              |
|------------------------|----------|--------------------------------------------------------|
| `clk_i`                | 1 бит    | Тактовый сигнал                                        |
| `rst_i`                | 1 бит    | Сигнал сброса                                          |
| `mem_addr_i`           | 32 бита  | Адрес обращения от процессора                         |
| `mem_data_wr_i`        | 32 бита  | Данные для записи                                     |
| `mem_rd_i`             | 1 бит    | Флаг чтения                                            |
| `mem_wr_i`             | 4 бита   | Побайтовая маска записи                                |
| `mem_cacheable_i`      | 1 бит    | Признак кэшируемости доступа                          |
| `mem_req_tag_i`        | 11 бит   | Идентификатор запроса                                 |
| `mem_invalidate_i`     | 1 бит    | Инвалидация строки кэша                               |
| `mem_writeback_i`      | 1 бит    | Принудительный write-back                             |
| `mem_flush_i`          | 1 бит    | Очистка всего кэша                                     |
| `outport_accept_i`     | 1 бит    | Внешняя память готова к приему                         |
| `outport_ack_i`        | 1 бит    | Подтверждение завершения операции                     |
| `outport_error_i`      | 1 бит    | Ошибка от внешней памяти                              |
| `outport_read_data_i`  | 32 бита  | Данные от внешней памяти                              |

Выходы

| Сигнал                  | Ширина   | Описание                                             |
|-------------------------|----------|-------------------------------------------------------|
| `mem_data_rd_o`         | 32 бита  | Прочитанные данные                                    |
| `mem_accept_o`          | 1 бит    | Готовность к приему нового запроса                    |
| `mem_ack_o`             | 1 бит    | Подтверждение завершения                              |
| `mem_error_o`           | 1 бит    | Ошибка при выполнении                                |
| `mem_resp_tag_o`        | 11 бит   | Тег ответа запроса                                   |
| `outport_wr_o`          | 4 бита   | Маска записи                                          |
| `outport_rd_o`          | 1 бит    | Сигнал чтения внешней памяти                          |
| `outport_len_o`         | 8 бит    | Длина burst-доступа                                  |
| `outport_addr_o`        | 32 бита  | Адрес внешнего обращения                             |
| `outport_write_data_o`  | 32 бита  | Данные для внешней памяти                            |

Функциональность

- **Кэширование данных**: с целью ускорения доступа.
- **Write-back**: поддержка сохранения изменённых данных во внешнюю память.
- **Invalidate / Flush**: ручная инвалидация строки или всего кэша.
- **Byte-enable запись**: поддержка маски байтов при записи.
- **Теги и индексирование**: адрес разбивается на тег, индекс и смещение.

###### 2.4.1 dcache_core_tag_ram

Модуль 
`dcache_core_tag_ram` - это двухпортовая синхронная память тегов для `dcache`, реализованная как RAM на 256 строк по 21 биту. Позволяет одновременное чтение и запись с разных тактовых доменов. Используется для хранения информации о валидности и теге строк кэша.

Входные сигналы

| Сигнал     | Разрядность | Описание                                        |
|------------|-------------|-------------------------------------------------|
| `clk0_i`   | 1 бит       | Тактовый сигнал для чтения                      |
| `rst0_i`   | 1 бит       | Сброс для порта чтения                          |
| `addr0_i`  | 8 бит       | Адрес строки для чтения                         |
| `clk1_i`   | 1 бит       | Тактовый сигнал для записи                      |
| `rst1_i`   | 1 бит       | Сброс для порта записи                          |
| `addr1_i`  | 8 бит       | Адрес строки для записи                         |
| `data1_i`  | 21 бит      | Данные для записи в память                      |
| `wr1_i`    | 1 бит       | Разрешение записи                               |

Выходные сигналы

| Сигнал     | Разрядность | Описание                                       |
|------------|-------------|------------------------------------------------|
| `data0_o`  | 21 бит      | Прочитанные данные по адресу `addr0_i`         |

Особенности

- **Тип памяти:** синхронная двухпортовая RAM
- **Размер:** 5376 бит
- **Режим доступа:** сначала выполняется запись, затем чтение
- **Порт чтения:** `clk0_i`, `addr0_i`, `data0_o`
- **Порт записи:** `clk1_i`, `addr1_i`, `data1_i`, `wr1_i`
- **Назначение:** хранение тегов кэш-линий и дополнительных флагов

###### 2.4.2 dcache_core_data_ram

Модуль `dcache_core_data_ram` - это двухпортовая синхронная память объёмом 8 КБ, предназначенная для хранения данных кэша. Позволяет выдавать одновременный доступ на чтение/запись с двух независимых портов.

Входные сигналы

| Сигнал       | Разрядность | Описание                                       |
|--------------|-------------|------------------------------------------------|
| `clk0_i`     | 1 бит       | Тактовый сигнал для порта 0                    |
| `rst0_i`     | 1 бит       | Сброс порта 0                                  |
| `addr0_i`    | 11 бит      | Адрес доступа к памяти по порту 0              |
| `data0_i`    | 32 бит      | Данные для записи по порту 0                   |
| `wr0_i`      | 4 бит       | Побайтовый сигнал записи по порту 0            |
| `clk1_i`     | 1 бит       | Тактовый сигнал для порта 1                    |
| `rst1_i`     | 1 бит       | Сброс порта 1                                  |
| `addr1_i`    | 11 бит      | Адрес доступа к памяти по порту 1              |
| `data1_i`    | 32 бит      | Данные для записи по порту 1                   |
| `wr1_i`      | 4 бит       | Побайтовый сигнал записи по порту 1            |

Выходные сигналы

| Сигнал     | Разрядность | Описание                                       |
|------------|-------------|------------------------------------------------|
| `data0_o`  | 32 бит      | Данные, прочитанные из памяти по порту 0       |
| `data1_o`  | 32 бит      | Данные, прочитанные из памяти по порту 1       |

Особенности

- **Тип памяти:** двухпортовая RAM
- **Объём:** 8 КБ
- **Режим чтения:** Read First - сначала чтение, затем запись
- **Побайтовая запись:** каждый бит `wrX_i` разрешает запись соответствующего байта
- поддержка двух разных клоков `clk0_i` и `clk1_i`

###### 2.5 dcache_axi

Модуль `dcache_axi` реализует взаимодействие между кэшом данных и внешней памятью через интерфейс AXI. Он буферизует запросы чтения и записи, поступающие от кэша, и обрабатывает их в соответствии с протоколом AXI. Используются подмодули `dcache_axi_fifo` и `dcache_axi_axi` для управления очередями и формированием AXI-транзакций.

Входные сигналы

| Сигнал                | Разрядность | Описание                             |
|-----------------------|-------------|--------------------------------------|
| `clk_i`               | 1 бит       | Тактовый сигнал                      |
| `rst_i`               | 1 бит       | Сброс                                |
| `inport_wr_i`         | 4 бита      | Маска записи по байтам               |
| `inport_rd_i`         | 1 бит       | Флаг запроса чтения                  |
| `inport_len_i`        | 8 бит       | Длина burst-передачи                 |
| `inport_addr_i`       | 32 бита     | Адрес операции                       |
| `inport_write_data_i` | 32 бита     | Данные для записи                    |
| `outport_awready_i`   | 1 бит       | AXI: готовность принять адрес записи |
| `outport_wready_i`    | 1 бит       | AXI: готовность принять данные       |
| `outport_bvalid_i`    | 1 бит       | AXI: подтверждение записи            |
| `outport_bresp_i`     | 2 бита      | AXI: статус ответа на запись         |
| `outport_bid_i`       | 4 бита      | AXI: ID ответа на запись             |
| `outport_arready_i`   | 1 бит       | AXI: готовность принять адрес чтения |
| `outport_rvalid_i`    | 1 бит       | AXI: валидные данные чтения          |
| `outport_rdata_i`     | 32 бита     | AXI: данные из памяти                |
| `outport_rresp_i`     | 2 бита      | AXI: статус ответа на чтение         |
| `outport_rid_i`       | 4 бита      | AXI: ID ответа на чтение             |
| `outport_rlast_i`     | 1 бит       | AXI: Последняя часть burst-чтения    |

Выходные сигналы

| Сигнал                | Разрядность | Описание                          |
|-----------------------|-------------|-----------------------------------|
| `inport_accept_o`     | 1 бит       | Запрос принят                     |
| `inport_ack_o`        | 1 бит       | Операция завершена                |
| `inport_error_o`      | 1 бит       | Произошла ошибка                  |
| `inport_read_data_o`  | 32 бита     | Данные из памяти при чтении       |
| `outport_awvalid_o`   | 1 бит       | AXI: адрес записи валиден         |
| `outport_awaddr_o`    | 32 бита     | AXI: адрес записи                 |
| `outport_awid_o`      | 4 бита      | AXI: ID запроса на запись         |
| `outport_awlen_o`     | 8 бит       | AXI: длина burst                  |
| `outport_awburst_o`   | 2 бита      | AXI: тип burst                    |
| `outport_wvalid_o`    | 1 бит       | AXI: данные для записи валидны    |
| `outport_wdata_o`     | 32 бита     | AXI: данные для записи            |
| `outport_wstrb_o`     | 4 бита      | AXI: маска записи по байтам       |
| `outport_wlast_o`     | 1 бит       | AXI: последний beat записи        |
| `outport_bready_o`    | 1 бит       | AXI: готов принять ответ записи   |
| `outport_arvalid_o`   | 1 бит       | AXI: адрес чтения валиден         |
| `outport_araddr_o`    | 32 бита     | AXI: адрес чтения                 |
| `outport_arid_o`      | 4 бита      | AXI: ID запроса на чтение         |
| `outport_arlen_o`     | 8 бит       | AXI: длина burst чтения           |
| `outport_arburst_o`   | 2 бита      | AXI: тип burst                    |
| `outport_rready_o`    | 1 бит       | AXI: готов принять данные         |

Логика работы

1. **Прием запроса**: модуль получает команду от кэша (`inport_rd_i` или `inport_wr_i`) и сохраняет ее в FIFO.
2. **Генерация транзакции**: при наличии запроса, `dcache_axi_axi` генерирует соответствующую AXI-транзакцию (`AR`, `AW`, `W`).
3. **Ожидание ответа**: модуль отслеживает приход подтверждения (`BVALID`/`RVALID`), после чего устанавливает флаг `inport_ack_o`.
4. **Обработка ошибок**: если `BRESP` или `RRESP` содержат ошибку — активируется `inport_error_o`.

###### 2.5.1 dcache_axi_axi

модуль реализует интерфейс AXI для работы с кэшем данных в системе на базе AXI-протокола.
Он выполняет функции промежуточного слоя между внутренним кэшем и внешним AXI-шиной, обеспечивая корректную передачу и прием данных и команд чтения/записи.

Входы

| Имя                 | Разрядность   | Описание                               |
|---------------------|---------------|----------------------------------------|
| `clk_i`             | 1 бит         | Тактовый сигнал                        |
| `rst_i`             | 1 бит         | Сигнал сброса                          |
| `inport_valid_i`    | 1 бит         | Входной сигнал валидности запроса      |
| `inport_write_i`    | 1 бит         | Тип операции: 1 — запись, 0 — чтение   |
| `inport_addr_i`     | 32 бита       | Адрес запроса                          |
| `inport_id_i`       | 4 бита        | ID транзакции                          |
| `inport_len_i`      | 8 бит         | Длина burst                            |
| `inport_burst_i`    | 2 бита        | Тип burst                              |
| `inport_wdata_i`    | 32 бита       | Данные для записи                      |
| `inport_wstrb_i`    | 4 бита        | Маска записи байтов                    |
| `inport_bready_i`   | 1 бит         | Готовность принять ответ записи        |
| `inport_rready_i`   | 1 бит         | Готовность принять данные чтения       |
| `outport_awready_i` | 1 бит         | Готовность slave принять адрес записи  |
| `outport_wready_i`  | 1 бит         | Готовность slave принять данные записи |
| `outport_bvalid_i`  | 1 бит         | Ответ на запись валиден                |
| `outport_bresp_i`   | 2 бита        | Ответ записи                           |
| `outport_bid_i`     | 4 бита        | ID транзакции записи                   |
| `outport_arready_i` | 1 бит         | Готовность slave принять адрес чтения  |
| `outport_rvalid_i`  | 1 бит         | Данные чтения валидны                  |
| `outport_rdata_i`   | 32 бита       | Данные чтения                          |
| `outport_rresp_i`   | 2 бита        | Ответ чтения                           |
| `outport_rid_i`     | 4 бита        | ID транзакции чтения                   |
| `outport_rlast_i`   | 1 бит         | Последний бит чтения                   |

Выходы

| Имя               | Разрядность   | Описание                              |
|-------------------|---------------|---------------------------------------|
| `inport_accept_o`   | 1 бит         | Принятие запроса                      |
| `inport_bvalid_o`   | 1 бит         | Ответ на запись валиден               |
| `inport_bresp_o`    | 2 бита        | Ответ записи                          |
| `inport_bid_o`      | 4 бита        | ID транзакции записи                  |
| `inport_rvalid_o`   | 1 бит         | Данные чтения валидны                 |
| `inport_rdata_o`    | 32 бита       | Данные чтения                         |
| `inport_rresp_o`    | 2 бита        | Ответ чтения                          |
| `inport_rid_o`      | 4 бита        | ID транзакции чтения                  |
| `inport_rlast_o`    | 1 бит         | Последний бит чтения                  |
| `outport_awvalid_o` | 1 бит         | Адрес записи валиден                  |
| `outport_awaddr_o`  | 32 бита       | Адрес записи                          |
| `outport_awid_o`    | 4 бита        | ID транзакции записи                  |
| `outport_awlen_o`   | 8 бит         | Длина burst записи                    |
| `outport_awburst_o` | 2 бита        | Тип burst записи                      |
| `outport_wvalid_o`  | 1 бит         | Данные записи валидны                 |
| `outport_wdata_o`   | 32 бита       | Данные записи                         |
| `outport_wstrb_o`   | 4 бита        | Маска байтов записи                   |
| `outport_wlast_o`   | 1 бит         | Последний beat записи                 |
| `outport_bready_o`  | 1 бит         | Готовность принять ответ записи       |
| `outport_arvalid_o` | 1 бит         | Адрес чтения валиден                  |
| `outport_araddr_o`  | 32 бита       | Адрес чтения                          |
| `outport_arid_o`    | 4 бита        | ID транзакции чтения                  |
| `outport_arlen_o`   | 8 бит         | Длина burst чтения                    |
| `outport_arburst_o` | 2 бита        | Тип burst чтения                      |
| `outport_rready_o`  | 1 бит         | Готовность принять данные чтения      |

## 3 Руководство по программированию

### 3.0 Введение
В этом разделе мы рассмотрим, как программировать под BiriscV. Изучим процесс сборки и запуска приложения, каким методом собирается программа, как она загружается в память и запускается. 

#### 3.0.1 Настройка окружения
Для программирования под BiriscV необходимо установить следующие инструменты:
- [RISC-V GCC Toolchain](https://github.com/stnolting/riscv-gcc-prebuilt). Скачать релиз для `rv32i` и распаковать его в место, которое надо добавить в $PATH
- SystemC. Установить следующей командой 
```bash
    wget https://github.com/accellera-official/systemc/archive/refs/tags/3.0.1.tar.gz && \
    tar -xvzf 3.0.1.tar.gz && rm 3.0.1.tar.gz && \
    cd systemc-3.0.1 && \
    mkdir objdir && cd objdir && \
    export CXX=g++ && \
    ../configure && make && make install && \
    cd .. && rm -rf objdir
```
- Verilator. Установить командой из [репозитория](https://github.com/verilator/verilator) 
```bash
git clone https://github.com/verilator/verilator
cd verilator
autoconf         # Create ./configure script
./configure      # Configure and create Makefile
make -j `nproc`  # Build Verilator itself (if error, try just 'make')
sudo make install
```

### 3.1 Запуск 

Процесс магии, что происходит за выполнением команды `make` в папке `sw` (что содержит примеры для выполнения) можно разделить на несколько этапов:
- **Компиляция**. GCC компилирует исходный код в объектный файл. Помимо компиляции .c файлов, также .S (с большой буквы) обрабатываются gcc и позволяют, например, подключать другой код используя `#include`
- **Линковка**. Линковщик объединяет множество объектных фалйов, а также динамические библиотеки в один исполняемый файл. Работа линковщика заключается также в том, чтобы указать адрес исполнения программы, а также адреса всех используемых разделов памяти. На выходе после линковщика получается ELF файл, который содержит все необходимые данные для загрузки в память и исполнения.
- **Загрузка**. ELF файл загружается в память и запускается

#### 3.1.1 Компиляция

Если из директории Make вызвать компиляцию примеров в директории `sw`, можно посмотреть с какими аргументами вызывается. Разберем сборку поподробнее

```bash
riscv64-unknown-elf-gcc \
    -march=rv32im_zicsr -mabi=ilp32   # целевая ISA и ABI
    -O2                               # оптимизация по скорости, без агрессивных трюков
    -g                                # отладочная информация (можно убрать для релиза)
    -nostartfiles -nostdlib           # не тянуть стандартный CRT-старт-ап и libc
    -T tcm.ld                         # скрипт линковки (или default.ld)
    -o hello.elf hello.c              # выходной ELF и исходники
    -L ../common                      # директория с библиотеками
    -lc -lm -lgcc -lsys               # минимальный набор библиотек
```

Директория `..\common`, помимо скриптов линковщика и общего Makefile, также содержит в себе и 
- ассемблерный файл `startup.S` для запуска -- инициализации системы, настройки обработки исключений и реализации базового механизма обработки различных типов прерываний. Этот код является важным низкоуровневым компонентом, который обеспечивает корректную инициализацию и базовую инфраструктуру обработки исключений, на которой строится дальнейшая работа системы. Скрипт линковщика задает функцию `_start` как точку входа программы
- заголовочный файл `rvconfig.h` -- содержит набор макросов для доступа к CSR-регистрам
- ассемблерный файл `syscall.S` -- реализация системных вызовов, которые позволяют взаимодействовать с операционной системой и выполнять низкоуровневые операции, такие как ввод-вывод. Стоит также обратить внимание, что вывод в консоль реализован так, что до появления символа перевода строки, все данные будут храниться в буфере

Также, уже после сборки, в папке сборки формируется дизасемблерованный файл посредством запуска `riscv64-unknown-elf-objdump -d hello.elf > hello.dis`, используя его можно изучить как была произведена сборка бинарника

#### 3.1.2 Линковка
*Линковка описана куда более подробно, из-за того, что она куда меньше знакома читателям*

> Линковщик (`linker`) -- инструмент, что собирает объектные `.o` файлы на выходе с ассемблера в единый исполняемый файл. Он должен удостовериться что все части сликнованны корректно 

![](Images/linker_scheme.png)
*Линковщик в процессе сборки*

Обычно, линковщик принимает участие
- в процессе компиляции, собирает весь код и библиотеки в один исполняемый файл
- в процессе загрузки программы в оперативную память, подгружая динамические библиотеки

##### Статическая линковка

Происходя во время комплияции программы, статическая линковка позволяет объеденить разрозненные файлы в один. После прохождения статической линковки, программа более не требует существования оригинальных .o файлов

Для упрощения, возьмем чистый ассемблер с двумя файлами -- `math.asm` и `main.asm`

```asm
global add        ; экспортируем функцию

section .text
add:
    ; int add(int a, int b)
    ; a в rdi, b в rsi
    mov rax, rdi   ; rax = a
    add rax, rsi   ; rax += b
    ret
```

```asm
extern add        ; импортируем функцию

section .text
global _start

_start:
    mov rdi, 5     ; первый аргумент (a)
    mov rsi, 7     ; второй аргумент (b)
    call add       ; вызвать внешнюю функцию

    ; Результат в rax, выведем его как exit-код
    mov rdi, rax   ; exit-код
    mov rax, 60    ; системный вызов exit
    syscall
```

Соберем эту программу, используя линковщик
```bash
nasm -f elf64 math.asm -o math.o
nasm -f elf64 main.asm -o main.o

ld main.o math.o -o program
```

И дизасэмблируем ее

```bash
$ objdump -d ./program 

./program:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <_start>:
  401000:       bf 05 00 00 00          mov    $0x5,%edi
  401005:       be 07 00 00 00          mov    $0x7,%esi
  40100a:       e8 11 00 00 00          callq  401020 <add>
  40100f:       48 89 c7                mov    %rax,%rdi
  401012:       b8 3c 00 00 00          mov    $0x3c,%eax
  401017:       0f 05                   syscall 
  401019:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000401020 <add>:
  401020:       48 89 f8                mov    %rdi,%rax
  401023:       48 01 f0                add    %rsi,%rax
  401026:       c3                      retq   
```

Видим, что функция add появилась внутри файла. А вызов заменился на вызов по определенному адрес (произошла реалокация)

Линковщик находит референсы на символы, и добавляет их в исходный файл. Отследить где конкретный символ был найден, можно используя `--trace-symbol <sym_name>`.


##### Динамическая линковка 
Динмаическая линковка, как и было описано ранее, происходит во время загрузки исполняемого кода в оперативную память. Именно из-за этого, например, запуск какой-нибудь executable почти на пустой системе без должного числа динамических библиотек невозможен. 

В репозитории с примерами также есть вариант статически зависимого кода от библиотеки `libcurl`. Он успешно соберется внутри отдельного dev docker образа, однако, из-за отсуствия этой динамической библиотеки в исполняемой среде запуститься не сможет

```bash
docker build -t curl-broken-runtime .
docker run --rm curl-broken-runtime
> ./main: error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory
```

Из этого примера очевидно основной плюс и основной минус статической линковки
- Сборка позволяет не подгружать на этапе компиляции в собранный файл тяжелые библиотеки. Помимо `libcurl` такой может являтся, например `libffmpeg` -- мощный комбайн для обработки медиа
- Из-за того, что библиотека подгружается динамически, ее отсуствие в другой среде не позволяет программе даже запуститься

Линковщик может реалоцировать и менять адреса "на лету", благодаря чему запуск идет корректно

Вот продолжение статьи, в том же стиле, на тему `.ld` файлов и конфигурации линковки:

##### Конфигурационные файлы линковщика (.ld)

> Файл линковки (`linker script` или `.ld`) — это специальный конфигурационный файл, который описывает, как линковщик должен разместить различные секции программы в памяти. Особенно важен при разработке низкоуровневого кода: embedded, OS kernel, bootloader, etc.
x
Линковщик по умолчанию умеет работать с простыми программами, размещая `.text`, `.data` и `.bss` в стандартные места. Но для системного программирования часто нужно полный контроль — и тут на сцену выходит `.ld` файл.

В репозитории, в папке `sw/common/default.ld` находится пример такого файла. Он описывает, как разместить секции в памяти, а также задает адреса для различных частей программы.

- Инцииализация
  ```
  // Указываем архитектуру — RISC-V
  OUTPUT_ARCH("riscv")
  
  // Указываем точку входа программы. 
  ENTRY(_start)
  _start = 0;
  
  // Определяем область памяти, доступную для размещения кода и данных.
  MEMORY
  {
    mem : ORIGIN = 0x80000000, LENGTH = 256K
  }
  ```
  
- Секции
  
  - `.text` -- исполняемый код. Подключаются
    
    - `*(.reset)` все секции `.reset` из объектных файлов
      
    - `*(.text .stub .text.* .gnu.linkonce.t.*)` Основной код и вспомогательные фрагменты
      
    - `KEEP (*(.text.*personality*))` Специальные обработчики исключений
      
    - `*(.gnu.warning)` Сообщение предупреждений о линковке
      
  - `.data` -- инициализационные данные. Сохраняются конструкторы и деструкторы, таблицы исключений, различные типы константных и инициализированных данных
    
  - `.bss` — переменные, которые не имеют начального значения. Резервируется место под общие переменные, также 16К под стек и кучу
    
  - `/DISCARD/ : { *(.note.GNU-stack) }` -- из файла убирается опции для исполняемого стэка

Флаг `-T` передает скрипт линковщику.

##### Что можно контролировать через `.ld`

Файл `.ld` позволяет:

- Задать адреса начала памяти (`. = <addr>`)
- Разбить код по кастомным секциям
- Создавать "символы" для взаимодействия с кодом (`_start = .;`)
- Задать точку входа (`ENTRY(_start)`)
- Упаковать данные в конкретный адрес для embedded-систем

#### 3.1.3 Загрузка на устройство

Запустить собранный код можно различными способами, в том числе, например, используя Verilator, тестбенч которого находится в папке `tb_top`

```bash
cd tb/tb_top
make build
build/test.x --elf ../../sw/bin/hello.elf
> Hello, world!
```

Также, используя `--cycles`, можно указать количество тактов, что будет выполнено в симуляции

Исходный код тестбенча на Verilator также находится в этой папке, благодаря чему можно его модифицировать и запускать программы, например
- `MEM_BASE` изменив его на `0x0000000` 
```diff
- #define MEM_BASE 0x80000000
+ #define MEM_BASE 0x00000000
```
- Сделать импровезированный *Debug*, добавив в интерфейс памяти тригеры на чтение
```diff
    uint8_t read(uint32_t addr)
    {
+        printf("READ: %08x\n", addr);
```
Для «железа» ядро biRISC-V подключается к памяти и периферии через AXI-интерфейсы (см. docs/integration.md). Обычно на FPGA резервируют RAM (TCM) по адресу 0x8000_0000 и UART по, например, 0x9200_0000. После синтеза загружайте скомпилированный ELF через загрузчик (SBI) или программатор в память FPGA.

## 4 Интеграционные тесты

Интеграционные тесты в процессоре BIRISC-V необходимы для проверки корректного взаимодействия между различными модулями процессора, такими как frontend, issue, exeс, кэши, память и интерфейсы ввода-вывода. Даже если каждый из этих компонентов работает правильно в отдельности, их совместная работа может вызывать ошибки из-за несогласованности сигналов, временных задержек или конфликтов при доступе к памяти. Интеграционные тесты позволяют выявить такие проблемы, проверяя целостность обработки инструкций на всех этапах конвейера, правильность переходов между состояниями, обработку прерываний, исключений и работу механизмов управления потоком команд, таких как переходы, возвраты. Также эти тесты проверяют корректность взаимодействия с кэшами и внешними интерфейсам.

### 4.1 Общие компоненты

#### 4.1.1 Файлы сборщика

Основной файл сборщика управляет генерацией кода, сборкой и запуском тестов

 Основные переменные

| Переменная          | Описание                                    | Значение по умолчанию                                     |
|---------------------|---------------------------------------------|-----------------------------------------------------------|
| `VERILATOR_SRC`     | Путь к заголовочным файлам Verilator        | `/usr/share/verilator/include`                            |
| `SYSTEMC_HOME`      | Путь к библиотекам SystemC                  | `/usr/local/systemc-3.0.1`                                |
| `TEST_IMAGE`        | Путь к тестовому ELF-файлу                  | `$(abspath ./test.elf)`                                   |
| `NUM_THREADS`       | Количество потоков для параллельной сборки  | `$(nproc) - 2, если количество потоков больше 2, иначе 2` |

Основные цели

| Цель        | Описание                                                                   |
|-------------|----------------------------------------------------------------------------|
| `build`     | Вызывает генерацию кода, сборку кода, а затем запуск testbench             |
| `all`       | Вызывает `build`                                                           |
| `set_path`  | Запускает скрипт `setup_environment.sh` для настройки переменных окружения |
| `get_path`  | Выводит текущее значение `LD_LIBRARY_PATH`                                 |
| `clean`     | Очищает сгенерированные и собранные файлы                                  |
| `run`       | Вызывает таргет build и запускает тесты                                    |
| `print_help`| Выводит список всех доступных целей с описанием                            |

##### 4.1.1.1 Makefile для генерации кода

Данный makefile отвечает за генерацию кода.

Основные переменные

| Переменная        | Описание                                           | Значение по умолчанию                                    |
|-------------------|----------------------------------------------------|----------------------------------------------------------|
| `CORE`            | Неиспользуемая переменная                          | `core`                                                   |
| `PARAMS`          | Дополнительные параметры                           |                                                          |
| `OUTPUT_DIR`      | Директория для выходных файлов                     | `verilated`                                              |
| `SRC_DIR`         | Директория с исходным кодом                        | `../../src/top`                                          |
| `SRC_TYPE`        | Расширение исходных файлов                         | `v`                                                      |
| `SRC_V_DIR`       | Директория с исходниками Verilog                   | `../../src/top`                                          |
| `OUTPUT_SUFFIX`   | Суффикс для выходных файлов                        |                                                          |
| `SRC`             | Имя основного исходного файла                      | `riscv_top`                                              |
| `NAME`            | Имя выходного файла                                | `riscv_top`                                              |
| `RTL_INCLUDE`     | Директории с зависимостями                         | `../../src/core`, `../../src/icache`, `../../src/dcache` |
| `VERILATE_PARAMS` | Параметры Verilator                                | `--trace`                                                |
| `VERILATOR_OPTS`  | Дополнительные опции Verilator                     | `--pins-sc-uint --unroll-count 512`                      |
| `TARGETS`         | путь до выходного файла для генерации              | `$(OUTPUT_DIR)/V$(NAME)`                                 |
| `OLDER_VERILATOR` | Определение версии Verilator                       | Исполняемая команда                                      |

Основные цели

| Цель                     | Описание                                                                         |
|--------------------------|----------------------------------------------------------------------------------|
| `all`                    | Основная цель, которая генерирует код (псевдоним для `$(OUTPUT_DIR)/V$(NAME)`)   |
| `$(OUTPUT_DIR)`          | Создает выходную директорию                                                      |
| `$(OUTPUT_DIR)/V$(NAME)` | Генерирует код из Verilog-кода с использованием Verilator и SystemC              |
| `clean`                  | Удаляет сгенерированные файлы и директории                                       |

##### 4.1.1.2 Makefile для сборки кода

Данный makefile отвечает за сборку кода

Основные переменные

| Переменная      | Описание                               | Значение по умолчанию        |
|-----------------|--------------------------------------|--------------------------------|
| `VERILATOR_SRC` | Путь к заголовочным файлам Verilator | `/usr/share/verilator/include` |
| `SYSTEMC_HOME`  | Путь к библиотеке SystemC            | `/usr/local/systemc-3.0.1`     |
| `SRC_DIR`       | Директория с исходными C++ файлами   | `verilated/`                   |
| `OBJ_DIR`       | Директория для объектных файлов      | `obj_verilated/`               |
| `LIB_DIR`       | Директория для выходной библиотеки   | `lib/`                         |
| `LIBNAME`       | Имя выходной библиотеки              | `libsyscverilated.a`           |

Параметры компиляции

| Переменная       | Описание                              |
|------------------|---------------------------------------|
| `INCLUDE_PATH`   | Список путей для заголовочных файлов  |
| `CFLAGS`         | Флаги компиляции                      |
| `LIB_OPT`        | Стандартная библиотека SystemC        |
| `SRC_LIST`       | Список всех исходных файлов Verilator |
| `OBJ`            | Список объектных файлов               |

Основные цели

| Цель                      | Описание                                                    |
|---------------------------|-------------------------------------------------------------|
| `all`                     | Общая цель сборки                                           |
| `$(LIB_DIR)$(LIBNAME)`    | Собирает shared-библиотеку из объектных файлов              |
| `$(OBJ_DIR)` `$(LIB_DIR)` | Создает директорию для объектных файлов выходной библиотеки |
| `$(LIB_DIR)`              | Создает директорию для выходной библиотеки                  |
| `clean`                   | Удаляет все сгенерированные файлы                           |

##### 4.1.1.3 Makefile для запуска тестов

Данный makefile отвечает за запуск интеграционных тестов

Основные переменные

| Переменная      | Описание                                 | Значение по умолчанию          |
|-----------------|------------------------------------------|--------------------------------|
| `VERILATOR_SRC` | Путь к заголовочным файлам Verilator     | `/usr/share/verilator/include` |
| `SYSTEMC_HOME`  | Путь к библиотеке SystemC                | `/usr/local/systemc-3.0.1`     |
| `OBJ_DIR`       | Директория для объектных файлов          | `obj/`                         |
| `EXE_DIR`       | Директория для сборки исполняемого файла | `build/`                       |
| `SRC_DIR`       | Директория с исходными C++ файлами       | `./`                           |
| `TARGET`        | Имя выходного исполняемого файла         | `test.x`                       |

Параметры компиляции и линковки

| Переменная     | Описание                             |
|----------------|--------------------------------------|
| `INCLUDE_PATH` | Список путей для заголовочных файлов |
| `LIB_PATH`     | Пути для поиска библиотек            |
| `LIBS`         | Подключаемые библиотеки              |
| `CFLAGS`       | Флаги компиляции                     |
| `LDFLAGS`      | Флаги линковки                       |

Основные цели

| Цель                      | Описание                                                     |
|---------------------------|--------------------------------------------------------------|
| `all`                     | Основной таргет сборки                                       |
| `$(EXE_DIR)$(TARGET)`     | Собирает исполняемый файл из объектных файлов                |
| `$(OBJ_DIR)` `$(EXE_DIR)` | Создает директорию для объектных файлов и исполняемого файла |
| `clean`                   | Удаляет директории и файлы                                   |

#### 4.1.2 Скрипт настройки окружения

Данный скрипт настраивает переменные окружения для выполнения тестирования

1. **Устанавливает путь до библиотеки SystemC в LD_LIBRARY_PATH**:
    - Если переменная не установлена - экспортирует путь до библиотеки SystemC (`/usr/local/systemc-3.0.1/lib-linux64`) и выводит сообщение об успешном выполнении.
    - Если путь в переменной отсутствует - добавляет его в конец и выводит сообщение об успешном выполнении.
    - Если путь уже есть - выводит сообщение о том, что путь уже содержится в переменной.

2. **Устанавливает путь до бинарников RISC-V в PATH**:
   - Если путь к бинарникам RISC-V (`/opt/riscv/bin`) отсутствует в PATH - добавляет его и выводит сообщение об успшном выполнении.
   - Если путь присутсвует в переменной - выводит сообщение об успешном выполнении.

3. **Выводит установленные переменные окружения**

#### 4.1.3 Тестовая микропрограмма

В репозиторий также добавлена тестовая микропрограмма `test.elf`, которая проверяет вывод приветственного сообщения.

### 4.2 Виды интеграционных тестов и их отличия

В данном процессоре есть две реализации интеграционных тестов: с ОЗУ и с TCM памятью.

TCM - это тип внутренней памяти, которая физически и логически тесно связана с процессором. В отличие от кэш-памяти, доступ к TCM полностью контролируется программным обеспечением: адресация осуществляется напрямую, без механизмов автоматической подкачки или вытеснения данных. Такая организация обеспечивает низколатентный доступ к памяти — операции чтения и записи могут выполняться за фиксированное и минимальное количество тактов.

#### 4.2.1 Тесты для реализации с ОЗУ

Память включает в себя два основных элемента: кэш инструкций и кэш данных. Оба кэша реализуют интерфейс AXI4 и обеспечивают взаимодействие между ядром RISC-V и внешней памятью.

Кэш инструкций отвечает за выборку инструкций, необходимых для исполнения программы. Ядро передаёт в кэш текущий адрес программы, после чего icache инициирует AXI-запрос на чтение и возвращает ядру нужную инструкцию. Также реализованы механизмы очистки и инвалидизации кэша, позволяющие управлять его состоянием при смене контекста или других событиях.

Кэш данных обслуживает операции чтения и записи данных, поступающие от ядра. В зависимости от типа запроса, кэш формирует AXI-транзакции и возвращает результат ядру. Он поддерживает работу с кэшируемыми и некэшируемыми областями памяти , а также имеет средства для обслуживания кэша: инвалидизаци, выгрузка и очистка.

##### 4.2.1.1 Файловая структура тестбенча

```text
.
├── axi4.h
├── axi4_defines.h
├── elf_load.cpp
├── elf_load.h
├── main.cpp
├── makefile
├── makefile.build_sysc_tb
├── makefile.build_verilated
├── makefile.generate_verilated
├── mem_api.h
├── riscv_top.cpp
├── riscv_top.h
├── sc_reset_gen.h
├── setup_environment.sh
├── tb_axi4_mem.cpp
├── tb_axi4_mem.cpp
├── testbench.h
├── testbench_vbase.h
└── test.elf
```

##### 4.2.1.2 Описание, ключевые компоненты и основной функционал файлов

###### 4.2.1.2.1 Исходные файлы тестов

Файлы тестов написанны на языке программирования __systemC__ 

Описание файла `main.cpp`

Главный файл тестбенча, реализующий:

- Инициализацию SystemC симуляции
- Управление тактовыми сигналами
- Обработку аргументов командной строки
- Генерацию VCD
- Обработку ошибок и прерываний

Основные компоненты

1. Объявление переменных

    | Название             | Назначение                         | Значение, если переменная объявлена |
    |----------------------|------------------------------------|-------------------------------------|
    | `SIM_TIME_RESOLUTION`| Разрешение временной шкалы         | 1                                   |
    | `SIM_TIME_SCALE`     | Единицы измерения времени          | `SC_NS`                             |
    | `CLK0_PERIOD`        | Период основного тактового сигнала | 10                                  |
    | `CLK0_NAME`          | Имя тактового сигнала              | `clk`                               |
    | `RST0_NAME`          | Имя сигнала сброса                 | `rst`                               |

2. Ключевые функции

    Обработчики ошибок:

    - `assert_handler` - обработчик `sc_assert`
        - Выводит сообщение о падении теста
        - Прерывает симуляцию через `tb->abort()`
    - `sigint_handler` - Обработчик SIGINT
        - Восстанавливает параметры
        - Завершает симуляцию с ошибкой

    Системные функции:

    - `vl_finish` - Обработчик завершения симуляции
        - Выводит информацию об успешном завершении
        - Вызывает функцию выхода
    - `exit_override` - Хук на завершение программы
        - Гарантирует корректное завершение тестбенча

    Функция `sc_main`

    Параметры командной строки

    | Аргумент     | Описание                         |
    |--------------|----------------------------------|
    | `--trace`    | Включение/выключение трассировки |
    | `--seed`     | Установка seed для рандомизации  |
    | `--vcd_name` | Имя файла волновых vcd           |

    Основные действия

    1. Регистрация обработчиков ошибок
    2. Создание тактового сигнала и генератора сброса
    3. Создание экземпляра тестбенча
    4. Настройка трассировки
    5. Запуск симуляции

Описание riscv_top.cpp

Модуль `riscv_top` представляет собой обертку SystemC для RISC-V, обеспечивающую:

- Связь между SystemC окружением и Verilog
- Синхронизацию сигналов
- Поддержку трассировки
- Работу с AXI4 интерфейсами

Основные компоненты

- Конструктор - инициализирует Verilated модель и подключает сигналы
- Метод async_outputs - обрабатывает изменения сигналов
- Методы трассировки - управляет записью vcd

 Интерфейсы и функциональность модуля riscv_top

Интерфейсы и сигналы:

Входные порты:

| Сигнал            | Назначение               |
|-------------------|--------------------------|
| `clk_in`          | Тактовый сигнал          |
| `rst_in`          | Сигнал сброса            |
| `intr_in`         | Вход прерывания          |
| `reset_vector_in` | Адрес начальной загрузки |
| `axi_i_in`        | AXI интерфейс инструкций |
| `axi_d_in`        | AXI интерфейс данных     |

Выходные порты:

| Сигнал         | Назначение               |
|----------------|--------------------------|
| `axi_i_out`    | AXI интерфейс инструкций |
| `axi_d_out`    |  AXI интерфейс данных    |

Методы:

Конструктор

1. Создает экземпляр Verilated модели RISC-V ядра
2. Выполняет привязку всех интерфейсных сигналов:
    - Тактовые сигналы и управление
    - AXI-интерфейсы инструкций и данных

Обработка сигналов

Основные функции:

- Синхронизация тактовых сигналов и сигналов сброса
- Преобразование AXI-структур:
- Разбор входных AXI-пакетов на отдельные сигналы
- Формирование выходных AXI-пакетов из отдельных сигналов
- Передача данных между SystemC и Verilog

Трассировка

Функциональные возможности:

- Активация записи VCD
- Поддержка отложенного старта трассировки
- Настройка глубины трассировки сигналов
- Совместимость с различными инструментами анализа временных диаграмм

Описание elf_load.cpp

`elf_load` реализует функциональность для:

- Загрузки исполняемых ELF-файлов в целевую память
- Извлечения символов из ELF-файлов
- Управления памятью через абстрактный интерфейс `mem_api`

Основные компоненты

Конструктор

- Инициализирует объект загрузчика
- Принимает:
- Имя файла для загрузки
- Указатель на интерфейс работы с памятью

Метод `load()`

1. Открывает и проверяет ELF-файл
2. Извлекает точку входа
3. Обрабатывает секции:
    - Выделяет память для секций с флагом SHF_ALLOC
    - Загружает содержимое секций PROGBITS в память
4. Поддерживает как 32-битные, так и 64-битные ELF-файлы

Метод `get_symbol()`

- Ищет символ в таблице символов ELF-файла
- Возвращает значение найденного символа
- Использует библиотеку BFD для работы с символами

Интерфейсы

- Работает через абстрактный интерфейс `mem_api` для доступа к памяти
- Поддерживает стандартные ELF-форматы (32/64 бита)
- Сохраняет точку входа программы для последующего использования

Описание  tb_axi4_mem.cpp

Код реализует функциональность тестового AXI4-совместимого блока памяти.

Основные функции

Обработка AXI-транзакций (`process`)

- Обрабатывает чтение и запись через AXI4-интерфейс
- Поддерживает все типы burst-транзакций:
  - INCR
  - WRAP
  - FIXED
- Использует очереди для хранения запросов
- Реализует случайные задержки для эмуляции реальной памяти

Вспомогательные функции

- `calc_next_addr` - вычисляет следующий адрес для burst-транзакций
- `calc_wrap_mask` - вычисляет маску для WRAP-транзакций
- `read32`/`write32` - 32-битные операции с памятью
- `read`/`write` - байтовые операции с памятью

###### 4.2.1.2.2 Заголовочные файлы

Описание riscv_top.h

Заголовочный файл определяет обертку SystemC для Verilog модели RISC-V процессора, обеспечивающую:

- Связь между SystemC и Verilog через AXI4 интерфейсы
- Поддержку трассировки сигналов
- Синхронизацию тактовых доменов

Основные компоненты

Интерфейсы

| Интерфейс         | Назначение               |
|-------------------|--------------------------|
| `clk_in`          | Тактовый сигнал          |
| `rst_in`          | Сигнал сброса            |
| `intr_in`         | Вход прерывания          |
| `reset_vector_in` | Адрес начальной загрузки |
| `axi_i_in/out`    | Канал инструкций         |
| `axi_d_in/out`    | Канал данных             |

Методы

1. **Конструктор** - инициализация модуля
2. **add_trace** - добавление сигналов в VCD
3. **async_outputs** - обработка асинхронных выходов
4. **trace_enable** - управление трассировкой

Внутренние сигналы

- Полный набор AXI4 сигналов для каналов:
  - Чтения
  - Записи
- Сигналы управления
- Сигналы прерываний

Описание tb_memory.h

Заголовочный файл определяет классы для эмуляции работы с памятью.

Основные компоненты

Класс `tb_mem_region`

Описывает память с:

- Базовым адресом и размером
- Методами доступа
- Возможностью трассировки операций
- Поддержкой внешнего массива данных

Класс `tb_mem_record`

Фиксирует детали транзакций:

- Время операции
- Тип
- Адрес и данные

Класс `tb_memory`

Основной класс для работы с памятью:

- Поддерживает до 10 областей памяти
- Обеспечивает:
  - Добавление/удаление областей
  - Проверку валидности адресов
  - Чтение/запись данных
  - Логирование операций
- Имеет механизм записи транзакций

Описание axi4.h

Файл определяет классы для работы с AXI4-интерфейсом в SystemC, включая:

- Структуры для master и slave
- Методы инициализации и сравнения
- Поддержку трассировки сигналов
- Операторы ввода/вывода

Основные классы

Класс `axi4_master`

**Основные сигналы:**

- Канал записи
- Канал чтения
- Управляющие сигналы

**Методы:**

- `init()` - сброс всех сигналов
- Операторы сравнения, вывода и трассировки

Класс `axi4_slave`

**Основные сигналы:**

- Ответы на каналы записи и чтения
- Управляющие сигналы

**Методы:**

- `init()` - сброс всех сигналов
- Операторы сравнения, вывода и трассировки

Описание tb_axi4_mem.h

Заголовочный файл определяет класс тестовой AXI4-памяти для верификации в SystemC.

Интерфейсы

| Сигнал    | Назначение             |
|---------- |------------------------|
| `clk_in`  | Тактовый сигнал        |
| `rst_in`  | Сигнал сброса          |
| `axi_in`  | Входной AXI-интерфейс  |
| `axi_out` | Выходной AXI-интерфейс |

Методы

- **Управление памятью**:
  - `write()` / `read()`
  - `write32()` / `read32()`

- **Управление задержками**:
  - `enable_delays()` - включение случайных задержек
  - `delay_cycle()` - генерация задержки

- **Обработка транзакций**:
  - `process()` - основной поток обработки AXI-транзакций

- **Вспомогательные функции**:
  - `calc_wrap_mask()` / `calc_next_addr()` - расчет адресов для burst-транзакций

Описание testbench_vbase.h

Базовый класс для создания тестов SystemC с интеграцией Verilator.

Интерфейсы

- `clk` - Тактовый сигнал
- `rst` - Сигнал сброса

Виртуальные методы

| Метод            | Назначение                           |
|------------------|--------------------------------------|
| `set_testcase`   | Установка номера тесткейса           |
| `set_delays`     | Включение/выключение задержек        |
| `set_iterations` | Установка числа итераций             |
| `set_argcv`      | Передача аргументов командной строки |
| `process`        | Основной поток выполнения теста      |
| `monitor`        | Поток мониторинга состояния          |
| `add_trace`      | Добавление сигналов в трассу         |

Реализованные методы

- `abort()` - Аварийное завершение теста
- `waves_enabled()` - Проверка включения трассировки
- `waves_delayed()` - Проверка задержки старта трассировки
- `getenv_str()` - Чтение переменных окружения

Описание testbench.h

Базовый класс для тестирования biRISC-V процессора с:

- Поддержкой загрузки ELF-файлов
- AXI4-совместимыми интерфейсами памяти
- Интеграцией с Verilator для трассировки

Основные компоненты

| Компонент      | Назначение              |
|----------------|-------------------------|
| `m_dut`        | Тестируемое RISC-V ядро |
| `m_icache_mem` | Память инструкций       |
| `m_dcache_mem` | Память данных           |

Интерфейсы

- AXI4-интерфейсы для памяти инструкций и данных
- Сигналы прерываний и сброса

Функциональность

1. **Загрузка ELF**:
   - Парсинг аргументов командной строки
   - Загрузка программы через `elf_load`
   - Настройка начального адреса выполнения

2. **Управление памятью**:
   - Создание областей памяти
   - Чтение и запись данных
   - Выравнивание адресов

3. **Трассировка**:
   - Поддержка VCD
   - Управление через переменные окружения
   - Отложенный старт трассировки

#### 4.2.2 Тесты для реализации с TCM

Реализация с TCM включает в себя встроенную память Tightly Coupled Memory, а также интерфейс к внешней памяти через шину AXI. Архитектура памяти организована по двухуровневому принципу: внутренняя быстрая память TCM используется для хранения инструкций и данных, а внешняя - для доступа к основной памяти системы или периферийным устройствам.

##### 4.2.2.1 Файловая структура тестбенча

```text
.
├── axi4.h
├── axi4_lite.h
├── elf_load.cpp
├── elf_load.h
├── main.cpp
├── makefile
├── makefile.build_sysc_tb
├── makefile.build_verilated
├── makefile.generate_verilated
├── mem_api.h
├── riscv_tcm_top.cpp
├── riscv_tcm_top_rtl.h
├── sc_reset_gen.h
├── setup_environment.sh
├── testbench.h
├── testbench_vbase.h
└── test.elf
```

##### 4.2.2.2 Описание, ключевые компоненты и основной функционал файлов

###### 4.2.2.2.1 Исходные файлы тестов

Файлы тестов написанны на языке программирования __systemC__ 

Описание файла `main.cpp`

Главный файл тестбенча, реализующий:

- Инициализацию SystemC симуляции
- Управление тактовыми сигналами
- Обработку аргументов командной строки
- Генерацию VCD
- Обработку ошибок и прерываний

Основные компоненты

1. Объявление переменных

    | Название             | Назначение                         | Значение, если переменная объявлена |
    |----------------------|------------------------------------|-------------------------------------|
    | `SIM_TIME_RESOLUTION`| Разрешение временной шкалы         | 1                                   |
    | `SIM_TIME_SCALE`     | Единицы измерения времени          | `SC_NS`                             |
    | `CLK0_PERIOD`        | Период основного тактового сигнала | 10                                  |
    | `CLK0_NAME`          | Имя тактового сигнала              | `clk`                               |
    | `RST0_NAME`          | Имя сигнала сброса                 | `rst`                               |

2. Ключевые функции

    Обработчики ошибок

    - `assert_handler` - обработчик `sc_assert`
        - Выводит сообщение о падении теста
        - Прерывает симуляцию через `tb->abort()`
    - `sigint_handler` - Обработчик SIGINT
        - Восстанавливает параметры
        - Завершает симуляцию с ошибкой

    Системные функции

    - `vl_finish` - Обработчик завершения симуляции
        - Выводит информацию об успешном завершении
        - Вызывает функцию выхода

    - `exit_override` - Хук на завершение программы
        - Гарантирует корректное завершение тестбенча

3. Функция `sc_main`

    Параметры командной строки

    | Аргумент     | Описание                         |
    |--------------|----------------------------------|
    | `--trace`    | Включение/выключение трассировки |
    | `--seed`     | Установка seed для рандомизации  |
    | `--vcd_name` | Имя файла волновых vcd           |

Основные действия

1. Регистрация обработчиков ошибок
2. Создание тактового сигнала и генератора сброса
3. Создание экземпляра тестбенча
4. Настройка трассировки
5. Запуск симуляции

Описание riscv_tcm_top_rtl.cpp

`riscv_tcm_top_rtl.cpp` представляет собой обертку SystemC для RISC-V с Tightly Coupled Memory, обеспечивающая:

- Связь между SystemC и Verilog через AXI интерфейсы
- Поддержку трассировки сигналов

Сигналы

| Интерфейс    | Назначение       |
|--------------|------------------|
| `clk_in`     | Тактовый сигнал  |
| `rst_in`     | Системный сброс  |
| `rst_cpu_in` | Сброс процессора |
| `axi_i_in`   | AXI-Lite         |
| `axi_t_in`   | AXI              |
| `intr_in`    | Вход прерывания  |

Методы

1. Конструктор
    - Создает экземпляр `Vriscv_tcm_top`
    - Связывает все сигналы:
    - Тактирование и сброс
    - Два AXI интерфейса:
        - `axi_i` - AXI-Lite для инструкций
        - `axi_t` - AXI для данных
    - Сигнал прерывания (`intr_i`)

2. Методы трассировки
    - `trace_enable` - активация VCD трассировки
    - `trace_rtl` - запись временных диаграмм с поддержкой отложенного старта

3. Метод `async_outputs`
    Обработка асинхронных сигналов:
    - Синхронизация простых сигналов
    - Преобразование AXI структур:
    - `axi4_lite_slave` - отдельные сигналы для инструкций
    - `axi4_master` и `axi4_slave` - для данных

Описание elf_load.cpp

`elf_load` реализует функциональность для:

- Загрузки исполняемых ELF-файлов в целевую память
- Извлечения символов из ELF-файлов
- Управления памятью через абстрактный интерфейс `mem_api`

Основные компоненты

Конструктор

- Инициализирует объект загрузчика
- Принимает:
  - Имя файла для загрузки
  - Указатель на интерфейс работы с памятью

Метод `load()`

1. Открывает и проверяет ELF-файл
2. Извлекает точку входа
3. Обрабатывает секции:
   - Выделяет память для секций с флагом SHF_ALLOC
   - Загружает содержимое секций PROGBITS в память
4. Поддерживает как 32-битные, так и 64-битные ELF-файлы

Метод `get_symbol()`

- Ищет символ в таблице символов ELF-файла
- Возвращает значение найденного символа
- Использует библиотеку BFD для работы с символами

Интерфейсы

- Работает через абстрактный интерфейс `mem_api` для доступа к памяти
- Поддерживает стандартные ELF-форматы (32/64 бита)
- Сохраняет точку входа программы для последующего использования

###### 4.2.2.2.3 Заголовочные файлы

Описание riscv_tcm_top_rtl.h

Заголовочный файл определяет обертку SystemC для Verilog модели RISC-V процессора с Tightly Coupled Memory, обеспечивающая:

- Связь между SystemC и Verilog через AXI интерфейсы
- Поддержку трассировки сигналов

Основные компоненты

Интерфейсы

| Сигнал       | Назначение         |
|--------------|--------------------|
| `clk_in`     | Тактовый сигнал    |
| `rst_in`     | Системный сброс    |
| `rst_cpu_in` | Сброс процессора   |
| `intr_in`    | Вход прерываний    |
| `axi_i_in`   | AXI-Lite интерфейс |
| `axi_i_out`  | AXI-Lite интерфейс |
| `axi_t_in`   | AXI интерфейс      |
| `axi_t_out`  | AXI интерфейс      |

Методы

**async_outputs** - Обработка асинхронных сигналов
**trace_enable** - Активация VCD трассировки
**trace_rtl** - Запись временных диаграмм
**add_trace** - Добавление сигналов в SystemC трассу

Внутренние сигналы

- Полный набор сигналов для AXI интерфейсов:
  - Каналы AW, W, B, AR, R
  - Сигналы handshake
  - Параметры транзакций

Описание axi4.h

Файл определяет классы для работы с AXI4-интерфейсом в SystemC, включая:

- Структуры для master и slave
- Методы инициализации и сравнения
- Поддержку трассировки сигналов
- Операторы ввода/вывода

Основные классы

1. Класс `axi4_master`

    **Основные сигналы:**

    - Канал записи
    - Канал чтения
    - Управляющие сигналы

    **Методы:**

    - `init()` - сброс всех сигналов
    - Операторы сравнения, вывода и трассировки

2. Класс `axi4_slave`

    **Основные сигналы:**

    - Ответы на каналы записи и чтения
    - Управляющие сигналы

    **Методы:**

    - `init()` - сброс всех сигналов
    - Операторы сравнения, вывода и трассировки

Описание axi4_lite.h

Определение классов для работы с AXI4-Lite интерфейсом в SystemC, включая:

- Структуры для master и slave устройств
- Методы инициализации и сравнения
- Поддержку трассировки сигналов
- Оп3ераторы ввода/вывода

Основные классы

1. Класс `axi4_lite_master`

    Описание master-устройства AXI4-Lite:

    **Сигналы:**

    - Канал записи
    - Канал чтения
    - Управляющие сигналы

    **Методы:**

    - `init()` - сброс всех сигналов
    - Операторы сравнения, вывода и трассировки

2. Класс `axi4_lite_slave`

    Описание slave-устройства AXI4-Lite:

    **Сигналы:**

    - Ответы на каналы записи и чтения
    - Управляющие сигналы

    **Методы:**

    - `init()` - сброс всех сигналов
    - Операторы сравнения, вывода и трассировки

Описание testbench_vbase.h

Базовый класс для создания тестов SystemC с интеграцией Verilator.

Исходный код представлен в [testbench_vbase.h](/tb/tb_tcm/testbench_vbase.h)

Интерфейсы

- `clk` - Тактовый сигнал
- `rst` - Сигнал сброса

Виртуальные методы

| Метод            | Назначение                           |
|------------------|--------------------------------------|
| `set_testcase`   | Установка номера тесткейса           |
| `set_delays`     | Включение/выключение задержек        |
| `set_iterations` | Установка числа итераций             |
| `set_argcv`      | Передача аргументов командной строки |
| `process`        | Основной поток выполнения теста      |
| `monitor`        | Поток мониторинга состояния          |
| `add_trace`      | Добавление сигналов в трассу         |

Реализованные методы

- `abort()` - Аварийное завершение теста
- `waves_enabled()` - Проверка включения трассировки
- `waves_delayed()` - Проверка задержки старта трассировки
- `getenv_str()` - Чтение переменных окружения

Описание testbench.h

Базовый класс для тестирования BIRISC-V процессора с Tightly Coupled Memory, реализующий:

- Загрузку ELF-файлов в память
- Управление процессором через AXI4-Lite интерфейсы
- Поддержку трассировки сигналов
- Контроль выполнения тестов

Основные компоненты

1. Интерфейсы и сигналы

    | Сигналы и интерфейсы | Назначение           |
    |----------------------|----------------------|
    | `clk`                | Тактирование         |
    | `rst`                | Сброс                |
    | `rst_cpu_in`         | Сброс процессора     |
    | `axi_t_in/out`       | Интерфейс данных     |
    | `axi_i_in/out`       | Интерфейс инструкций |
    | `intr_in`            | Вход прерываний      |

2. Параметры командной строки

    | Опция      | Описание                |
    |------------|-------------------------|
    | `--elf`    | ELF-файл для загрузки   |
    | `--cycles` | Лимит тактов выполнения |

## Приложение А - описание сигнальных линий модулей ядра biRISC-V

### Входные и выходные порты, внутренние сигналы модуля __riscv_core__

Таблица 1 - Входные и выходные порты модуля riscv_core.    

| Сигнал                    | Направление | Размерность (биты) | Описание                                |
|---------------------------|-------------|--------------------|-----------------------------------------|
| **Тактирование и сброс**  |             |                    |                                         |
| clk_i                     | Вход        | 1                  | Тактовый сигнал                         |
| rst_i                     | Вход        | 1                  | Сигнал сброса                           |
| **Интерфейс памяти данных** |           |                    |                                         |
| mem_d_data_rd_i           | Вход        | 32                 | Данные чтения из памяти данных          |
| mem_d_accept_i            | Вход        | 1                  | Подтверждение приема запроса данных     |
| mem_d_ack_i               | Вход        | 1                  | Подтверждение выполнения запроса        |
| mem_d_error_i             | Вход        | 1                  | Ошибка доступа к данным                 |
| mem_d_resp_tag_i          | Вход        | 11                 | Тег ответа данных                       |
| mem_d_addr_o              | Выход       | 32                 | Адрес данных                            |
| mem_d_data_wr_o           | Выход       | 32                 | Данные для записи                       |
| mem_d_rd_o                | Выход       | 1                  | Сигнал чтения данных                    |
| mem_d_wr_o                | Выход       | 4                  | Сигналы записи данных (по байтам)       |
| **Интерфейс памяти инструкций** |       |                    |                                         |
| mem_i_inst_i              | Вход        | 64                 | Инструкции из памяти (2x32-битные)      |
| mem_i_accept_i            | Вход        | 1                  | Подтверждение приема запроса инструкций |
| mem_i_valid_i             | Вход        | 1                  | Действительные данные инструкций        |
| mem_i_error_i             | Вход        | 1                  | Ошибка доступа к инструкциям            |
| mem_i_rd_o                | Выход       | 1                  | Сигнал чтения инструкций                |
| mem_i_flush_o             | Выход       | 1                  | Сброс кэша инструкций                   |
| mem_i_invalidate_o        | Выход       | 1                  | Инвалидация кэша инструкций             |
| mem_i_pc_o                | Выход       | 32                 | Адрес инструкции                        |
| **Системные сигналы**     |             |                    |                                         |
| intr_i                    | Вход        | 1                  | Вход прерывания                         |
| reset_vector_i            | Вход        | 32                 | Вектор сброса                           |
| cpu_id_i                  | Вход        | 32                 | Идентификатор CPU                       |
| **Управление кэшем**      |             |                    |                                         |
| mem_d_cacheable_o         | Выход       | 1                  | Флаг кэшируемости                       |
| mem_d_req_tag_o           | Выход       | 11                 | Тег запроса данных                      |
| mem_d_invalidate_o        | Выход       | 1                  | Инвалидация кэша                        |
| mem_d_writeback_o         | Выход       | 1                  | Запись обратно                          |
| mem_d_flush_o             | Выход       | 1                  | Сброс кэша                              |


Таблица 2 - Основные внутренние сигналы модуля riscv_core.  

| Сигнал                    | Размерность | Описание                                |
|---------------------------|-------------|-----------------------------------------|
| mmu_ifetch_inst_w         | 64          | Выбранные инструкции от MMU             |
| fetch0_instr_w            | 32          | Инструкция 0-го потока                  |
| fetch1_instr_w            | 32          | Инструкция 1-го потока                  |
| opcode0_opcode_w          | 32          | Декодированная инструкция потока 0      |
| opcode1_opcode_w          | 32          | Декодированная инструкция потока 1      |
| writeback_exec0_value_w   | 32          | Результат выполнения ALU потока 0       |
| writeback_exec1_value_w   | 32          | Результат выполнения ALU потока 1       |
| branch_pc_w               | 32          | Адрес перехода                          | 
| mmu_satp_w                | 32          | Регистр управления MMU                  |


### Входные и выходные порты, основные сигналы подмодуля __issue__
Таблица 3 - Входные и выходные порты подмодуля issue.    

| Сигнал                    | Направление | Размерность (биты) | Описание                                |
|---------------------------|-------------|--------------------|-----------------------------------------|
| **Тактирование и сброс**  |             |                    |                                         |
| clk_i                     | Вход        | 1                  | Тактовый сигнал                         |
| rst_i                     | Вход        | 1                  | Сигнал сброса (активный высокий уровень)|
| **Интерфейс выборки**     |             |                    |                                         |
| fetch0_valid_i            | Вход        | 1                  | Валидность инструкции 0                 |
| fetch0_instr_i            | Вход        | 32                 | Инструкция 0                            |
| fetch0_pc_i               | Вход        | 32                 | Адрес инструкции 0                      |
| fetch1_valid_i            | Вход        | 1                  | Валидность инструкции 1                 |
| fetch1_instr_i            | Вход        | 32                 | Инструкция 1                            |
| fetch1_pc_i               | Вход        | 32                 | Адрес инструкции 1                      |
| **Информация о ветвлениях** |           |                    |                                         |
| branch_exec0_request_i    | Вход        | 1                  | Запрос ветвления от потока 0            |
| branch_exec1_request_i    | Вход        | 1                  | Запрос ветвления от потока 1            |
| **Результаты выполнения** |             |                    |                                         |
| writeback_exec0_value_i   | Вход        | 32                 | Результат ALU потока 0                  |
| writeback_exec1_value_i   | Вход        | 32                 | Результат ALU потока 1                  |
| writeback_mem_value_i     | Вход        | 32                 | Результат LSU                           |
| writeback_mul_value_i     | Вход        | 32                 | Результат умножения                     |
| writeback_div_value_i     | Вход        | 32                 | Результат деления                       |
| **Управление выборкой**   |             |                    |                                         |
| fetch0_accept_o           | Выход       | 1                  | Подтверждение приема инструкции 0       |
| fetch1_accept_o           | Выход       | 1                  | Подтверждение приема инструкции 1       |
| **Интерфейс исполнительных устройств** | |                |                                         |
| exec0_opcode_valid_o      | Выход       | 1                  | Валидность инструкции для потока 0      |
| exec1_opcode_valid_o      | Выход       | 1                  | Валидность инструкции для потока 1      |
| lsu_opcode_valid_o        | Выход       | 1                  | Валидность инструкции для LSU           |
| **Декодированные инструкции** |         |                    |                                         |
| opcode0_opcode_o          | Выход       | 32                 | Декодированная инструкция потока 0      |
| opcode1_opcode_o          | Выход       | 32                 | Декодированная инструкция потока 1      |
| **Информация о регистрах** |            |                    |                                         |
| opcode0_rd_idx_o          | Выход       | 5                  | Индекс регистра назначения потока 0     |
| opcode0_ra_idx_o          | Выход       | 5                  | Индекс регистра источника A потока 0    |
| opcode0_rb_idx_o          | Выход       | 5                  | Индекс регистра источника B потока 0    |

Таблица 4 - Основные внутренние сигналы модуля issue.  

| Сигнал                    | Размерность | Описание                                      |
|---------------------------|-------------|-----------------------------------------------|
| **Управление конвейером** |             |                                               |
| pipe0_stall_raw_w         | 1           | Сигнал остановки потока 0                     |
| pipe1_stall_raw_w         | 1           | Сигнал остановки потока 1                     |
| **Регистровый файл**      |             |                                               |
| issue_a_ra_value_w        | 32          | Значение регистра A потока 0                  |
| issue_a_rb_value_w        | 32          | Значение регистра B потока 0                  |
| issue_b_ra_value_w        | 32          | Значение регистра A потока 1                  |
| issue_b_rb_value_w        | 32          | Значение регистра B потока 1                  |
| **Состояние выполнения**  |             |                                               |
| pipe0_load_e1_w           | 1           | Флаг операции загрузки в стадии E1 потока 0   |
| pipe0_mul_e1_w            | 1           | Флаг операции умножения в стадии E1 потока 0  |
| pipe1_load_e1_w           | 1           | Флаг операции загрузки в стадии E1 потока 1   |

### Входные и выходные порты, основные сигналы подмодуля __frontend__
Таблица 5 - Входные и выходные порты подмодуля frontend.    

| Сигнал                     | Направление | Размерность | Описание                                      |
|----------------------------|-------------|-------------|-----------------------------------------------|
| **Тактирование и сброс**   |             |             |                                               |
| `clk_i`                    | Вход        | 1 бит       | Тактовый сигнал                               |
| `rst_i`                    | Вход        | 1 бит       | Сигнал сброса                                 |
| **Интерфейс кеша инструкций** |          |             |                                               |
| `icache_accept_i`          | Вход        | 1 бит       | Подтверждение приема от кеша инструкций       |
| `icache_valid_i`           | Вход        | 1 бит       | Валидность данных от кеша                     |
| `icache_inst_i`            | Вход        | 64 бита     | Инструкции из кеша                            |
| `icache_rd_o`              | Выход       | 1 бит       | Запрос чтения кеша                            |
| `icache_pc_o`              | Выход       | 32 бита     | Адрес для чтения кеша                         |
| **Интерфейс выборки**      |             |             |                                               |
| `fetch0_accept_i`          | Вход        | 1 бит       | Готовность приемника для fetch0               |
| `fetch1_accept_i`          | Вход        | 1 бит       | Готовность приемника для fetch1               |
| `fetch0_valid_o`           | Выход       | 1 бит       | Валидность инструкции 0                       |
| `fetch0_instr_o`           | Выход       | 32 бита     | Инструкция 0                                  |
| `fetch1_valid_o`           | Выход       | 1 бит       | Валидность инструкции 1                       |
| `fetch1_instr_o`           | Выход       | 32 бита     | Инструкция 1                                  |
| **Управление ветвлениями** |             |             |                                               |
| `branch_request_i`         | Вход        | 1 бит       | Запрос на ветвление                           |
| `branch_pc_i`              | Вход        | 32 бита     | Адрес ветвления                               |
| `branch_info_is_taken_i`   | Вход        | 1 бит       | Признак взятого ветвления                     |
| `branch_info_source_i`     | Вход        | 32 бита     | Адрес источника ветвления                     |
| **Типы инструкций**        |             |             |                                               |
| `fetch0_instr_exec_o`      | Выход       | 1 бит       | Признак исполнительной инструкции (поток 0)   |
| `fetch0_instr_lsu_o`       | Выход       | 1 бит       | Признак load/store (поток 0)                  |
| `fetch1_instr_branch_o`    | Выход       | 1 бит       | Признак ветвления (поток 1)                   |
| `fetch1_instr_mul_o`       | Выход       | 1 бит       | Признак умножения (поток 1)                   |

Таблица 6 - Основные внутренние сигналы подмодуля frontend.  

| Сигнал                  | Размерность | Описание                                                                 |
|-------------------------|-------------|--------------------------------------------------------------------------|
| **Управление выборкой**                                                                 |
| `fetch_valid_w`         | 1 бит       | Валидность текущего набора инструкций в конвейере                        |
| `fetch_instr_w`         | 64 бита     | Сдвоенная инструкция (2x32 бита) из кеша                                 |
| `fetch_accept_w`        | 1 бит       | Готовность конвейера к приему новых инструкций                           |
| `fetch_pc_accept_w`     | 1 бит       | Подтверждение приема адреса блоком NPC                                   |
| **Прогнозирование переходов**                                                          |
| `next_pc_f_w`           | 32 бита     | Следующий PC от блока предсказания (NPC)                                 |
| `next_taken_f_w`        | 2 бита      | Прогноз направления ветвления (00-не взято, 01-взято и т.д.)             |
| `fetch_pred_branch_w`   | 2 бита      | Состояние предсказания для текущего PC                                   |
| **Обработка исключений**                                                               |
| `fetch_fault_fetch_w`   | 1 бит       | Флаг ошибки выборки инструкции                                           |
| `fetch_fault_page_w`    | 1 бит       | Флаг page fault при обращении к памяти                                   |
| **Адресация**                                                                          |
| `fetch_pc_w`            | 32 бита     | Текущий адрес инструкции в конвейере                                     |
| `fetch_pc_f_w`          | 32 бита     | Адрес следующей инструкции для NPC                                       |
| **Декодирование**                                                                      |
| `fetch_instr_w`         | 64 бита     | Сырые инструкции перед декодированием                                    |

### Входные и выходные порты подмодуля __exec__
Таблица 7 - Входные и выходные порты подмодуля exec.    

| Сигнал                     | Направление | Размерность | Описание                                      |
|----------------------------|-------------|-------------|-----------------------------------------------|
| **Тактирование и управление**                                                      |
| `clk_i`                    | input       | 1 бит       | Тактовый сигнал                               |
| `rst_i`                    | input       | 1 бит       | Асинхронный сброс (активный 1)                |
| `hold_i`                   | input       | 1 бит       | Сигнал остановки конвейера                     |
| **Интерфейс инструкций**                                                          |
| `opcode_valid_i`           | input       | 1 бит       | Валидность текущей инструкции                  |
| `opcode_opcode_i`          | input       | 32 бита     | Код исполняемой инструкции                     |
| `opcode_pc_i`              | input       | 32 бита     | Адрес инструкции (текущий PC)                  |
| `opcode_invalid_i`         | input       | 1 бит       | Флаг невалидной инструкции                     |
| **Интерфейс регистров**                                                          |
| `opcode_rd_idx_i`          | input       | 5 бит       | Индекс регистра назначения (rd)                |
| `opcode_ra_idx_i`          | input       | 5 бит       | Индекс первого операнда (rs1)                  |
| `opcode_rb_idx_i`          | input       | 5 бит       | Индекс второго операнда (rs2)                  |
| `opcode_ra_operand_i`      | input       | 32 бита     | Значение регистра rs1                          |
| `opcode_rb_operand_i`      | input       | 32 бита     | Значение регистра rs2                          |
| **Интерфейс ветвлений**                                                          |
| `branch_request_o`         | output      | 1 бит       | Факт наличия ветвления                         |
| `branch_is_taken_o`        | output      | 1 бит       | Ветвление выполняется                          |
| `branch_is_not_taken_o`    | output      | 1 бит       | Ветвление не выполняется                       |
| `branch_source_o`          | output      | 32 бита     | PC исходной инструкции ветвления               |
| `branch_is_call_o`         | output      | 1 бит       | Флаг вызова подпрограммы                       |
| `branch_is_ret_o`          | output      | 1 бит       | Флаг возврата из подпрограммы                  |
| `branch_is_jmp_o`          | output      | 1 бит       | Флаг безусловного перехода                     |
| `branch_pc_o`              | output      | 32 бита     | Целевой PC перехода                            |
| `branch_d_request_o`       | output      | 1 бит       | Запрос предсказания ветвления                  |
| `branch_d_pc_o`            | output      | 32 бита     | PC для предсказания ветвления                  |
| `branch_d_priv_o`          | output      | 2 бита      | Уровень привилегий (не используется)           |
| **Интерфейс записи результатов**                                                |
| `writeback_value_o`        | output      | 32 бита     | Результат выполнения для записи в регистровый файл |

Таблица 8 - Основные внутренние сигналы подмодуля exec.  

| Сигнал              | Размерность | Описание |
|---------------------|-------------|----------|
| `imm20_r`           | 32 бита     | Immediate U-типа |
| `imm12_r`           | 32 бита     | Immediate I-типа |
| `bimm_r`           | 32 бита     | Immediate B-типа |
| `jimm20_r`         | 32 бита     | Immediate J-типа |
| `shamt_r`          | 5 бит       | Величина сдвига |
| `alu_func_r`       | 4 бита      | Код операции ALU |
| `alu_input_a_r`    | 32 бита     | Первый операнд ALU |
| `alu_input_b_r`    | 32 бита     | Второй операнд ALU |
| `branch_r`         | 1 бит       | Внутренний флаг ветвления |
| `branch_taken_r`   | 1 бит       | Флаг взятия ветвления |
| `branch_target_r`  | 32 бита     | Целевой адрес ветвления |

### Входные и выходные порты подмодуля __csr__
Таблица 9 - Входные и выходные порты подмодуля csr.    

| Сигнал                             | Направление | Размерность | Описание                                      |
|------------------------------------|-------------|-------------|-----------------------------------------------|
| **Тактирование и управление**                                                      |
| `clk_i`                            | input       | 1 бит       | Тактовый сигнал                               |
| `rst_i`                            | input       | 1 бит       | Асинхронный сброс (активный высокий уровень)  |
| **Прерывания и исключения**                                                       |
| `intr_i`                           | input       | 1 бит       | Внешнее прерывание                            |
| `interrupt_inhibit_i`              | input       | 1 бит       | Запрет обработки прерываний                   |
| `take_interrupt_o`                 | output      | 1 бит       | Флаг обработки прерывания                     |
| **Интерфейс инструкций**                                                          |
| `opcode_valid_i`                   | input       | 1 бит       | Валидность текущей инструкции                 |
| `opcode_opcode_i`                  | input       | 32 бита     | Код инструкции                                |
| `opcode_pc_i`                      | input       | 32 бита     | Адрес инструкции                              |
| `opcode_invalid_i`                 | input       | 1 бит       | Флаг невалидной инструкции                    |
| `opcode_rd_idx_i`                  | input       | 5           | opcode_rd_idx_i                               |
| `opcode_ra_idx_i`                  | input       | 5           | Индекс первого операнда (rs1)                 |
| `opcode_rb_idx_i`                  | input       | 5           | Индекс второго операнда (rs2)                 |
| `opcode_ra_operand_i`              | input       | 32          | Первый операнд (rs1)                          |
| `opcode_rb_operand_i`              | input       | 32          | Второй операнд (rs2)                          |
| **Системные регистры (CSR)**                                                     |
| `csr_writeback_write_i`            | input       | 1 бит       | Запись в CSR                                  |
| `csr_writeback_waddr_i`            | input       | 12 бит      | Адрес CSR                                     |
| `csr_writeback_wdata_i`            | input       | 32 бита     | Данные для записи в CSR                       |
| `csr_result_e1_value_o`            | output      | 32 бита     | Прочитанное значение CSR                      |
| `csr_result_e1_write_o`            | output      | 1 бит       | Подтверждение записи в CSR                    |
| `csr_result_e1_wdata_o`            | output      | 32 бита     | Данные для записи в CSR                       |
| `csr_writeback_exception_i`        | input       | 6           | Код исключения                                |
| `csr_writeback_exception_pc_i`     | input       | 32          | Адрес инструкции, вызвавшей исключение        |
| `csr_writeback_exception_addr_i`   | input       | 32          | Адрес, связанный с исключением (например, для page fault)               |
| **Управление ветвлениями**                                                       |
| `branch_csr_request_o`             | output      | 1 бит       | Запрос ветвления по CSR                       |
| `branch_csr_pc_o`                  | output      | 32 бита     | Адрес ветвления по CSR                        |
| `branch_csr_priv_o`                | output      | 2 бита      | Уровень привилегий после ветвления            |
| **Управление памятью**                                                           |
| `ifence_o`                         | output      | 1 бит       | Сброс конвейера инструкций                    |
| `mmu_priv_d_o`                     | output      | 2 бита      | Уровень привилегий для MMU                    |
| `mmu_sum_o`                        | output      | 1 бит       | Разрешение доступа к пользовательской памяти  |
| `mmu_mxr_o`                        | output      | 1 бит       | Разрешение выполнения при чтении              |
| `mmu_flush_o`                      | output      | 1 бит       | Сброс TLB                                     |
| `mmu_satp_o`                       | output      | 32 бита     | Регистр трансляции адресов                    |
| **Идентификация и векторы**                                                      |
| `cpu_id_i`                         | input       | 32 бита     | Идентификатор процессора                      |
| `reset_vector_i`                   | input       | 32 бита     | Начальный адрес исполнения                    |
| **Исключения**                     |             |             |                                               |
| `csr_result_e1_exception_o`        | output      | 6           | Код исключения на стадии E1                   |

Таблица 10 - Основные внутренние сигналы подмодуля csr.  

| Категория               | Сигнал               | Тип    | Описание                                                                 |
|-------------------------|----------------------|--------|--------------------------------------------------------------------------|
| **Декодирование**       | `ecall_w`            | wire   | Флаг инструкции `ECALL` (вызов исключения)                               |
|                         | `ebreak_w`           | wire   | Флаг инструкции `EBREAK` (отладочное прерывание)                         |
|                         | `eret_w`             | wire   | Флаг инструкции `ERET` (возврат из исключения)                           |
|                         | `csrrw_w`            | wire   | Флаг инструкции `CSRRW` (чтение/запись CSR)                              |
|                         | `csrrs_w`            | wire   | Флаг инструкции `CSRRS` (установка битов CSR)                            |
| **Управление CSR**      | `current_priv_w`     | wire   | Текущий уровень привилегий (M/S/U)                                       |
|                         | `csr_priv_r`         | reg    | Требуемый уровень привилегий для доступа к CSR                           |
|                         | `csr_readonly_r`     | reg    | Флаг "только для чтения" CSR                                             |
|                         | `satp_update_w`      | wire   | Флаг обновления регистра `SATP` (виртуальная память)                     |
| **Исключения**          | `exception_e1_q`     | reg    | Код исключения на стадии E1                                              |
|                         | `eret_fault_w`       | wire   | Ошибка при `ERET` (недостаточные привилегии)                             |
| **Прерывания**          | `interrupt_w`        | wire   | Маска активных прерываний                                                |
|                         | `take_interrupt_q`   | reg    | Флаг разрешения обработки прерывания                                     |
| **MMU/TLB**             | `status_reg_w`       | wire   | Значение регистра `mstatus` (настройки MMU)                              |
|                         | `satp_reg_w`         | wire   | Значение регистра `satp` (таблица страниц)                               |
|                         | `tlb_flush_q`        | reg    | Флаг сброса TLB                                                          |
| **Переходы**            | `csr_branch_w`       | wire   | Запрос перехода (исключение/прерывание)                                  |
|                         | `csr_target_w`       | wire   | Адрес перехода (новый PC)                                                |
| **Системные**           | `misa_w`             | wire   | Регистр `misa` (поддерживаемые расширения CPU)                           |
|                         | `reset_q`            | reg    | Флаг начального сброса                                                   |

### Входные и выходные порты и основные внутренние сигналы подмодуля __lsu__
Таблица 11 - Входные и выходные порты подмодуля __lsu__.

#### Модуль LSU (Load-Store Unit)

| Категория          | Сигнал               | Направление | Разрядность | Описание                                  |
|--------------------|----------------------|-------------|-------------|-------------------------------------------|
| **Системные**      | `clk_i`              | Вход        | 1           | Тактовый сигнал                          |
|                    | `rst_i`              | Вход        | 1           | Сигнал сброса                            |
| **Инструкции**     | `opcode_valid_i`     | Вход        | 1           | Флаг валидности инструкции               |
|                    | `opcode_opcode_i`    | Вход        | 32          | Код инструкции                          |
|                    | `opcode_pc_i`        | Вход        | 32          | Адрес инструкции                        |
|                    | `opcode_rd_idx_i`    | Вход        | 5           | Индекс регистра назначения               |
|                    | `opcode_ra_idx_i`    | Вход        | 5           | Индекс регистра-источника A              |
|                    | `opcode_rb_idx_i`    | Вход        | 5           | Индекс регистра-источника B              |
|                    | `opcode_ra_operand_i`| Вход        | 32          | Данные регистра A                        |
|                    | `opcode_rb_operand_i`| Вход        | 32          | Данные регистра B                        |
| **Память**         | `mem_data_rd_i`      | Вход        | 32          | Прочитанные данные из памяти             |
|                    | `mem_accept_i`       | Вход        | 1           | Готовность памяти принять запрос         |
|                    | `mem_ack_i`          | Вход        | 1           | Подтверждение выполнения запроса         |
|                    | `mem_error_i`        | Вход        | 1           | Ошибка доступа к памяти                  |
|                    | `mem_load_fault_i`   | Вход        | 1           | Ошибка страницы при чтении               |
|                    | `mem_store_fault_i`  | Вход        | 1           | Ошибка страницы при записи               |
|                    | `mem_addr_o`         | Выход       | 32          | Адрес для доступа к памяти               |
|                    | `mem_data_wr_o`      | Выход       | 32          | Данные для записи                        |
|                    | `mem_rd_o`           | Выход       | 1           | Сигнал чтения                            |
|                    | `mem_wr_o`           | Выход       | 4           | Маска записи (по байтам)                 |
| **Кэш**            | `mem_cacheable_o`    | Выход       | 1           | Флаг кэшируемости адреса                 |
|                    | `mem_invalidate_o`   | Выход       | 1           | Инвалидация кэша                         |
|                    | `mem_writeback_o`    | Выход       | 1           | Запись данных кэша в память              |
|                    | `mem_flush_o`        | Выход       | 1           | Полный сброс кэша                        |
| **Конвейер**       | `writeback_valid_o`  | Выход       | 1           | Флаг валидности результата               |
|                    | `writeback_data_o`   | Выход       | 32          | Результат операции загрузки              |
|                    | `writeback_rd_idx_o` | Выход       | 5           | Индекс регистра для записи               |
|                    | `stall_o`            | Выход       | 1           | Сигнал остановки конвейера               |
| __Исключения__     | `exception_o`        | Выход       | 1           | Флаг исключения                          |
|                    | `exception_code_o`   | Выход       | 4           | Код исключения                           |

#### Пояснения:

##### Маска записи (`mem_wr_o`):
| Значение  | Тип доступа       |
|-----------|-------------------|
| `4'b0001` | Запись байта      |
| `4'b0011` | Запись полуслова  |
| `4'b1111` | Запись слова      |

##### Коды исключений (`exception_code_o`):
| Код  | Тип исключения            |
|------|---------------------------|
| 0001 | Misaligned access         |
| 0010 | Load page fault          |
| 0011 | Store page fault         |
| 0100 | Access fault             |
| 0101 | PMA violation            |

Таблица 12 - Основные внутренние сигналы подмодуля __lsu__.

| Категория               | Сигнал               | Тип    | Разрядность | Описание                                            |
|-------------------------|----------------------|--------|-------------|-----------------------------------------------------|
| **Управление доступом** | `addr_aligned`       | wire   | 1           | Флаг выровненного адреса (0 - невыровненный доступ) |
|                         | `access_size`        | reg    | 2           | Размер доступа: 00-байт, 01-полуслово, 10-слово     |
|                         | `load_store_n`       | reg    | 1           | Тип операции: 0-запись, 1-чтение                    |
|                         | `mem_req_valid`      | reg    | 1           | Флаг валидности запроса к памяти                    |
|                         | `mem_req_ready`      | wire   | 1           | Флаг готовности памяти принять запрос               |
| **Обработка данных**    | `data_reg`           | reg    | 32          | Буфер для данных записи/чтения                      |
|                         | `byte_sel`           | wire   | 4           | Выбор байтов для записи (активные биты)             |
|                         | `sign_extend`        | reg    | 1           | Флаг знакового расширения (для операций загрузки)   |
|                         | `load_data`          | wire   | 32          | Прочитанные данные после выравнивания и расширения  |
| **Управление FSM**      | `state`              | reg    | 2           | Текущее состояние: IDLE, REQ, WAIT, DONE            |
|                         | `next_state`         | wire   | 2           | Следующее состояние FSM                             |
| **Обработка ошибок**    | `misaligned_except`  | wire   | 1           | Флаг невыровненного доступа                         |
|                         | `bus_error`          | reg    | 1           | Флаг ошибки шины                                    |
|                         | `except_code`        | reg    | 3           | Код исключения                                      |
| **Буферизация**         | `addr_buf`           | reg    | 32          | Буфер адреса                                        |
|                         | `data_buf`           | reg    | 32          | Буфер данных                                        |
|                         | `rd_idx_buf`         | reg    | 5           | Буфер индекса регистра назначения                   |
| **Конвейер**            | `stall_req`          | reg    | 1           | Запрос на остановку конвейера                       |
|                         | `wb_valid`           | reg    | 1           | Флаг валидности обратной записи                     |
|                         | `wb_data`            | wire   | 32          | Данные для обратной записи в регистр                |

###№ Пояснения ключевых сигналов:

1. **`addr_aligned`**:
   - Проверяет выравнивание адреса в соответствии с размером доступа
   - Генерирует `misaligned_except` при нарушении выравнивания

2. **`state` (FSM состояния)**:
   - `IDLE`: Ожидание новой операции
   - `REQ`: Отправка запроса к памяти
   - `WAIT`: Ожидание ответа от памяти
   - `DONE`: Завершение операции

3. **`byte_sel`**:
   - Формируется на основе младших бит адреса и размера доступа
   - Пример: Для адреса 0x1003 и размера слова (32 бита) = 4'b1000

4. **`load_data`**:
   - Выполняет выравнивание данных (сдвиг вправо)
   - Знаковое/беззнаковое расширение в зависимости от `sign_extend`

5. **`except_code`**:
   - 000: Нет ошибки
   - 001: Невыровненный доступ
   - 010: Ошибка страницы (page fault)
   - 011: Ошибка прав доступа
   - 100: Ошибка устройства