## Руководство по программированию
### 3.0 Введение
В этом разделе мы рассмотрим, как программировать под BiriscV. Изучим процесс сборки и запуска приложения, каким методом собираетася программа, как она загружается в память и запускается. 

#### 3.0.1 Настройка окружения
Для программирования под BiriscV необхоимо установить следующие инструменты:
- [RISC-V GCC Toolchain](https://github.com/stnolting/riscv-gcc-prebuilt). Скачать релиз для `rv32i` и распоковать его в место, которое надо добавить в $PATH
- SystemC. Установить следующей командой 
```bash
    wget https://github.com/accellera-official/systemc/archive/refs/tags/3.0.1.tar.gz && \
    tar -xvzf 3.0.1.tar.gz && rm 3.0.1.tar.gz && \
    cd systemc-3.0.1 && \
    mkdir objdir && cd objdir && \
    export CXX=g++ && \
    ../configure && make && make install && \
    cd .. && rm -rf objdir
```
- Verilator. Установить командой из [репозитория](https://github.com/verilator/verilator) 
```bash
git clone https://github.com/verilator/verilator
cd verilator
autoconf         # Create ./configure script
./configure      # Configure and create Makefile
make -j `nproc`  # Build Verilator itself (if error, try just 'make')
sudo make install
```

### 3.1 Запуск 

Процесс магии, что происходит за выполнением команды `make` в папке `sw` (что содержит примеры для выполнения) можно разделить на несколько этапов:
- **Компиляция**. GCC компилирует исходный код в объектный файл. Помимо компиляции .c файлов, также .S (с большой буквы) обрабатываются gcc и позволяют, например, подключать другой код используя `#include`
- **Линковка**. Линковщик объединяет множество объектных фалйов, а также динамические библиотеки в один исполняемый файл. Работа линковщика заключается также в том, чтобы указать адрес исполнения программы, а также адреса всех используемых разделов памяти. На выходе после линковщика получается ELF файл, который содержит все необходимые данные для загрузки в память и исполнения.
- **Загрузка**. ELF файл загружается в память и запускается

#### 3.1.1 Линковка

> Линковщик (`linker`) -- инструмент, что собирает объектные `.o` файлы на выходе с ассемблера в единый исполняемый файл. Он должен удостовериться что все части сликнованны корректно 

![](scheme.png)
*Линковщик в процессе сборки*

Обычно, линковщик принимает участие
- в процессе компиляции, собирает весь код и библиотеки в один исполняемый файл
- в процессе загрузки программы в оперативную память, подгружая динамические библиотеки

##### Статическая линковка

Происходя во время комплияции программы, статическая линковка позволяет объеденить разрозненные файлы в один. После прохождения статической линковки, программа более не требует существования оригинальных .o файлов

Для упрощения, возьмем чистый ассемблер с двумя файлами -- `math.asm` и `main.asm`

```asm
global add        ; экспортируем функцию

section .text
add:
    ; int add(int a, int b)
    ; a в rdi, b в rsi
    mov rax, rdi   ; rax = a
    add rax, rsi   ; rax += b
    ret
```

```asm
extern add        ; импортируем функцию

section .text
global _start

_start:
    mov rdi, 5     ; первый аргумент (a)
    mov rsi, 7     ; второй аргумент (b)
    call add       ; вызвать внешнюю функцию

    ; Результат в rax, выведем его как exit-код
    mov rdi, rax   ; exit-код
    mov rax, 60    ; системный вызов exit
    syscall
```

Соберем эту программу, используя линковщик
```bash
nasm -f elf64 math.asm -o math.o
nasm -f elf64 main.asm -o main.o

ld main.o math.o -o program
```

И дизасэмблируем ее

```bash
$ objdump -d ./program 

./program:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <_start>:
  401000:       bf 05 00 00 00          mov    $0x5,%edi
  401005:       be 07 00 00 00          mov    $0x7,%esi
  40100a:       e8 11 00 00 00          callq  401020 <add>
  40100f:       48 89 c7                mov    %rax,%rdi
  401012:       b8 3c 00 00 00          mov    $0x3c,%eax
  401017:       0f 05                   syscall 
  401019:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000401020 <add>:
  401020:       48 89 f8                mov    %rdi,%rax
  401023:       48 01 f0                add    %rsi,%rax
  401026:       c3                      retq   
```

Видим, что функция add появилась внутри файла. А вызов заменился на вызов по определенному адрес (произошла реалокация)

Линковщик находит референсы на символы, и добавляет их в исходный файл. Отследить где конкретный символ был найден, можно используя `--trace-symbol <sym_name>`.


##### Динамическая линковка 
Динмаическая линковка, как и было описано ранее, происходит во время загрузки исполняемого кода в оперативную память. Именно из-за этого, например, запуск какой-нибудь executable почти на пустой системе без должного числа динамических библиотек невозможен. 

В репозитории с примерами также есть вариант статически зависимого кода от библиотеки `libcurl`. Он успешно соберется внутри отдельного dev docker образа, однако, из-за отсуствия этой динамической библиотеки в исполняемой среде запуститься не сможет

```bash
docker build -t curl-broken-runtime .
docker run --rm curl-broken-runtime
> ./main: error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory
```

Из этого примера очевидно основной плюс и основной минус статической линковки
- Сборка позволяет не подгружать на этапе компиляции в собранный файл тяжелые библиотеки. Помимо `libcurl` такой может являтся, например `libffmpeg` -- мощный комбайн для обработки медиа
- Из-за того, что библиотека подгружается динамически, ее отсуствие в другой среде не позволяет программе даже запуститься

Линковщик может реалоцировать и менять адреса "на лету", благодаря чему запуск идет корректно

Вот продолжение статьи, в том же стиле, на тему `.ld` файлов и конфигурации линковки:

##### Конфигурационные файлы линковщика (.ld)

> Файл линковки (`linker script` или `.ld`) — это специальный конфигурационный файл, который описывает, как линковщик должен разместить различные секции программы в памяти. Особенно важен при разработке низкоуровневого кода: embedded, OS kernel, bootloader, etc.
x
Линковщик по умолчанию умеет работать с простыми программами, размещая `.text`, `.data` и `.bss` в стандартные места. Но для системного программирования часто нужно полный контроль — и тут на сцену выходит `.ld` файл.

##### Простой пример `.ld` файла

Создадим простой `.ld` скрипт, который явно указывает, где начинаются секции `.text`, `.data` и `.bss`.

```ld
SECTIONS
{
  . = 0x400000;         /* Стартовая точка адресного пространства */

  .text : {
    *(.text)            /* Все .text секции из объектных файлов */
  }

  .data : {
    *(.data)
  }

  .bss : {
    *(.bss)
  }
}
```

Файл говорит линковщику:
- начать с адреса `0x400000`
- последовательно разместить `.text`, `.data` и `.bss` секции из всех `.o` файлов

Компилируем программу с использованием этого скрипта:

```bash
ld -T linker.ld main.o math.o -o program
```

Флаг `-T` передает скрипт линковщику.

##### Что можно контролировать через `.ld`

Файл `.ld` позволяет:

- Задать адреса начала памяти (`. = <addr>`)
- Разбить код по кастомным секциям
- Создавать "символы" для взаимодействия с кодом (`_start = .;`)
- Задать точку входа (`ENTRY(_start)`)
- Упаковать данные в конкретный адрес для embedded-систем

Пример с кастомными символами:

```ld
ENTRY(_start)

SECTIONS
{
  . = 0x10000;

  _text_start = .;
  .text : { *(.text) }
  _text_end = .;

  _data_start = .;
  .data : { *(.data) }
  _data_end = .;
}
```

Теперь из программы можно ссылаться на символы `_text_start`, `_text_end` и, например, копировать `.data` вручную на старте, как это принято в bare-metal.


##### Когда `.ld` необходим?

- **Микроконтроллеры**: размещение кода в flash, а данных — в RAM
- **Ядра ОС**: kernel должен начинаться с определенного адреса
- **Загрузчики**: специфичное размещение стека, переменных и таблиц
- **Оптимизация**: компактное размещение данных для уменьшения размера

##### Проверка структуры

Чтобы увидеть, как `.ld` скрипт повлиял на расположение, используем `readelf`:

```bash
readelf -S program
```

Или для визуального представления:

```bash
objdump -h program
```
