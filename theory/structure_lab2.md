# Структура лабораторной работы "Цифровые операционные устройства"

- [Структура лабораторной работы "Цифровые операционные устройства"](#структура-лабораторной-работы-цифровые-операционные-устройства)
  - [1. Цели и ход работы](#1-цели-и-ход-работы)
  - [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
    - [2.1 Сумматоры](#21-сумматоры)
      - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
    - [2.1.2 Сумматоры с ускоренным переносом](#212-сумматоры-с-ускоренным-переносом)
    - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
      - [2.2.1 Режимы работы АЛУ](#221-режимы-работы-алу)
    - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
      - [2.3.1 Микросхема 4х разрядного ускоренного переноса - 74181](#231-микросхема-4х-разрядного-ускоренного-переноса---74181)
      - [2.3.2 Микросхема 32х разрядного ускоренного переноса - 74882](#232-микросхема-32х-разрядного-ускоренного-переноса---74882)


## 1. Цели и ход работы 

## 2. Цифровые операционные устройства

### 2.1 Сумматоры

#### 2.1.1 Сумматоры с последовательным переносом
[Отсылка на литературу. Романов]()

### 2.1.2 Сумматоры с ускоренным переносом

Рассказываем про CLA сумматоры 

### 2.2 Арифметико - логическое устройство

#### 2.2.1 Режимы работы АЛУ

Арифметеческий режим

Логический режим

```sv
// f - fixed. Без конструкции generate
module alu_74181f(
    input [3:0]s,
    input Cin, M,
    input [3:0] a, b,
    output reg [3:0] y
);

    reg [3:0] p, g;

    always @(*) begin
        p[0] <= ~(a[0] | (s[0] & b[0]) | (s[1] & ~b[0]));
        p[1] <= ~(a[1] | (s[0] & b[1]) | (s[1] & ~b[1]));
        p[2] <= ~(a[2] | (s[0] & b[2]) | (s[1] & ~b[2]));
        p[3] <= ~(a[3] | (s[0] & b[3]) | (s[1] & ~b[3]));

        g[0] <= ~((a[0] & ~b[0] & s[2]) | (a[0] & b[0] & s[3]));
        g[1] <= ~((a[1] & ~b[1] & s[2]) | (a[1] & b[1] & s[3]));
        g[2] <= ~((a[2] & ~b[2] & s[2]) | (a[2] & b[2] & s[3]));
        g[3] <= ~((a[3] & ~b[3] & s[2]) | (a[3] & b[3] & s[3]));

        y[0] = (p[0] ^ g[0]) ^ ~(~Cin & ~M);
        y[1] = (p[1] ^ g[1]) ^ ~((~Cin & ~M & g[0]) | (~M & p[0]));
        y[2] = (p[2] ^ g[2]) ^ ~((~Cin & ~M & g[0] & g[1]) | (~M & p[1]) | (~M & p[0] & g[1]));
        y[3] = (p[3] ^ g[3]) ^ ~((~Cin & ~M & g[0] & g[1] & g[2]) | (~M & p[2]) | (~M & p[1] & g[2]) | (~M & p[0] & g[1] & g[2]));
    end


endmodule // alu74181
```

Листинг - RTL код четырех разрядного АЛУ 74181

### 2.3 Способы повышения разрядности цифровых операционных устройства

#### 2.3.1 Микросхема 4х разрядного ускоренного переноса - 74181

теория

Структура CLA

```sv
module cla_74182 (
    input[3:0]  nPB, 
    input[3:0]  nGB,
    input   Cn,
    output	PBo, GBo, Cnx, Cny, Cnz
);
    assign PBo = (  nPB[0]   |   nPB[1]   |   nPB[2]   |   nPB[3]);
    assign GBo = (  (nGB[0]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[2]  &   nGB[2]   &   nGB[3]) | 
                    (nPB[3]  &   nGB[3]));

    assign Cnx = ~( (nPB[0]  &   nGB[0]) | 
                    (nGB[0]  &   ~Cn));
    assign Cny = ~( (nPB[1]  &   nGB[1]) | 
                    (nPB[0]  &   nGB[0]   &   nGB[1])  |
                    (nGB[0]  &   nGB[1]   &   ~Cn));
    assign Cnz = ~( (nPB[2]  &   nGB[2]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2])  |
                    (nPB[0]  &   nGB[0]   &   nGB[1]   &   nGB[2])  | 
                    (nGB[0]  &   nGB[1]   &   nGB[2]   &   ~Cn));
endmodule

```
Листинг x - 

#### 2.3.2 Микросхема 32х разрядного ускоренного переноса - 74882


теория

Структура CLA

```sv
// Модуль ускоренного переноса с ПОЛОЖИТЕЛЬНЫМ (p) логическим уровнем
module carry32_p74882 (
    input [7:0] P,      // Пропускные сигналы
    input [7:0] G,      // Генерирующие сигналы
    input Cin,          // Входной перенос
    output [3:0] Cout   // Выходные переносы
);

    // Сокращенные записи с использованием generate
    genvar i;
    wire [7:0] PP;      // PP[i] = P[i] & P[i-1]
    wire [7:0] PG;      // PG[i] = P[i] & G[i-1]

    generate
        for (i = 1; i <= 7; i = i + 1) begin : gen_PP_PG
            assign PP[i] = P[i] & P[i-1];
            assign PG[i] = P[i] & G[i-1];
        end
    endgenerate

    assign Cout[0] = ((G[1]) | 
                     ( PG[1]) | 
                     ( PP[1] & Cin));
    assign Cout[1] = ((G[3]) |
                     ( PG[3]) | 
                     ( PP[3] & G[1]) | 
                     ( PP[3] & PG[1]) | 
                     ( PP[3] & PP[1] & ~Cin));

    assign Cout[2] = ((G[5]) |
                     ( PG[5]) | 
                     ( PP[5] & G[3]) | 
                     ( PP[5] & PG[3]) | 
                     ( PP[5] & PP[3] & G[1]) |
                     ( PP[5] & PP[3] & PG[1]) | 
                     ( PP[5] & PP[3] & PP[1] & ~Cin));
    
    assign Cout[3] = ((G[7]) | 
                     ( PG[7])| 
                     ( PP[7] & G[5]) | 
                     ( PP[7] & PG[5])| 
                     ( PP[7] & PP[5] & G[3]) | 
                     ( PP[7] & PP[5] & PG[3])| 
                     ( PP[7] & PP[5] & PP[3] & G[1]) | 
                     ( PP[7] & PP[5] & PP[3] & PG[1])| 
                     ( PP[7] & PP[5] & PP[3] & PP[1] & ~Cin));

endmodule
```

`