

Verilator - это инструмент, который компилирует исходные тексты Verilog и SystemVerilog в высоко оптимизированный (и, по желанию, многопоточный) код на C++ или SystemC с точностью до цикла. Преобразованные модули могут быть инстанцированы и использованы в тестовых стендах на C++ или SystemC для верификации и/или моделирования.


### Почему Verilator 

Verilator - это, по сути, симулятор Verilog/SystemVerilog. Он коммерческого класса, сверхбыстрый, бесплатный и с открытым исходным кодом, но он не является прямой заменой Modelsim, Questa Sim, Synopsys VCS, Vivado Xsim и других симуляторов, основанных на событиях. Verilator - это симулятор, основанный на циклах, что означает, что он не оценивает время в пределах одного тактового цикла и не моделирует точную синхронизацию схемы. Вместо этого состояние схемы, как правило, оценивается один раз за тактовый цикл, поэтому любые внутрипериодные глюки не могут быть замечены, а временные задержки сигналов не поддерживаются. Это имеет как преимущества, так и недостатки при сравнении Verilator с другими симуляторами.

### Скорость 

Поскольку Verilator основан на циклах, его нельзя использовать для моделирования синхронизации, нетлистов с обратным аннотированием, асинхронной (безчасовой) логики и вообще любых изменений сигналов, связанных с понятием времени - все выходы переключаются мгновенно, когда схема оценивается.

Однако, поскольку все, что происходит между фронтами тактовых импульсов, игнорируется, моделирование в Verilator выполняется чрезвычайно быстро и отлично подходит для моделирования функциональности синхронных цифровых логических схем с одним или несколькими тактовыми импульсами, а также для создания программных моделей из кода Verilog/SystemVerilog для использования в разработке программного обеспечения.

### Качество кода 

Поскольку verilator основан на циклах, он не может полностью поддерживать стандарты IEEE Verilog и SystemVerilog. Но не волнуйтесь, инструменты синтеза, как правило, тоже не полностью соответствуют этим стандартам.

Следовательно, Verilator очень строг к коду Verilog/SystemVerilog, который вы ему предоставляете. Помимо того, что он не поддерживает временные задержки, он также не принимает большинство несинтезируемого кода*, поэтому (как правило) вы не можете просто взять свой тестовый стенд на SystemVerilog и построить его с помощью Verilator без существенных изменений. Вы быстро поймете, что Verilator не поддерживает ваш код, так как он будет бомбардировать вас кучей предупреждений и сообщений об ошибках.

Поскольку Verilator не поддерживает несинтезируемый код, есть неожиданный плюс в том, что он ближе к поведению инструментов синтеза по сравнению с другими симуляторами. Это заставит вас писать более качественный код для синтеза, что потенциально уменьшит количество проблем, с которыми вы столкнетесь позже в процессе разработки.

* за исключением таких вещей, как $display(), $finish(), $fatal(), некоторых версий $assert и других.

### Цена 

Verilator имеет открытый исходный код и является бесплатным, как бесплатное пиво и свобода слова. Чтобы смоделировать проект с помощью Verilator, из верифицированного HDL-кода и тестового стенда на C++ с помощью GCC и Make собирается собственный двоичный исполняемый файл. Поскольку весь инструментарий является бесплатным, нет никаких ограничений на количество запущенных экземпляров или количество пользователей. Благодаря скорости работы Verilator, моделирование даже самых сложных конструкций быстро завершается на старых машинах и ноутбуках, поэтому вам не придется приобретать дорогостоящее вычислительное оборудование. Отличное решение для студентов!

Однако не позволяйте цене обмануть вас. У Verilator есть и широкий круг коммерческих пользователей:

### Начало работы 

Это руководство написано для тех, кто в основном знает Verilog/Systemverilog и немного C/C++, но никогда не использовал Verilator.

Я предположу, что вы используете какую-либо разновидность Linux в своей системе, и у вас установлены Verilator, GTKWave, Make и GCC.

Вы можете получить готовые исходные тексты для примера проекта Verilator, используемого в этом руководстве, с Github и изучить их по своему усмотрению:


### Наш DUT 
Чтобы проверить, как работает Verilator, нам нужно какое-то DUT (тестируемое устройство). Я написал базовое АЛУ на языке SystemVerilog, которое мы будем проверять в этой серии уроков, состоящей из нескольких частей, исходный текст которых приведен ниже:

Чтобы следовать этому руководству, создайте новый рабочий каталог и сохраните исходный текст ALU под именем alu.sv.

Как вы можете видеть, это АЛУ очень простое. В нем два каскада регистров, нет срыва, и он поддерживает только две операции: сложение и вычитание. Вот пример осциллограммы того, как должно вести себя АЛУ:


### Преобразование SystemVerilog в C++ 

#### Верилятор 

Как уже упоминалось во введении, Verilator требует, чтобы тестовый стенд на C++ был скомпилирован в двоичный файл родной системы. Однако мы не можем включить наше SystemVerilog ALU в C++ тестбенч как таковой: сначала нам нужно использовать Verilator для преобразования SystemVerilog кода в C++, или «верификации», которая в самой простой форме выполняется следующим образом:

```shell
    verilator --cc alu.sv
```


Параметр `--cc` указывает Verilator на преобразование в C++. Verilator также поддерживает преобразование в SystemC, что можно сделать с помощью параметра `--sc`, но сейчас мы не будем использовать эту функциональность.

Результаты преобразования 
Выполнение приведенной выше команды создает новую папку с именем obj_dir в нашем рабочем каталоге. Туда попадают все наши сконвертированные исходники:


