Verilator Это инструмент, который компилирует исходные коды Verilog и SystemVerilog в высокооптимизированный (и, при необходимости, многопоточный) код C++ или SystemC с точностью до цикла. Преобразованные модули можно создавать и использовать в тестовой среде C++ или SystemC для проверки и/или моделирования.

Verilator — это симулятор Verilog/SystemVerilog. Он используется в том числе для коммерческих целей, очень быстрый, бесплатный и с открытым исходным кодом, но не является прямой заменой других симуляторов на основе событий. Verilator — это циклический симулятор, то есть он не оценивает время в пределах одного тактового цикла и не моделирует точное время работы схемы. Вместо этого состояние схемы обычно оценивается один раз за такт, поэтому невозможно наблюдать какие-либо внутрипериодные сбои, а задержки сигналов по времени не поддерживаются. Это имеет как преимущества, так и недостатки по сравнению с другими симуляторами.

Поскольку Verilator работает на основе циклов, его нельзя использовать для моделирования временных интервалов, списков логических схем с положительно обратной связью, асинхронной (без тактовых импульсов) логики или в целом любых изменений сигналов, связанных с понятием времени. Все выходы переключаются мгновенно при оценке схемы.

**Скорость**

Однако, поскольку всё, что находится между фронтами тактового сигнала, игнорируется, моделирование в Verilator выполняется очень быстро и отлично подходит для имитации функциональности синхронных цифровых логических схем с одним или несколькими тактовыми сигналами, а также для создания программных моделей на основе кода Verilog/SystemVerilog для использования при разработке программного обеспечения.

**Качество кода**

Verilator очень требователен к коду Verilog/SystemVerilog, который ему предоставляется. Помимо того, что он не поддерживает временные задержки, он также не принимает большую часть кода, который нельзя синтезировать (за исключением таких элементов, как ```$display()```, ```$finish()```, ```$fatal()```), поэтому невозможнона основе тестового стенда SystemVerilog построить с помощью Verilator тестовый стенд без существенных изменений. Если Verilator не поддерживает код, он выдаст множество предупреждений и сообщений об ошибках.

Поскольку Verilator не поддерживает код, который нельзя синтезировать, у него есть неожиданное преимущество: он ближе к поведению инструментов синтеза, чем другие симуляторы. Это заставляет писать более качественный код для синтеза, что потенциально уменьшит количество проблем, с которыми возможно столкнутся в процессе разработки.

**Необходимые шаги для создания базовой тестовой установки**

1. Преобразование SystemVerilog в C ++
   
   Verilator требует, чтобы тестовая среда C++ компилировалась в собственный двоичный файл системы. Однако, включить исходный файл SystemVerilog в тестовую среду C++ в исходном виде невозможно: сначала необходимо использовать Verilator, чтобы преобразовать код SystemVerilog в C++ или «верифицировать» его, что в самой простой форме выглядит следующим образом:
   
   >verilator --cc test_file.sv

   Параметр ```--cc``` здесь указывает Verilator на необходимость преобразования в C++. Verilator также поддерживает преобразование в SystemC, которое можно выполнить с помощью ```--sc```.

   При выполнении приведённой выше команды в рабочем каталоге создаётся новая папка с именем ```obj_dir```. Именно туда попадают преобразованные исходные коды.

   Сгенерированные файлы ```.mk``` будут использоваться с Make для создания исполняемого файла для моделирования, а файлы ```.h``` и ```.cpp``` содержат наши заголовки C++ и исходные коды, полученные в результате преобразования SystemVerilog.
2. Разработка базового тестового стенда Verilator
   
   После преобразования DUT в C++, можно приступить к написанию тестового стенда. Тестовый стенд будет находиться в новом файле с именем ```tb_alu.cpp```. Необходимо начать с изучения минимального примера кода тестового стенда на C++.
  
   ```cpp
    #include <stdlib.h>
    #include <iostream>
    #include <verilated.h>
    #include <verilated_vcd_c.h>
    #include "Valu.h"
    #include "Valu___024unit.h"

    #define MAX_SIM_TIME 20
    vluint64_t sim_time = 0;

    int main(int argc, char** argv, char** env) {
        Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut->clk ^= 1;
        dut->eval();
        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
    }
    ```
    Первые несколько строк с операторами ```include``` говорят сами за себя. Необходимо включить ```<verilated.h>``` и ```<verilated_vcd_c.h>```, которые поставляются вместе с Verilator, чтобы получить доступ к стандартным процедурам Verilator и записать сигналы в файл VCD (сброса значений).

    ```"Valu.h"``` содержит верхний класс модуля Verilated ALU, а ```"Valu___024unit.h"``` содержит Verilated-версию перечисления typedef.

   Рассмотрим подробнее следующие две строки:
   ```cpp
    #define MAX_SIM_TIME 20
    vluint64_t sim_time = 0;
    ```
    Переменная ```sim_time``` необходима для отслеживания завершения симуляции. Программа остановимся после того, как промоделируем 20 тактовых импульсов.

    Затем следует основная функция:

    ```cpp
    int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    /* <...> */

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
    }
    ```
    Строка ```Valu *dut = new Valu;``` создаёт экземпляр преобразованного модуля АЛУ. В SystemVerilog это примерно соответствует ```alu dut (.*);```.

    Следующие четыре строки настраивают вывод сигналов. В частности, создается объект ```m_trace``` и передается в dut в строке ```dut->trace(m_trace, 5);```. Параметр 5 ограничивает глубину трассировки до 5 уровней ниже тестируемого устройства.

    Приведенный ниже код отвечает за симуляцию:

    ```cpp
    while (sim_time < MAX_SIM_TIME) {
    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
    }
    ```
    Во время каждой итерации цикла while строка ```dut->clk ^= 1;``` инвертирует тактовый сигнал АЛУ (это создаст нарастающий/спадающий фронт тактового сигнала).

    Вызов ```dut->eval();``` вычисляет все сигналы в модуле АЛУ, а ```m_trace->dump(sim_time);``` записывает все значения отслеживаемых сигналов в файл дампа формы волны. На данном этапе модель вычисляется только по фронтам тактового сигнала.

    Затем время симуляции увеличивается, и цикл продолжается до тех пор, пока не достигнет MAX_SIM_TIME. Важно, что на самом деле это не значение time — переменная просто отслеживает, сколько раз были инвертированы часы.

3. Построение исполняемого файла моделирования
   
   Для запуска моделирования необходимо создать запускаемый файл. Приложение Verilator используется только для преобразования Verilog в C++ и создания инструкций по сборке для Make. Симулятором является сам тестовый стенд C++.

    Тестовый стенд — это, по сути, приложение на C++, которое собирается и запускается на компьютере. При запуске скомпилированного исполняемого файла имитируется разработка, а GNU Compiler Collection (GCC) является дефолтным выбором для создания исполняемых файлов Verilator.

    Чтобы создать исполняемый файл для моделирования, необходимо заново сгенерировать файлы ```.mk``` и включить тестовый стенд C++ — это делается с помощью ```--exe tb_alu.cpp```:
    >$ verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp
    
    Эта команда преобразует исходный код alu.sv в C++ и генерирует файлы сборки для создания исполняемого файла моделирования. Команда ```-Wall``` используется для отображения всех ошибок C++,```--trace``` для отслеживания сигналов, ```-cc alu.sv``` для преобразования модуля ```alu.sv``` в C++ и ```--exe tb_alu.cpp``` для указания Verilator, какой файл является нашим тестовым стендом на C++.

    >make -C obj_dir -f Valu.mk Valu

    Эта команда позволяет создать исполняемый файл для моделирования на основе тестового стенда и преобразованных исходных кодов. Данная команда указываем Make изменить рабочий каталог на    ```obj_dir```, использовать файл сборки с именем ```Valu.mk``` и создать цель с именем ```Valu```

    >./obj_dir/Valu
     
    Эта команда запускает исполняемый файл для моделирования, который имитирует испытательный стенд и генерирует сигналы.

Постоянно растущая сложность проектов FPGA и ASIC приводит к ужесточению требований к верификации. Поэтому возросший спрос на продвинутые тестовые стенды привёл к появлению новых методологий и инструментов, таких как OVM, VVM, UVM, SystemC, а также различных фреймворков на основе Python. И все эти инструменты направлены на достижение одной цели — упрощение создания мощных самопроверяющихся тестовых стендов из многократно используемых компонентов, при этом увеличивая охват кода, сводя к минимуму дублирование кода. 

Один из основных способов, с помощью которых вышеупомянутые инструменты достигают этой цели, заключается в том, что они пораждают тестовые сценарии в транзакционном стиле. Тестовый стенд в транзакционном стиле — это тестовый стенд, который использует транзакции, предоставляющие уровень абстракции, который позволяет напрямую присваивать значения входным контактам и напрямую проверять значения выходных контактов тестируемого устройства (DUT).

В традиционном тестовом стенде, написанном на VHDL, Verilog, SystemVerilog или C++, обычно есть экземпляр тестируемого устройства, а также длинный поведенческий код с циклами и условными операторами, которые последовательно управляют входами тестируемого устройства, чтобы оно переходило из одного состояния в другое. В большинстве случаев такие тестовые стенды проверяют на корректность путём визуального анализа сигналов, но возможно и добавить сомопроверку с помощью утверждений или написать код мониторинга.

В отличие от этого, транзакционный тестовый стенд обеспечивает строгое разделение между различными функциональными блоками, каждый из которых взаимодействует с помощью транзакций. Базовый транзакционный тестовый стенд может состоять из:
- блок, генерирующий входные данные для DUT (генератора транзакций / последовательности);
- блок, который передает вышеупомянутые данные в ИУ (драйвер);
- блок, который отслеживает выходные данные DUT и генерирует пакеты с результатами (монитор);
- блок, который собирает различные пакеты данных, а затем сравнивает их на предмет правильности (табло);
- блок, который собирает различные пакеты данных и вычисляет функциональное покрытие (покрытие).

Важно отметить, что существенным недостатком транзакционных тестовых стендов является их сложность — из-за большого количества отдельных функциональных блоков, которые необходимо создать, запуск базового моделирования происходит гораздо медленнее. Однако в обмен на дополнительные усилия вы получаете беспрецедентную гибкость и возможность повторного использования.

Например, если в вашем испытательном стенде есть драйвер, поддерживающий интерфейс типа A, вы можете повторно использовать тот же самый драйвер с любым другим испытуемым устройством, у которого также есть интерфейс типа A. Единственное, что нужно изменить, — это передаваемые ему данные. Если интерфейс типа A заменяется на интерфейс типа B, вы просто заменяете блок драйвера указанного интерфейса с типа A на тип B, а остальную часть испытательного стенда оставляете без изменений.

**Базовая блок-схема транзакционного тестового стенда**

Ниже приведен пример того, как устроен современный транзакционный тестовый стенд:

![alt text](https://itsembedded.com/static/dhd/verilator_4/basic_tb_transactional.jpg)

*Транзакция и элемент транзакции*

Транзакция — это операция обмена данными высокого уровня, а элемент транзакции — пакет данных, или, другими словами, набор данных или инструкций. Обычно пакеты реализуются в виде класса или структуры и содержат данные, которые отправляются или принимаются устройством.

![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_item.jpg)

*Генератор транзакций* 

Генератор транзакций (его также называют генератором случайных транзакций, генератором стимулов, генератором элементов транзакций или генератором случайных входных данных) — это класс или блок кода, который генерирует (создаёт) элементы транзакций, используемые в качестве инструкций для управления входными интерфейсами тестируемого устройства.

![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_generator.jpg)

*Драйвер*

Драйвер это набор компонент, которые принимают элементы транзакций и на основе данных, содержащихся в этих элементах, управляют физическими выводами входного интерфейса с помощью 1 и 0, чтобы передавать данные в тестируемое устройство.

![alt text](https://itsembedded.com/static/dhd/verilator_4/driver.jpg)

*Интерфейс* 

Интерфейс — это просто набор или группа контактов, которые используются для выполнения определённой функции. Например, у FIFO обычно есть два интерфейса: вход и выход, а у двухтактовой оперативной памяти их может быть четыре: вход для порта $A$, выход для порта $A$, вход для порта $B$, выход для порта $B$.

![alt text](https://itsembedded.com/static/dhd/verilator_4/interface.jpg)

*Монитор* 

Это практически полная противоположность драйверу: вместо того, чтобы управлять состоянием физических контактов на интерфейсах, они пассивно наблюдают (мониторят) за тем, что происходит на интерфейсе. Мониторы обычно подключаются к выходному интерфейсу, где они используются для проверки выходных данных тестируемого устройства. Кроме того, их можно подключить к входным интерфейсам, где они могут проверять, что соответствующий драйвер правильно управляет интерфейсом.

То, что они делают с данными, полученными в результате наблюдения за волновыми сигналами, зависит от функционала испытательного стенда. Мониторы могут быть полностью автономными и самопроверяющимися, то есть они могут напрямую выполнять код, который проверяет правильность волновых сигналов по мере возникновения событий на интерфейсе. Однако чаще всего мониторы предназначены для создания новых транзакций на основе наблюдаемых изменений состояния контактов интерфейса. Полученные в результате транзакции отправляются в аналитические порты информационных панелей.

![alt text](https://itsembedded.com/static/dhd/verilator_4/monitor.jpg)

*Табло* 

Структура табло обычно содержит большую часть кода самопроверяющегося тестового стенда. Одно табло имеет один или несколько аналитических (прослушивающих) портов, которые используются для получения элементов транзакций от мониторов. Табло проверяет полученные элементы транзакций, чтобы убедиться, что наблюдаемые входные стимулы приводят к правильным выходным результатам, и определяет, пройден ли тест или нет.

Как правило, в тестовом стенде используется одно табло, но, при необходимости, есть возможность создать несколько экземпляров.

![alt text](https://itsembedded.com/static/dhd/verilator_4/scoreboard.jpg)