# Verilator Pt.2: Основы верификации SystemVerilog с использованием C++

В первой части мы обсудили основы использования Verilator и написания тестовых стендов на C++ для модулей Verilog/SystemVerilog. В этом руководстве мы улучшим тестовый стенд, добавив случайные начальные значения для сигналов, добавим сигнал сброса и, наконец, добавим проверку входных стимулов и выходных сигналов, чтобы начать работу с базовой функциональностью верификации.

## Начало работы 

Это руководство является прямым продолжением первой части. Вы можете получить готовые исходные тексты для примера проекта Verilator, используемого в этом руководстве, с Github и изучить их по своему усмотрению:

## Длинные команды - для троглодитов 
Прежде чем что-то делать с нашим тестовым стендом, следует сказать, что никому не нравится набирать одни и те же команды снова и снова. А поскольку мы не пещерные люди, мы будем использовать (Make)[https://www.gnu.org/software/make/] для быстрой сборки и запуска нашего симулятора, быстро продвигая наши возможности проектирования аппаратного обеспечения в каменный век.

Большинство команд сборки, используемых в приведенном ниже Makefile, должны быть знакомы вам по первой части, но на всякий случай давайте вкратце повторим их:

verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp 

Это преобразует наш исходный файл alu.sv в C++ и генерирует файлы сборки для создания исполняемого файла симуляции. Мы используем -Wall, чтобы включить все ошибки C++, --trace, чтобы включить трассировку формы волны, -cc alu.sv, чтобы преобразовать наш модуль alu.sv в C++, и --exe tb_alu.cpp, чтобы указать Verilator, какой файл является нашим тестовым стендом C++.

make -C obj_dir -f Valu.mk Valu 
Это создаст наш исполняемый файл для моделирования из тестового стенда и преобразованных исходных текстов. Мы указываем Make изменить рабочий каталог на obj_dir, использовать файл сборки с именем Valu.mk и построить цель с именем Valu

./obj_dir/Valu 
Это запустит наш исполняемый файл симуляции, который смоделирует тестовый стенд и сгенерирует наши осциллограммы.

В рабочем каталоге создайте файл с именем Makefile и вставьте в него следующее содержимое:

ПРИМЕЧАНИЕ: Не перетаскивайте выделение и CTRL+C, вместо этого наведите курсор мыши и нажмите на появившуюся кнопку COPY в правом верхнем углу текстового поля.


Makefile должен быть простым для тех, кто знаком с Make. Если вы не использовали Make раньше, пожалуйста, посмотрите другое из моих руководств по использованию Make для моделирования.

После сохранения файла вы сможете быстро перестроить всю симуляцию, запустив make sim в терминале, открыть GTKWave с помощью make waves, верифицировать ваш дизайн с помощью make verilate или собрать верифицированные исходники с помощью make build.

Обратите внимание, что существует дополнительная цель make lint, которая вызывает Verilator с параметром --lint-only. Это полезно для быстрого разбора исходных файлов Verilog/SystemVerilog и проверки на наличие проблем. Это можно использовать для проверки исходных текстов, даже если вы не используете Verilator для моделирования.

Наконец, есть цель make clean, которая удаляет весь мусор, сгенерированный в процессе сборки.

Ну а теперь, когда все это пройдено, давайте заставим этот тестовый стенд сверкать.


## Случайные начальные значения 

Одним из наблюдений, сделанных в первой части, было то, что Verilator - это симулятор двух состояний, то есть он поддерживает только логические значения 1 и 0, и в нем нет поддержки X (и лишь ограниченная поддержка Z). Поэтому Verilator по умолчанию инициализирует все сигналы в 0, что видно на рис. 1 из наших предыдущих результатов моделирования:


Кроме того, если у вас есть код, который присваивает X проводу или регистру, то по умолчанию он также получает значение 0.

Однако мы можем изменить это поведение с помощью параметров командной строки - мы можем попросить Verilator инициализировать все сигналы в 1, или, что еще лучше, в случайное значение. Это позволит нам проверить, работает ли наш сигнал сброса, как только мы добавим его в тестбенч.

Чтобы заставить наш тестовый стенд инициализировать сигналы случайными значениями, нам нужно сначала вызвать Verilated::commandArgs(argc, argv); перед созданием объекта DUT:

Затем нам нужно обновить нашу команду сборки цели верификации, добавив --x-assign unique и --x-initial unique. Таким образом, строка 31 нашего Makefile должна выглядеть следующим образом:

```shell
verilator -Wall --trace --x-assign unique --x-initial unique -cc $(MODULE).sv --exe tb_$(MODULE).cpp
```

Наконец, нам нужно передать +verilator+rand+reset+2 в исполняемый файл симуляции, чтобы установить случайный метод инициализации сигнала во время выполнения. Это означает изменение строки 21 в нашем Makefile на:



В строке 3 я произвольно выбрал, что сброс должен происходить между тактовыми фронтами 3 и 5. Вы, конечно, можете скорректировать это, если потребуется.

В строке 4 сброс подается на высокий уровень, а в последующих строках все входы ИУ сбрасываются в 0.

Линии 11-14 не изменяются. Мы тикаем часы и инкрементируем счетчик времени.

Строка 2 добавлена для сброса счетчика в 0 при последующих итерациях цикла. Вместе строки 2-3-4 в коде SystemVerilog будут эквивалентны следующему:

```sv
always_comb begin
    dut.rst = 1'b0;
    if (sim_time >= 3 && sim_time < 6) begin
        dut.rst = 1'b1;
    end
end
```

Как видно из рисунка 3, наш сигнал сброса успешно генерируется в тестовом стенде. Чтобы сохранить главный цикл немного чище, давайте перенесем сброс в отдельную функцию вне main():

```cpp
void dut_reset (Valu *dut, vluint64_t &sim_time){
    dut->rst = 0;
    if(sim_time >= 3 && sim_time < 6){
        dut->rst = 1;
        dut->a_in = 0;
        dut->b_in = 0;
        dut->op_in = 0;
        dut->in_valid = 0;
    }
}

```

Затем мы добавляем вызов `dut_reset` в главный цикл:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```

Теперь, когда наш сброс работает, давайте посмотрим на реальные стимулы и проверочный код.

### Базовая верификация 
На данный момент в нашем основном цикле моделирования мы имеем следующее:

```cpp
while (sim_time < MAX_SIM_TIME) {
    dut_reset(dut, sim_time);

    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
}
```


Теперь, если бы мы моделировали тестовый стенд Verilog/SystemVerilog в качестве dut вместо нашего модуля alu, мы могли бы добавить проверку Verilated::gotFinish() и остановить моделирование, если это значение равно true. Это происходит, когда $finish() вызывается из Verilog/SystemVerilog. Тогда нашего тестового стенда на C++ будет достаточно для моделирования тестового стенда Verilog/SystemVerilog.

Однако нам этого будет недостаточно, поскольку нам нужно вставить код стимуляции и верификации где-то в главном цикле C++-тестбенча, чтобы управлять и проверять наш DUT.

## Счетчик фронтов тактовых импульсов 
Есть много способов снять шкуру с мертвой лошади одним камнем, но мы пока поступим следующим образом:

Во-первых, мы создадим новую переменную для подсчета положительных фронтов тактового генератора. Эта переменная будет иметь тот же тип, что и sim_time:

```cpp
    vluint64_t sim_time = 0;
    vluint64_t posedge_cnt = 0;
```

Далее мы модифицируем наш код генерации фронтов, добавив счетчик положительных фронтов:

