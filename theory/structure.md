# Структура лабораторной работы "Цифровые операционные устройства"

- [Структура лабораторной работы "Цифровые операционные устройства"](#структура-лабораторной-работы-цифровые-операционные-устройства)
  - [1. Цели и ход работы](#1-цели-и-ход-работы)
  - [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
    - [2.1 Сумматоры](#21-сумматоры)
      - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
    - [2.1.2 Сумматоры с ускоренным переносом](#212-сумматоры-с-ускоренным-переносом)
    - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
      - [2.2.1 Режимы работы АЛУ](#221-режимы-работы-алу)
    - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
      - [2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181](#231-микросхема-4-разрядного-ускоренного-переноса--74181)
      - [2.3.2 Микросхема 32х разрядного ускоренного переноса - 74882](#232-микросхема-32х-разрядного-ускоренного-переноса---74882)


## 1. Цели и ход работы 

## 2. Цифровые операционные устройства

### 2.1 Сумматоры

#### 2.1.1 Сумматоры с последовательным переносом
[Отсылка на литературу. Романов]()

### 2.1.2 Сумматоры с ускоренным переносом

Рассказываем про CLA сумматоры 

### 2.2 Арифметико - логическое устройство

Постоянно растущая сложность проектов FPGA и ASIC приводит к ужесточению требований к верификации. Поэтому возросший спрос на продвинутые тестовые стенды привёл к появлению новых методологий и инструментов, таких как OVM, VVM, UVM, SystemC, а также различных фреймворков на основе Python. И все эти инструменты направлены на достижение одной цели — упрощение создания мощных самопроверяющихся тестовых стендов из многократно используемых компонентов, при этом увеличивая охват кода, сводя к минимуму дублирование кода. 

Один из основных способов, с помощью которых вышеупомянутые инструменты достигают этой цели, заключается в том, что они пораждают тестовые сценарии в транзакционном стиле. Тестовый стенд в транзакционном стиле — это тестовый стенд, который использует транзакции, предоставляющие уровень абстракции, который позволяет напрямую присваивать значения входным контактам и напрямую проверять значения выходных контактов тестируемого устройства (DUT).

В традиционном тестовом стенде, написанном на VHDL, Verilog, SystemVerilog или C++, обычно есть экземпляр тестируемого устройства, а также длинный поведенческий код с циклами и условными операторами, которые последовательно управляют входами тестируемого устройства, чтобы оно переходило из одного состояния в другое. В большинстве случаев такие тестовые стенды проверяют на корректность путём визуального анализа сигналов, но возможно и добавить сомопроверку с помощью утверждений или написать код мониторинга.

В отличие от этого, транзакционный тестовый стенд обеспечивает строгое разделение между различными функциональными блоками, каждый из которых взаимодействует с помощью транзакций. Базовый транзакционный тестовый стенд может состоять из:
- блок, генерирующий входные данные для DUT (генератора транзакций / последовательности);
- блок, который передает вышеупомянутые данные в ИУ (драйвер);
- блок, который отслеживает выходные данные DUT и генерирует пакеты с результатами (монитор);
- блок, который собирает различные пакеты данных, а затем сравнивает их на предмет правильности (табло);
- блок, который собирает различные пакеты данных и вычисляет функциональное покрытие (покрытие).

Важно отметить, что существенным недостатком транзакционных тестовых стендов является их сложность — из-за большого количества отдельных функциональных блоков, которые необходимо создать, запуск базового моделирования происходит гораздо медленнее. Однако в обмен на дополнительные усилия вы получаете беспрецедентную гибкость и возможность повторного использования.

Например, если в вашем испытательном стенде есть драйвер, поддерживающий интерфейс типа A, вы можете повторно использовать тот же самый драйвер с любым другим испытуемым устройством, у которого также есть интерфейс типа A. Единственное, что нужно изменить, — это передаваемые ему данные. Если интерфейс типа A заменяется на интерфейс типа B, вы просто заменяете блок драйвера указанного интерфейса с типа A на тип B, а остальную часть испытательного стенда оставляете без изменений.

**Базовая блок-схема транзакционного тестового стенда**
Ниже приведен пример того, как устроен современный транзакционный тестовый стенд:
![alt text](https://itsembedded.com/static/dhd/verilator_4/basic_tb_transactional.jpg)

*Транзакция и элемент транзакции*
Транзакция — это операция обмена данными высокого уровня, а элемент транзакции — пакет данных, или, другими словами, набор данных или инструкций. Обычно пакеты реализуются в виде класса или структуры и содержат данные, которые отправляются или принимаются устройством.
![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_item.jpg)

*Генератор транзакций* 
Генератор транзакций (его также называют генератором случайных транзакций, генератором стимулов, генератором элементов транзакций или генератором случайных входных данных) — это класс или блок кода, который генерирует (создаёт) элементы транзакций, используемые в качестве инструкций для управления входными интерфейсами тестируемого устройства.
![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_generator.jpg)

*Драйвер*
Драйвер это набор компонент, которые принимают элементы транзакций и на основе данных, содержащихся в этих элементах, управляют физическими выводами входного интерфейса с помощью 1 и 0, чтобы передавать данные в тестируемое устройство.
![alt text](https://itsembedded.com/static/dhd/verilator_4/driver.jpg)

*Интерфейс* 
Интерфейс — это просто набор или группа контактов, которые используются для выполнения определённой функции. Например, у FIFO обычно есть два интерфейса: вход и выход, а у двухтактовой оперативной памяти их может быть четыре: вход для порта A, выход для порта A, вход для порта B, выход для порта B.
![alt text](https://itsembedded.com/static/dhd/verilator_4/interface.jpg)

*Монитор* 
Это практически полная противоположность драйверу: вместо того, чтобы управлять состоянием физических контактов на интерфейсах, они пассивно наблюдают (мониторят) за тем, что происходит на интерфейсе. Мониторы обычно подключаются к выходному интерфейсу, где они используются для проверки выходных данных тестируемого устройства. Кроме того, их можно подключить к входным интерфейсам, где они могут проверять, что соответствующий драйвер правильно управляет интерфейсом.

То, что они делают с данными, полученными в результате наблюдения за волновыми сигналами, зависит от функционала испытательного стенда. Мониторы могут быть полностью автономными и самопроверяющимися, то есть они могут напрямую выполнять код, который проверяет правильность волновых сигналов по мере возникновения событий на интерфейсе. Однако чаще всего мониторы предназначены для создания новых транзакций на основе наблюдаемых изменений состояния контактов интерфейса. Полученные в результате транзакции отправляются в аналитические порты информационных панелей.
![alt text](https://itsembedded.com/static/dhd/verilator_4/monitor.jpg)

*Табло* 
Структура табло обычно содержит большую часть кода самопроверяющегося тестового стенда. Одно табло имеет один или несколько аналитических (прослушивающих) портов, которые используются для получения элементов транзакций от мониторов. Табло проверяет полученные элементы транзакций, чтобы убедиться, что наблюдаемые входные стимулы приводят к правильным выходным результатам, и определяет, пройден ли тест или нет.

Как правило, в тестовом стенде используется одно табло, но, при необходимости, есть возможность создать несколько экземпляров.
![alt text](https://itsembedded.com/static/dhd/verilator_4/scoreboard.jpg)

#### 2.2.1 Режимы работы АЛУ

Арифметеческий режим

Логический режим

```sv
// f - fixed. Без конструкции generate
module alu_74181f(
    input [3:0]s,
    input Cin, M,
    input [3:0] a, b,
    output reg [3:0] y
);

    reg [3:0] p, g;

    always @(*) begin
        p[0] <= ~(a[0] | (s[0] & b[0]) | (s[1] & ~b[0]));
        p[1] <= ~(a[1] | (s[0] & b[1]) | (s[1] & ~b[1]));
        p[2] <= ~(a[2] | (s[0] & b[2]) | (s[1] & ~b[2]));
        p[3] <= ~(a[3] | (s[0] & b[3]) | (s[1] & ~b[3]));

        g[0] <= ~((a[0] & ~b[0] & s[2]) | (a[0] & b[0] & s[3]));
        g[1] <= ~((a[1] & ~b[1] & s[2]) | (a[1] & b[1] & s[3]));
        g[2] <= ~((a[2] & ~b[2] & s[2]) | (a[2] & b[2] & s[3]));
        g[3] <= ~((a[3] & ~b[3] & s[2]) | (a[3] & b[3] & s[3]));

        y[0] = (p[0] ^ g[0]) ^ ~(~Cin & ~M);
        y[1] = (p[1] ^ g[1]) ^ ~((~Cin & ~M & g[0]) | (~M & p[0]));
        y[2] = (p[2] ^ g[2]) ^ ~((~Cin & ~M & g[0] & g[1]) | (~M & p[1]) | (~M & p[0] & g[1]));
        y[3] = (p[3] ^ g[3]) ^ ~((~Cin & ~M & g[0] & g[1] & g[2]) | (~M & p[2]) | (~M & p[1] & g[2]) | (~M & p[0] & g[1] & g[2]));
    end


endmodule // alu74181
```

Листинг - RTL код четырех разрядного АЛУ 74181

### 2.3 Способы повышения разрядности цифровых операционных устройства
Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​
#### 2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181

Микросхема 74181 представляет собой 4-разрядное арифметико-логическое устройство (АЛУ), способное выполнять 16 логических и 16 арифметических операций над двумя 4-битными словами. Она поддерживает операции сложения, вычитания, инкремента, декремента, а также логические функции, такие как AND, OR, XOR.

Ключевой особенностью 74181 является использование схемы ускоренного переноса (carry-lookahead), которая позволяет значительно повысить скорость выполнения операций по сравнению с традиционным последовательным переносом. Это достигается за счёт вычисления сигналов генерации (G) и распространения (P) переноса для каждого бита, что позволяет предсказать переносы на более высокие разряды без необходимости ожидания завершения операций в младших разрядах.

Назначение входов/выходов микросхемы: 
- A0-A3 и B0-B3 - четырёхразрядные двоичные суммируемые операнды; 
- S0-S3 - четыре входа выбора позволяют выбрать одну из 16 возможных функций, в зависимости от состояния сигнала на линии M (Mode Control) (M=0 - арифметические операции над прямым кодом операндов А и В при С=1; M=1 - логические операции над прямым кодом операндов); 
- F0-F3 - 4-битный результат выбранной операции; 
- P, G - выходы подключения к блоку ускоренного переноса при каскадировании; 
- (А=В) = бинарный признак равенства операндов в операции сравнения; 
- Cn (Carry In), Cn+4 - входной и выходной признаки переноса. Если операция даёт перенос, то он появляется на выходе Cn+4. Этот перенос можно передавать в следующую микросхему, если нужно работать с числами больше 4 бит.


![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74181.png)

Структура CLA

```sv
module cla_74182 (
    input[3:0]  nPB, 
    input[3:0]  nGB,
    input   Cn,
    output	PBo, GBo, Cnx, Cny, Cnz
);
    assign PBo = (  nPB[0]   |   nPB[1]   |   nPB[2]   |   nPB[3]);
    assign GBo = (  (nGB[0]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[2]  &   nGB[2]   &   nGB[3]) | 
                    (nPB[3]  &   nGB[3]));

    assign Cnx = ~( (nPB[0]  &   nGB[0]) | 
                    (nGB[0]  &   ~Cn));
    assign Cny = ~( (nPB[1]  &   nGB[1]) | 
                    (nPB[0]  &   nGB[0]   &   nGB[1])  |
                    (nGB[0]  &   nGB[1]   &   ~Cn));
    assign Cnz = ~( (nPB[2]  &   nGB[2]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2])  |
                    (nPB[0]  &   nGB[0]   &   nGB[1]   &   nGB[2])  | 
                    (nGB[0]  &   nGB[1]   &   nGB[2]   &   ~Cn));
endmodule

```
Листинг x - 

#### 2.3.2 Микросхема 32х разрядного ускоренного переноса - 74882

Микросхема 74882 — это специализированный блок ускоренного переноса, предназначенный для использования в составе высокоразрядных АЛУ. Она не является самостоятельным АЛУ, как 74181, а служит в качестве расширителя CLA-схемы, обеспечивая обработку переноса между группами по 4 бита, в общей сложности — до 32 разрядов.

Использование 74882 позволяет значительно сократить время выполнения операций сложения и вычитания за счёт параллельной обработки переносов между группами разрядов. Это особенно важно в системах, требующих высокой производительности, таких как процессоры и цифровые сигнальные процессоры.

Назначение входов/выходов микросхемы:
- P0–P7 – входы распространения переноса от восьми 4-битных арифметических блоков (например, от микросхем 74181); указывают, способен ли каждый блок передать перенос дальше при его наличии.
- G0–G7 – входы генерации переноса от тех же восьми 4-битных блоков; сигнализируют о том, что соответствующий блок обязательно создаёт перенос независимо от входного значения переноса.
- Cn – вход переноса в первый (младший) 4-битный блок; используется как начальный перенос в цепи.
- C1–C7 – выходы переноса для последующих 4-битных блоков; формируют сигналы переноса, поступающие на следующий каскад микросхем 74181.
- PG (Group Propagate) – групповой сигнал распространения переноса; означает, что весь 32-битный блок способен передать входной перенос от начала до конца без генерации своего.
- GG (Group Generate) – групповой сигнал генерации переноса; означает, что весь 32-битный блок сам формирует перенос независимо от входного сигнала Cn.

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74882.png)

Структура CLA

```sv
// Модуль ускоренного переноса с ПОЛОЖИТЕЛЬНЫМ (p) логическим уровнем
module carry32_p74882 (
    input [7:0] P,      // Пропускные сигналы
    input [7:0] G,      // Генерирующие сигналы
    input Cin,          // Входной перенос
    output [3:0] Cout   // Выходные переносы
);

    // Сокращенные записи с использованием generate
    genvar i;
    wire [7:0] PP;      // PP[i] = P[i] & P[i-1]
    wire [7:0] PG;      // PG[i] = P[i] & G[i-1]

    generate
        for (i = 1; i <= 7; i = i + 1) begin : gen_PP_PG
            assign PP[i] = P[i] & P[i-1];
            assign PG[i] = P[i] & G[i-1];
        end
    endgenerate

    assign Cout[0] = ((G[1]) | 
                     ( PG[1]) | 
                     ( PP[1] & Cin));
    assign Cout[1] = ((G[3]) |
                     ( PG[3]) | 
                     ( PP[3] & G[1]) | 
                     ( PP[3] & PG[1]) | 
                     ( PP[3] & PP[1] & ~Cin));

    assign Cout[2] = ((G[5]) |
                     ( PG[5]) | 
                     ( PP[5] & G[3]) | 
                     ( PP[5] & PG[3]) | 
                     ( PP[5] & PP[3] & G[1]) |
                     ( PP[5] & PP[3] & PG[1]) | 
                     ( PP[5] & PP[3] & PP[1] & ~Cin));
    
    assign Cout[3] = ((G[7]) | 
                     ( PG[7])| 
                     ( PP[7] & G[5]) | 
                     ( PP[7] & PG[5])| 
                     ( PP[7] & PP[5] & G[3]) | 
                     ( PP[7] & PP[5] & PG[3])| 
                     ( PP[7] & PP[5] & PP[3] & G[1]) | 
                     ( PP[7] & PP[5] & PP[3] & PG[1])| 
                     ( PP[7] & PP[5] & PP[3] & PP[1] & ~Cin));

endmodule
```

тест 