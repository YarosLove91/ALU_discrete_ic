# Структура лабораторной работы "Цифровые операционные устройства"

- [Структура лабораторной работы "Цифровые операционные устройства"](#структура-лабораторной-работы-цифровые-операционные-устройства)
  - [1. Цели и ход работы](#1-цели-и-ход-работы)
  - [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
    - [2.1 Сумматоры](#21-сумматоры)
      - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
      - [2.1.2 Сумматоры с ускоренным переносом](#212-сумматоры-с-ускоренным-переносом)
    - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
      - [2.2.1 Режимы работы АЛУ](#221-режимы-работы-алу)
    - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
      - [2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181](#231-микросхема-4-разрядного-ускоренного-переноса--74181)
      - [2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#232-микросхема-32-разрядного-ускоренного-переноса---74882)
  - [3. Симулятор DIGITAL](#3-симулятор-digital)
    - [3.1 Описание функционала программы](#31-описание-функционала-программы)
    - [3.2 Установка DIGITAL](#32-установка-digital)
    - [3.3 Сведения о лабораторном оборудовании](#33-сведения-о-лабораторном-оборудовании)
      - [3.3.1 Микросхема 4-разрядного ускоренного переноса — 74181](#331-микросхема-4-разрядного-ускоренного-переноса--74181)
      - [3.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#332-микросхема-32-разрядного-ускоренного-переноса---74882)




## 1. Цели и ход работы 
Целью данной лабораторной работы является изучение и экспериментальное исследование арифметико-логических устройств (АЛУ) и блоков ускоренного переноса (CLA), их структуры, принципов работы и способов организации многобитных вычислений.
## 2. Цифровые операционные устройства

### 2.1 Сумматоры
Сумматоры — это цифровые устройства, предназначенные для выполнения операции сложения двоичных чисел. Они являются фундаментальными элементами арифметико-логических устройств современных процессоров, цифровых сигнальных процессоров (DSP) и вычислительных ядер. Схемотехнически сумматоры представляют собой комбинационные логические схемы, которые реализуют булевы функции сложения по модулю два (сложение без учета переноса) и операции переноса разряда.

Алгоритм двоичного сложения является базовой арифметической операцией, на которой строится работа всех цифровых вычислительных систем. Принцип сложения двоичных чисел аналогичен сложению десятичных чисел, но с учётом особенностей двоичной системы счисления, где допустимы только два значения: 0 и 1.

Для сложения двух одноразрядных двоичных чисел $A$ и $B$ с учётом входного переноса $C_{in}$ используется следующая таблица истинности:

| $A$ | $B$ | $C_{in}$ | Сумма $(S)$| Перенос $(C_{out})$ |
| - | - | -------- | --------- | ------------------- |
| 0 | 0 | 0        | 0         | 0                   |
| 0 | 0 | 1        | 1         | 0                   |
| 0 | 1 | 0        | 1         | 0                   |
| 0 | 1 | 1        | 0         | 1                   |
| 1 | 0 | 0        | 1         | 0                   |
| 1 | 0 | 1        | 0         | 1                   |
| 1 | 1 | 0        | 0         | 1                   |
| 1 | 1 | 1        | 1         | 1                   |

Отсюда формируются логические выражения:

Сумма:

$S = A ⊕ B ⊕ C_{in}$

Перенос:

$C_{out} = (A ⋅ B) + (C_{in} ⋅ (A ⊕ B))$

*Классификация сумматоров*

Сумматоры можно классифицировать по нескольким признакам, исходя из особенностей их построения и схемных решений. Основные типы классификации следующие:

1. По числу входных разрядов:
   - Одноразрядные:

      - Полусумматоры (складывают два числа без учёта переноса);

      - Полные сумматоры (складывают два числа с учётом входного переноса).

   - Многоразрядные:

        Сложение выполняется по алгоритму последовательного или ускоренного переноса.

2. По способу переноса:
   
    - Сумматоры с последовательным переносом (Ripple Carry Adder, RCA):
    
        Перенос передаётся последовательно от младшего разряда к старшему. Простая структура, но большая задержка при увеличении разрядности.

    - Сумматоры с ускоренным переносом (Carry Look-Ahead Adder, CLA):
    
        Переносы вычисляются заранее с использованием функций генерации и распространения переноса. Существенно меньшая задержка по сравнению с RCA.

    - Сумматоры с прогнозированием переноса (Carry Select Adder, CSA):

        Число разбивается на блоки, и сложение в блоках выполняется параллельно для двух вариантов переноса (0 и 1), после чего выбирается правильный результат. Компромисс между быстродействием и сложностью схемы.

    - Сумматоры с сщхранением переносом (Carry Skip Adder, CSA):

        Используют специальные схемы пропуска переноса через группы разрядов, что сокращает задержку.

    - Иерархические (многоуровневые) сумматоры:

        Строятся с применением многоуровневых схем ускоренного переноса. Хорошо масштабируются для больших разрядностей (например, 32, 64 и более бит).

3. По скорости работы:

    - Медленные (например, RCA) — линейная зависимость задержки от разрядности.

    - Ускоренные (CLA, CSA, CSA) — задержка растёт логарифмически или квазилогарифмически от числа разрядов.


#### 2.1.1 Сумматоры с последовательным переносом
Сумматоры с последовательным переносом представляют собой наиболее простую и базовую реализацию многоразрядных сумматоров в цифровой логике. Они получили широкое распространение в схемах малой и средней разрядности, где важны минимальные затраты по логическим элементам и простота проектирования.

*Структура и принцип работы*

Многоразрядный сумматор с последовательным переносом строится из цепочки полных сумматоров, где каждый следующий сумматор принимает на вход перенос из предыдущего разряда. Это создаёт линейную зависимость времени задержки по числу разрядов.

Формально, для i-го разряда суммирование определяется следующими логическими выражениями:

$S = A_{i} ⊕ B_{i} ⊕ C_{i}$

$C_{i} = (A_{i} ⋅ B_{i}) + (C_{in} ⋅ (A_{i} ⊕ B_{i}))$ 

где:

$A_{i}$, $B_{i}$ — биты слагаемых чисел в i-м разряде,

$С_{i}$ — перенос, поступающий с предыдущего разряда,

$S_{i}$ — сумма в текущем разряде,

$C_{i+1}$  — перенос на следующий разряд.

Именно задержка распространения переноса $C_{i+1}$ по цепочке полных сумматоров и определяет суммарное время отклика всего сумматора. Каждый перенос должен быть вычислен до того, как следующий разряд сможет начать работу, что и образует последовательный характер выполнения сложения.

*Преимущества и недостатки*

Достоинства:

- Простейшая архитектура, хорошо поддающаяся ручному и автоматизированному преобразованию;

- Минимальные аппаратные затраты;

- Хорошо подходит для реализации в программируемых логических интегральных схемах (ПЛИС) с ограниченными ресурсами.

Недостатки:

- Линейная задержка при увеличении разрядности;

- Неэффективность при работе на высоких частотах и больших разрядностях;

- Склонность к накоплению ошибок тайминга при длинных цепочках переноса.

#### 2.1.2 Сумматоры с ускоренным переносом

Сумматоры с ускоренным переносом были разработаны как ответ на главный недостаток RCA — последовательную задержку переноса. Архитектура CLA позволяет вычислять переносы параллельно для всех разрядов, что существенно ускоряет процесс сложения и уменьшает общую задержку схемы до логарифмической зависимости от разрядности.

*Принцип работы*

Основой CLA являются две ключевые функции:

- Генерация переноса ($G_{i}$) — фиксирует ситуацию, когда перенос обязательно возникнет в текущем разряде:

    $G_{i} = (A_{i} ⋅ B_{i})$
 
- Передача переноса ($P_{i}$) — определяет возможность "пропускания" входного переноса на следующий разряд:

    $P = A_{i} ⊕ B_{i}$
 
- Выходной перенос для каждого разряда рассчитывается как:

    $C_{i+1} = G_{i} + (P_{i} ⋅ C_{i})$

    Это уравнение позволяет реализовать схему, где переносы всех разрядов могут быть предвычислены параллельно, без необходимости ожидать результатов младших разрядов.

*Блочная структура CLA*

Для улучшения масштабируемости, CLA обычно проектируются блочно. Несколько разрядов (обычно по 4 или 8) группируются, и для группы вычисляются групповые сигналы генерации и передачи переноса:

$G_{group} = G_{3} + (P_{3} ⋅ G_{2}) + (P_{3} ⋅ P_{2} ⋅ G_{1}) + (P_{3} ⋅ P_{2} ⋅ P_{1} ⋅ G_{0})$

$P_{group} = P_{3} ⋅ P_{2} ⋅ P_{1} ⋅ P_{0}$​

Эти групповые сигналы далее используются для расчёта переносов между группами, что позволяет строить сумматоры большой разрядности (например, 32, 64 и 128 бит) с умеренной задержкой.

*Преимущества и недостатки*

Достоинства:

- Существенно более высокая скорость по сравнению с RCA, особенно на больших разрядностях;

- Параллельная обработка переносов сокращает путь задержки;

- Хорошо масштабируется для процессоров с 32, 64 и более битами данных.

Недостатки:

- Увеличение числа логических элементов и более сложная логическая схема;

- Повышенное потребление энергии;

- Большая площадь кристалла при реализации в интегральных схемах (ASIC).

### 2.2 Арифметико - логическое устройство

Арифметико-логическое устройство (АЛУ) представляет собой ключевой компонент вычислительных систем, предназначенный для выполнения логических и арифметических операций с данными. 

Элементарные арифметические и логические операции реализуются с помощью комбинационных схем на логических элементах. Например, сложение выполняется сумматорами, а сдвиги – регистрами сдвига. Более сложные операции (умножение, деление) реализуются программно или микропрограммно путем последовательного выполнения элементарных операций.

Для работы с числовыми данными в АЛУ используются:
- Сумматоры – для сложения и вычитания;
- Регистры сдвига – для перемещения битов;
- Регистры счёта – для накопления значений при арифметических операциях;
- Компараторы – для сравнения значений.
  
По своей структуре АЛУ относится к классу комбинационных схем, поскольку не содержит элементов памяти. Это означает, что его выходные сигналы зависят исключительно от текущего состояния входных данных. Время выполнения каждой операции определяется характеристиками используемых электронных компонентов, типом выполняемой логической функции и видом АЛУ.

Существуют разные виды АЛУ по организации обработки данных:

- По способу обработки данных во времени:
    - Последовательные АЛУ – выполняют операции поэтапно, что снижает скорость, но экономит аппаратные ресурсы.
    - Параллельные АЛУ – обрабатывают несколько битов одновременно, ускоряя вычисления.
- По форме представления данных:
    - С фиксированной запятой.
    - С плавающей запятой.
- По архитектуре:
    - Многофункциональные АЛУ – выполняют все операции в одном блоке, что уменьшает затраты на оборудование, но снижает скорость обработки.
    - Блочные АЛУ – каждая операция выполняется в отдельном блоке, что увеличивает производительность и упрощает параллельную обработку.
- По организации временного цикла:
    - Синхронные АЛУ – работают в фиксированные тактовые интервалы.
    - Асинхронные АЛУ – начинают новую операцию сразу после завершения предыдущей, что уменьшает задержки, но усложняет схемотехнику.

Как правило, АЛУ оснащено двумя наборами входных линий и одной группой выходов, а также дополнительными сигналами, несущими вспомогательную информацию. Входные линии подключены к буферным регистрам, предназначенным для временного хранения поступающих данных. Каждый такой регистр способен хранить фиксированное количество бит информации, определяемое разрядностью устройства.

Кроме того, в состав устройства входит регистр состояния, фиксирующий информацию о результатах выполнения операций. В нем могут содержаться флаги, которые передают служебные сигналы, объединяемые в кодовое слово состояния (Program State Word – PSW). В него входят:

- Zero (нулевой результат),
- Sign (знак результата),
- Carry (перенос или заём),
- Overflow (переполнение),
- Parity (чётность/нечётность),
- Логические условия сравнения (<, >, ≥, ≤, ≠).
  
В зависимости от типа выполняемой операции АЛУ может работать с одним или двумя операндами. Например, для сложения требуется два входных значения, а инверсия кода требует только одного.

#### 2.2.1 Режимы работы АЛУ

Набор поддерживаемых АЛУ функций может варьироваться в зависимости от архитектуры, но большинство устройств включает в себя стандартный набор базовых операций, таких как:

- Арифметические операции:
    - сложение,
    - вычитание,
    - инкремент (увеличение на 1),
    - декремент (уменьшение на 1),
    - умножение,
    - деление;
- Логические операции:
    - логическое И (конъюнкция),
    - логическое ИЛИ (дизъюнкция),
    - исключающее ИЛИ,
    - инверсия;
- Операции сдвига:
    - сдвиг вправо и влево,
    - арифметический сдвиг,
    - логический сдвиг,
    - циклический сдвиг.

Арифметеческий режим

Логический режим

```sv
// f - fixed. Без конструкции generate
module alu_74181f(
    input [3:0]s,
    input Cin, M,
    input [3:0] a, b,
    output reg [3:0] y
);

    reg [3:0] p, g;

    always @(*) begin
        p[0] <= ~(a[0] | (s[0] & b[0]) | (s[1] & ~b[0]));
        p[1] <= ~(a[1] | (s[0] & b[1]) | (s[1] & ~b[1]));
        p[2] <= ~(a[2] | (s[0] & b[2]) | (s[1] & ~b[2]));
        p[3] <= ~(a[3] | (s[0] & b[3]) | (s[1] & ~b[3]));

        g[0] <= ~((a[0] & ~b[0] & s[2]) | (a[0] & b[0] & s[3]));
        g[1] <= ~((a[1] & ~b[1] & s[2]) | (a[1] & b[1] & s[3]));
        g[2] <= ~((a[2] & ~b[2] & s[2]) | (a[2] & b[2] & s[3]));
        g[3] <= ~((a[3] & ~b[3] & s[2]) | (a[3] & b[3] & s[3]));

        y[0] = (p[0] ^ g[0]) ^ ~(~Cin & ~M);
        y[1] = (p[1] ^ g[1]) ^ ~((~Cin & ~M & g[0]) | (~M & p[0]));
        y[2] = (p[2] ^ g[2]) ^ ~((~Cin & ~M & g[0] & g[1]) | (~M & p[1]) | (~M & p[0] & g[1]));
        y[3] = (p[3] ^ g[3]) ^ ~((~Cin & ~M & g[0] & g[1] & g[2]) | (~M & p[2]) | (~M & p[1] & g[2]) | (~M & p[0] & g[1] & g[2]));
    end


endmodule // alu74181
```

Листинг - RTL код четырех разрядного АЛУ 74181

### 2.3 Способы повышения разрядности цифровых операционных устройства
Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​
#### 2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181

Микросхема 74181 представляет собой 4-разрядное арифметико-логическое устройство (АЛУ), способное выполнять 16 логических и 16 арифметических операций над двумя 4-битными словами. Она поддерживает операции сложения, вычитания, инкремента, декремента, а также логические функции, такие как $AND$, $OR$, $XOR$.

Ключевой особенностью 74181 является использование схемы ускоренного переноса (carry-lookahead), которая позволяет значительно повысить скорость выполнения операций по сравнению с традиционным последовательным переносом. Это достигается за счёт вычисления сигналов генерации ($G$) и распространения ($P$) переноса для каждого бита, что позволяет предсказать переносы на более высокие разряды без необходимости ожидания завершения операций в младших разрядах.

Назначение входов/выходов микросхемы: 
- $A_{0} - A_{3}$ и $B_{0} - B_{3}$ - четырёхразрядные двоичные суммируемые операнды; 
- $S_{0} - S_{3}$ - четыре входа выбора позволяют выбрать одну из 16 возможных функций, в зависимости от состояния сигнала на линии $M$ (Mode Control) ($M = 0$ - арифметические операции над прямым кодом операндов $А$ и $В$ при $С = 1$; $M = 1$ - логические операции над прямым кодом операндов); 
- $F_{0} - F_{3}$ - 4-битный результат выбранной операции; 
- $P$, $G$ - выходы подключения к блоку ускоренного переноса при каскадировании; 
- $(А = В)$ = бинарный признак равенства операндов в операции сравнения; 
- $C_{n}$ (Carry In), $C_{n+4}$ - входной и выходной признаки переноса. Если операция даёт перенос, то он появляется на выходе $C_{n+4}$. Этот перенос можно передавать в следующую микросхему, если нужно работать с числами больше 4 бит.


![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74181.png?raw=true)

Структура CLA

```sv
module cla_74182 (
    input[3:0]  nPB, 
    input[3:0]  nGB,
    input   Cn,
    output	PBo, GBo, Cnx, Cny, Cnz
);
    assign PBo = (  nPB[0]   |   nPB[1]   |   nPB[2]   |   nPB[3]);
    assign GBo = (  (nGB[0]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[2]  &   nGB[2]   &   nGB[3]) | 
                    (nPB[3]  &   nGB[3]));

    assign Cnx = ~( (nPB[0]  &   nGB[0]) | 
                    (nGB[0]  &   ~Cn));
    assign Cny = ~( (nPB[1]  &   nGB[1]) | 
                    (nPB[0]  &   nGB[0]   &   nGB[1])  |
                    (nGB[0]  &   nGB[1]   &   ~Cn));
    assign Cnz = ~( (nPB[2]  &   nGB[2]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2])  |
                    (nPB[0]  &   nGB[0]   &   nGB[1]   &   nGB[2])  | 
                    (nGB[0]  &   nGB[1]   &   nGB[2]   &   ~Cn));
endmodule

```
Листинг x - 

#### 2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882

Микросхема 74882 — это специализированный блок ускоренного переноса, предназначенный для использования в составе высокоразрядных АЛУ. Она не является самостоятельным АЛУ, как 74181, а служит в качестве расширителя CLA-схемы, обеспечивая обработку переноса между группами по 4 бита, в общей сложности — до 32 разрядов.

Использование 74882 позволяет значительно сократить время выполнения операций сложения и вычитания за счёт параллельной обработки переносов между группами разрядов. Это особенно важно в системах, требующих высокой производительности, таких как процессоры и цифровые сигнальные процессоры.

Назначение входов/выходов микросхемы:
- $P_{0} – P_{7}$ – входы распространения переноса от восьми 4-битных арифметических блоков (например, от микросхем 74181); указывают, способен ли каждый блок передать перенос дальше при его наличии.
- $G_{0} – G_{7}$ – входы генерации переноса от тех же восьми 4-битных блоков; сигнализируют о том, что соответствующий блок обязательно создаёт перенос независимо от входного значения переноса.
- $C_{n}$ – вход переноса в первый (младший) 4-битный блок; используется как начальный перенос в цепи.
- $C_{1} – C_{7}$ – выходы переноса для последующих 4-битных блоков; формируют сигналы переноса, поступающие на следующий каскад микросхем 74181.

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74882.png?raw=true)

Структура CLA

```sv
// Модуль ускоренного переноса с ПОЛОЖИТЕЛЬНЫМ (p) логическим уровнем
module carry32_p74882 (
    input [7:0] P,      // Пропускные сигналы
    input [7:0] G,      // Генерирующие сигналы
    input Cin,          // Входной перенос
    output [3:0] Cout   // Выходные переносы
);

    // Сокращенные записи с использованием generate
    genvar i;
    wire [7:0] PP;      // PP[i] = P[i] & P[i-1]
    wire [7:0] PG;      // PG[i] = P[i] & G[i-1]

    generate
        for (i = 1; i <= 7; i = i + 1) begin : gen_PP_PG
            assign PP[i] = P[i] & P[i-1];
            assign PG[i] = P[i] & G[i-1];
        end
    endgenerate

    assign Cout[0] = ((G[1]) | 
                     ( PG[1]) | 
                     ( PP[1] & Cin));
    assign Cout[1] = ((G[3]) |
                     ( PG[3]) | 
                     ( PP[3] & G[1]) | 
                     ( PP[3] & PG[1]) | 
                     ( PP[3] & PP[1] & ~Cin));

    assign Cout[2] = ((G[5]) |
                     ( PG[5]) | 
                     ( PP[5] & G[3]) | 
                     ( PP[5] & PG[3]) | 
                     ( PP[5] & PP[3] & G[1]) |
                     ( PP[5] & PP[3] & PG[1]) | 
                     ( PP[5] & PP[3] & PP[1] & ~Cin));
    
    assign Cout[3] = ((G[7]) | 
                     ( PG[7])| 
                     ( PP[7] & G[5]) | 
                     ( PP[7] & PG[5])| 
                     ( PP[7] & PP[5] & G[3]) | 
                     ( PP[7] & PP[5] & PG[3])| 
                     ( PP[7] & PP[5] & PP[3] & G[1]) | 
                     ( PP[7] & PP[5] & PP[3] & PG[1])| 
                     ( PP[7] & PP[5] & PP[3] & PP[1] & ~Cin));

endmodule
```

## 3. Симулятор DIGITAL
Digital — это инструмент для проектирования и симуляции цифровых логических схем, разработанный с образовательными целями. Он позволяет пользователям создавать, моделировать и анализировать цифровые схемы, предоставляя визуализацию сигналов и различные инструменты для тестирования и синтеза.
### 3.1 Описание функционала программы
Основные функции:
1. Симуляция работы микросхем в реальном времени:
 - Поддержка комбинационных и последовательностных схем.
- Визуализация изменений сигналов в ходе работы схемы.
- Возможность приостановки и покадрового просмотра работы схем.
2. Моделирование логических элементов и сложных устройств:
- Логические вентили (AND, OR, NOT, XOR и др.).
- Триггеры (D, JK, T, RS).
- Регистрирующие устройства (регистр сдвига, счетчики).
- Память (ROM, RAM).
- Мультиплексоры, дешифраторы, арифметико-логические устройства.
3. Работа с реальными микросхемами:
- Моделирование работы стандартных ИС (например, серии 74xx).
- Возможность загружать схемы и анализировать их сигналы.
- Поддержка пользовательских компонентов для создания сложных цифровых устройств.
4. Графическая визуализация сигналов и измерений:
- Графики изменения сигналов на выводах микросхем.
- Осциллограф для анализа временных диаграмм.
- Логический анализатор для исследования состояний регистров и шин данных.
5. Тестирование и отладка схем:
- Возможность пошагового выполнения схемы.
- Поддержка сценариев тестирования.
- Выявление ошибок в проектировании схем с подсветкой проблемных узлов.
6. Работа с процессорной логикой:
- Симуляция простых процессоров и ALU.
- Создание собственных микропроцессорных архитектур.
- Моделирование работы машинного кода на уровне схем.

### 3.2 Установка DIGITAL
1. Скачайте файл Digital.zip с [GitHub-репозитория](https://github.com/hneemann/Digital).
2. Распакуйте архив в удобное для вас место.
3. Убедитесь, что у вас установлена Java Runtime Environment (JRE) версии 8 или выше. На Windows рекомендуется использовать бинарные файлы от проекта [Eclipse Temurin](https://adoptium.net/).

### 3.3 Сведения о лабораторном оборудовании
#### 3.3.1 Микросхема 4-разрядного ускоренного переноса — 74181
*Цель*

В результате работы со стендом будет получено:

- понимание принципов построения и работы микросхемы АЛУ 74181;

- знание основных арифметических и логических операций на уровне аппаратной логики;

- понимание принципов работы схемы ускоренного переноса и её применения;

- опыт  создания цифровых схем с использованием симуляторов.
  
*Алгоритм работы*
1. В симуляторе Digital откройте или собрите проект стенда с микросхемой 74181.
2. Установите значения операндов $A$ и $B$, переключив соответствующие входы ($A_{3} – A_{0}, B_{3} – B_{0}$) в интерфейсе симулятора.
3. Задате код операции, переключив тетраду входов S3–S0 согласно таблице функций и установите вход $M$ для выбора типа операции ($M = 0$ — арифметика, $M = 1$ — логика).
4. Активируйте входной перенос $C_{0}$ (обычно устанавливается в 1 для операций сложения).
5. Проанализируйте результат на выходах $F_{3} – F_{0}$, а также сигналы состояния ($C_{4}$, $P$, $G$, $A$ $=$ $B$).
   
| Код $S$  | Арифметическая операция $(M=0, C0=1)$ | Арифметическая операция $(M=0, C0=0)$ | Логическая операция $(M=1)$    |
|--------|-------------------------------------|-------------------------------------|-------------------------------|
| 0000   | $A$                                   | $A + 1$                               | $NOT$ $A$                         |
| 0001   | $A$  $OR$ $B$                              | $NOT$ ($A$ $OR$ $B$)                        |                               |
| 0010   | $A$ $OR$ $(NOT$ $B)$                        | $NOT$ $A$ $AND$ $B$                         |                               |
| 0011   | $0$                                   | $0$                                   |                               |
| 0100   | $A$ $+$ $(A$ $AND$ $NOT$ $B)$                   | $NOT$ $(A$ $AND$ $B)$                       |                               |
| 0101   | $(A$ $AND$ $B)$ $+$ $(A$ $OR$ $B)$                | $NOT$ $B$                               |                               |
| 0110   | $A$ $-$ $B$ $-$ $1$                           | $A$ $-$ $B$                               | $A$ $XOR$ $B$                       |
| 0111   | $(A$ $AND$ $NOT$ $B)$ $-$ $1$                   | $A$ $AND$ $NOT$ $B$                         |                               |
| 1000   | $A$ $+$ $(A$ $AND$ $B)$                       | $NOT$ $A$ $OR$ $B$                          |                               |
| 1001   | $A$ $+$ $B$                               | $A$ $+$ $B$ $+$ $1$                           | $NOT$ $(A$ $XOR$ $B)$                 |
| 1010   | $(A$ $AND$ $B)$ $+$ $(A$ $OR$ $(NOT$ $B))$          | $B$                                   |                               |
| 1011   | $(A$ $AND$ $B)$ $-$ $1$                       | $A$ $AND$ $B$                             |                               |
| 1100   | $A$ $+$ $A$                               | $A$ $+$ $A$ $+$ $1$                           | $1$                             |
| 1101   | $A$ $+$ $(A$ $OR$ $B)$                        | $A$ $OR$ $(NOT$ $B)$                        |                               |
| 1110   | $A$ $+$ $(A$ $OR$ $(NOT$ $B))$                  | $A$ $OR$ $B$                              |                               |
| 1111   | $A$ $-$ $1$                               | $A$                                   | $A$                             |

*Пример*

Рассмотрим выполнение арифметической операции сложения двух четырёхразрядных чисел. Пусть $A = 0101 (5), B = 0011 (3)$.
На входы микросхемы в симуляторе устанавливаются:

$A_{3} = 0, A-{2} = 1, A_{1} = 0, A_{0} = 1$

$B_{3} = 0, B_{2} = 0, B_{1} = 1, B_{0} = 1$
 
Для операции сложения с учётом переноса выбирается код $S_{3} – S_{0} = 1001$ (см. Таблицу функций).

Устанавливается:

$M = 0$ (арифметическая операция)

$C_{0} = 1$  (входной перенос)

В результате на выходе:

$F_{3} – F_{0} = 1001 (9)$, 

так как 5 + 3 + 1 = 9

$C_{4} = 0$ (переполнения нет).

#### 3.3.2 Микросхема 32-разрядного ускоренного переноса - 74882
*Цель*

В результате работы со стендом будет получено:

- Понимание алгоритма генерации и распространения сигналов переноса;
- Понимание принципа работы ускоренного переноса Carry Lookahead;
- Знание способа построения высокоразрядных АЛУ из каскадированных микросхем;
- Знание методов уменьшения задержек в цифровых вычислениях.

*Алгоритм работы*

1. В симуляторе Digital откройте схему, включающую 4 микросхемы 74181 и одну 74882.
2. Установите значения операндов A и B для каждой микросхемы, переключив соответствующие входы ($A_{3} – A_{0}, B_{3} – B_{0}$) в интерфейсе симулятора.
3. Получите сигналы $G$ и $P$ с каждой  ALU 74181 и подайте их на 74882.
4. Активируйте входной перенос $C_{0}$.
5. Проанализируйте выходы $C_{1} – C_{4}$, которые подаются на следующие по старшинству микросхемы.

Пример микросхемы  32-разрядного ускоренного переноса - 74882.
![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/CLA_74882_ALU-32.png?raw=true)

На русунке:

- $PG$ (Group Propagate) – групповой сигнал распространения переноса; означает, что весь 32-битный блок способен передать входной перенос от начала до конца без генерации своего.

- $GG$ (Group Generate) – групповой сигнал генерации переноса; означает, что весь 32-битный блок сам формирует перенос независимо от входного сигнала $C_{n}$.

*Пример*

Устанавливается значения входных сигналов $G_{7} – G_{0}$ и $P_{7} – P_{0}$ на основе результатов работы 74181. Ввод $C_{0} = 1$ инициирует вычисление всех Cn.Выходы $C_{1} – C_{4}$ подаются в $C_{0}$ следующих микросхем.


