# Структура лабораторной работы "Цифровые операционные устройства"

- [Структура лабораторной работы "Цифровые операционные устройства"](#структура-лабораторной-работы-цифровые-операционные-устройства)
  - [1. Цели и ход работы](#1-цели-и-ход-работы)
  - [2. Цифровые операционные устройства](#2-цифровые-операционные-устройства)
    - [2.1 Сумматоры](#21-сумматоры)
      - [2.1.1 Сумматоры с последовательным переносом](#211-сумматоры-с-последовательным-переносом)
      - [2.1.2 Сумматоры с ускоренным переносом](#212-сумматоры-с-ускоренным-переносом)
    - [2.2 Арифметико - логическое устройство](#22-арифметико---логическое-устройство)
    - [2.3 Способы повышения разрядности цифровых операционных устройства](#23-способы-повышения-разрядности-цифровых-операционных-устройства)
      - [2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181](#231-микросхема-4-разрядного-ускоренного-переноса--74181)
      - [2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#232-микросхема-32-разрядного-ускоренного-переноса---74882)
  - [3. Симулятор DIGITAL](#3-симулятор-digital)
    - [3.1 Описание функционала программы](#31-описание-функционала-программы)
    - [3.2 Установка DIGITAL](#32-установка-digital)
    - [3.3 Сведения о лабораторном оборудовании](#33-сведения-о-лабораторном-оборудовании)
      - [3.3.1 Микросхема 4-разрядного ускоренного переноса — 74181](#331-микросхема-4-разрядного-ускоренного-переноса--74181)
      - [3.3.2 Микросхема 32-разрядного ускоренного переноса - 74882](#332-микросхема-32-разрядного-ускоренного-переноса---74882)




## 1. Цели и ход работы 
Целью данной лабораторной работы является изучение и экспериментальное исследование арифметико-логических устройств (АЛУ) и блоков ускоренного переноса (CLA), их структуры, принципов работы и способов организации многобитных вычислений.
## 2. Цифровые операционные устройства

### 2.1 Сумматоры
Сумматоры — это цифровые устройства, предназначенные для выполнения операции сложения двоичных чисел. Они являются фундаментальными элементами арифметико-логических устройств современных процессоров, цифровых сигнальных процессоров (DSP) и вычислительных ядер. Схемотехнически сумматоры представляют собой комбинационные логические схемы, которые реализуют булевы функции сложения по модулю два (сложение без учета переноса) и операции переноса разряда.

Алгоритм двоичного сложения является базовой арифметической операцией, на которой строится работа всех цифровых вычислительных систем. Принцип сложения двоичных чисел аналогичен сложению десятичных чисел, но с учётом особенностей двоичной системы счисления, где допустимы только два значения: 0 и 1.

Для сложения двух одноразрядных двоичных чисел $A$ и $B$ с учётом входного переноса $C_{in}$ используется следующая таблица истинности:

| $A$ | $B$ | $C_{in}$ | Сумма $(S)$| Перенос $(C_{out})$ |
| - | - | -------- | --------- | ------------------- |
| 0 | 0 | 0        | 0         | 0                   |
| 0 | 0 | 1        | 1         | 0                   |
| 0 | 1 | 0        | 1         | 0                   |
| 0 | 1 | 1        | 0         | 1                   |
| 1 | 0 | 0        | 1         | 0                   |
| 1 | 0 | 1        | 0         | 1                   |
| 1 | 1 | 0        | 0         | 1                   |
| 1 | 1 | 1        | 1         | 1                   |

Отсюда формируются логические выражения:

Сумма:

$S = A ⊕ B ⊕ C_{in}$

Перенос:

$C_{out} = (A ⋅ B) + (C_{in} ⋅ (A ⊕ B))$

*Классификация сумматоров*

Сумматоры можно классифицировать по нескольким признакам, исходя из особенностей их построения и схемных решений. Основные типы классификации следующие:

1. По числу входных разрядов:
   - Одноразрядные:

      - Полусумматоры (складывают два числа без учёта переноса);

      - Полные сумматоры (складывают два числа с учётом входного переноса).

   - Многоразрядные:

        Сложение выполняется по алгоритму последовательного или ускоренного переноса.

2. По способу переноса:
   
    - Сумматоры с последовательным переносом (Ripple Carry Adder, RCA):
    
        Перенос передаётся последовательно от младшего разряда к старшему. Простая структура, но большая задержка при увеличении разрядности.

    - Сумматоры с ускоренным переносом (Carry Look-Ahead Adder, CLA):
    
        Переносы вычисляются заранее с использованием функций генерации и распространения переноса. Существенно меньшая задержка по сравнению с RCA.

    - Сумматоры с прогнозированием переноса (Carry Select Adder, CSA):

        Число разбивается на блоки, и сложение в блоках выполняется параллельно для двух вариантов переноса (0 и 1), после чего выбирается правильный результат. Компромисс между быстродействием и сложностью схемы.

    - Сумматоры с сщхранением переносом (Carry Skip Adder, CSA):

        Используют специальные схемы пропуска переноса через группы разрядов, что сокращает задержку.

    - Иерархические (многоуровневые) сумматоры:

        Строятся с применением многоуровневых схем ускоренного переноса. Хорошо масштабируются для больших разрядностей (например, 32, 64 и более бит).

3. По скорости работы:

    - Медленные (например, RCA) — линейная зависимость задержки от разрядности.

    - Ускоренные (CLA, CSA, CSA) — задержка растёт логарифмически или квазилогарифмически от числа разрядов.


#### 2.1.1 Сумматоры с последовательным переносом
Сумматоры с последовательным переносом представляют собой наиболее простую и базовую реализацию многоразрядных сумматоров в цифровой логике. Они получили широкое распространение в схемах малой и средней разрядности, где важны минимальные затраты по логическим элементам и простота проектирования.

*Структура и принцип работы*

Многоразрядный сумматор с последовательным переносом строится из цепочки полных сумматоров, где каждый следующий сумматор принимает на вход перенос из предыдущего разряда. Это создаёт линейную зависимость времени задержки по числу разрядов.

Формально, для i-го разряда суммирование определяется следующими логическими выражениями:

$S = A_{i} ⊕ B_{i} ⊕ C_{i}$

$C_{i} = (A_{i} ⋅ B_{i}) + (C_{in} ⋅ (A_{i} ⊕ B_{i}))$ 

где:

$A_{i}$, $B_{i}$ — биты слагаемых чисел в i-м разряде,

$С_{i}$ — перенос, поступающий с предыдущего разряда,

$S_{i}$ — сумма в текущем разряде,

$C_{i+1}$  — перенос на следующий разряд.

Именно задержка распространения переноса $C_{i+1}$ по цепочке полных сумматоров и определяет суммарное время отклика всего сумматора. Каждый перенос должен быть вычислен до того, как следующий разряд сможет начать работу, что и образует последовательный характер выполнения сложения.

*Преимущества и недостатки*

Достоинства:

- Простейшая архитектура, хорошо поддающаяся ручному и автоматизированному преобразованию;

- Минимальные аппаратные затраты;

- Хорошо подходит для реализации в программируемых логических интегральных схемах (ПЛИС) с ограниченными ресурсами.

Недостатки:

- Линейная задержка при увеличении разрядности;

- Неэффективность при работе на высоких частотах и больших разрядностях;

- Склонность к накоплению ошибок тайминга при длинных цепочках переноса.

#### 2.1.2 Сумматоры с ускоренным переносом

Сумматоры с ускоренным переносом были разработаны как ответ на главный недостаток RCA — последовательную задержку переноса. Архитектура CLA позволяет вычислять переносы параллельно для всех разрядов, что существенно ускоряет процесс сложения и уменьшает общую задержку схемы до логарифмической зависимости от разрядности.

*Принцип работы*

Основой CLA являются две ключевые функции:

- Генерация переноса ($G_{i}$) — фиксирует ситуацию, когда перенос обязательно возникнет в текущем разряде:

    $G_{i} = (A_{i} ⋅ B_{i})$
 
- Передача переноса ($P_{i}$) — определяет возможность "пропускания" входного переноса на следующий разряд:

    $P = A_{i} ⊕ B_{i}$
 
- Выходной перенос для каждого разряда рассчитывается как:

    $C_{i+1} = G_{i} + (P_{i} ⋅ C_{i})$

    Это уравнение позволяет реализовать схему, где переносы всех разрядов могут быть предвычислены параллельно, без необходимости ожидать результатов младших разрядов.

*Блочная структура CLA*

Для улучшения масштабируемости, CLA обычно проектируются блочно. Несколько разрядов (обычно по 4 или 8) группируются, и для группы вычисляются групповые сигналы генерации и передачи переноса:

$G_{group} = G_{3} + (P_{3} ⋅ G_{2}) + (P_{3} ⋅ P_{2} ⋅ G_{1}) + (P_{3} ⋅ P_{2} ⋅ P_{1} ⋅ G_{0})$

$P_{group} = P_{3} ⋅ P_{2} ⋅ P_{1} ⋅ P_{0}$​

Эти групповые сигналы далее используются для расчёта переносов между группами, что позволяет строить сумматоры большой разрядности (например, 32, 64 и 128 бит) с умеренной задержкой.

*Преимущества и недостатки*

Достоинства:

- Существенно более высокая скорость по сравнению с RCA, особенно на больших разрядностях;

- Параллельная обработка переносов сокращает путь задержки;

- Хорошо масштабируется для процессоров с 32, 64 и более битами данных.

Недостатки:

- Увеличение числа логических элементов и более сложная логическая схема;

- Повышенное потребление энергии;

- Большая площадь кристалла при реализации в интегральных схемах (ASIC).

### 2.2 Арифметико - логическое устройство

Verilator Это инструмент, который компилирует исходные коды Verilog и SystemVerilog в высокооптимизированный (и, при необходимости, многопоточный) код C++ или SystemC с точностью до цикла. Преобразованные модули можно создавать и использовать в тестовой среде C++ или SystemC для проверки и/или моделирования.

Verilator — это симулятор Verilog/SystemVerilog. Он используется в том числе для коммерческих целей, очень быстрый, бесплатный и с открытым исходным кодом, но не является прямой заменой других симуляторов на основе событий. Verilator — это циклический симулятор, то есть он не оценивает время в пределах одного тактового цикла и не моделирует точное время работы схемы. Вместо этого состояние схемы обычно оценивается один раз за такт, поэтому невозможно наблюдать какие-либо внутрипериодные сбои, а задержки сигналов по времени не поддерживаются. Это имеет как преимущества, так и недостатки по сравнению с другими симуляторами.

Поскольку Verilator работает на основе циклов, его нельзя использовать для моделирования временных интервалов, списков логических схем с положительно обратной связью, асинхронной (без тактовых импульсов) логики или в целом любых изменений сигналов, связанных с понятием времени. Все выходы переключаются мгновенно при оценке схемы.

**Скорость**

Однако, поскольку всё, что находится между фронтами тактового сигнала, игнорируется, моделирование в Verilator выполняется очень быстро и отлично подходит для имитации функциональности синхронных цифровых логических схем с одним или несколькими тактовыми сигналами, а также для создания программных моделей на основе кода Verilog/SystemVerilog для использования при разработке программного обеспечения.

**Качество кода**

Verilator очень требователен к коду Verilog/SystemVerilog, который ему предоставляется. Помимо того, что он не поддерживает временные задержки, он также не принимает большую часть кода, который нельзя синтезировать (за исключением таких элементов, как ```$display()```, ```$finish()```, ```$fatal()```), поэтому невозможнона основе тестового стенда SystemVerilog построить с помощью Verilator тестовый стенд без существенных изменений. Если Verilator не поддерживает код, он выдаст множество предупреждений и сообщений об ошибках.

Поскольку Verilator не поддерживает код, который нельзя синтезировать, у него есть неожиданное преимущество: он ближе к поведению инструментов синтеза, чем другие симуляторы. Это заставляет писать более качественный код для синтеза, что потенциально уменьшит количество проблем, с которыми возможно столкнутся в процессе разработки.

**Необходимые шаги для создания базовой тестовой установки**

1. Преобразование SystemVerilog в C ++
   
   Verilator требует, чтобы тестовая среда C++ компилировалась в собственный двоичный файл системы. Однако, включить исходный файл SystemVerilog в тестовую среду C++ в исходном виде невозможно: сначала необходимо использовать Verilator, чтобы преобразовать код SystemVerilog в C++ или «верифицировать» его, что в самой простой форме выглядит следующим образом:
   
   >verilator --cc test_file.sv

   Параметр ```--cc``` здесь указывает Verilator на необходимость преобразования в C++. Verilator также поддерживает преобразование в SystemC, которое можно выполнить с помощью ```--sc```.

   При выполнении приведённой выше команды в рабочем каталоге создаётся новая папка с именем ```obj_dir```. Именно туда попадают преобразованные исходные коды.

   Сгенерированные файлы ```.mk``` будут использоваться с Make для создания исполняемого файла для моделирования, а файлы ```.h``` и ```.cpp``` содержат наши заголовки C++ и исходные коды, полученные в результате преобразования SystemVerilog.
2. Разработка базового тестового стенда Verilator
   
   После преобразования DUT в C++, можно приступить к написанию тестового стенда. Тестовый стенд будет находиться в новом файле с именем ```tb_alu.cpp```. Необходимо начать с изучения минимального примера кода тестового стенда на C++.
  
   ```cpp
    #include <stdlib.h>
    #include <iostream>
    #include <verilated.h>
    #include <verilated_vcd_c.h>
    #include "Valu.h"
    #include "Valu___024unit.h"

    #define MAX_SIM_TIME 20
    vluint64_t sim_time = 0;

    int main(int argc, char** argv, char** env) {
        Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    while (sim_time < MAX_SIM_TIME) {
        dut->clk ^= 1;
        dut->eval();
        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
    }
    ```
    Первые несколько строк с операторами ```include``` говорят сами за себя. Необходимо включить ```<verilated.h>``` и ```<verilated_vcd_c.h>```, которые поставляются вместе с Verilator, чтобы получить доступ к стандартным процедурам Verilator и записать сигналы в файл VCD (сброса значений).

    ```"Valu.h"``` содержит верхний класс модуля Verilated ALU, а ```"Valu___024unit.h"``` содержит Verilated-версию перечисления typedef.

   Рассмотрим подробнее следующие две строки:
   ```cpp
    #define MAX_SIM_TIME 20
    vluint64_t sim_time = 0;
    ```
    Переменная ```sim_time``` необходима для отслеживания завершения симуляции. Программа остановимся после того, как промоделируем 20 тактовых импульсов.

    Затем следует основная функция:

    ```cpp
    int main(int argc, char** argv, char** env) {
    Valu *dut = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    /* <...> */

    m_trace->close();
    delete dut;
    exit(EXIT_SUCCESS);
    }
    ```
    Строка ```Valu *dut = new Valu;``` создаёт экземпляр преобразованного модуля АЛУ. В SystemVerilog это примерно соответствует ```alu dut (.*);```.

    Следующие четыре строки настраивают вывод сигналов. В частности, создается объект ```m_trace``` и передается в dut в строке ```dut->trace(m_trace, 5);```. Параметр 5 ограничивает глубину трассировки до 5 уровней ниже тестируемого устройства.

    Приведенный ниже код отвечает за симуляцию:

    ```cpp
    while (sim_time < MAX_SIM_TIME) {
    dut->clk ^= 1;
    dut->eval();
    m_trace->dump(sim_time);
    sim_time++;
    }
    ```
    Во время каждой итерации цикла while строка ```dut->clk ^= 1;``` инвертирует тактовый сигнал АЛУ (это создаст нарастающий/спадающий фронт тактового сигнала).

    Вызов ```dut->eval();``` вычисляет все сигналы в модуле АЛУ, а ```m_trace->dump(sim_time);``` записывает все значения отслеживаемых сигналов в файл дампа формы волны. На данном этапе модель вычисляется только по фронтам тактового сигнала.

    Затем время симуляции увеличивается, и цикл продолжается до тех пор, пока не достигнет MAX_SIM_TIME. Важно, что на самом деле это не значение time — переменная просто отслеживает, сколько раз были инвертированы часы.

3. Построение исполняемого файла моделирования
   
   Для запуска моделирования необходимо создать запускаемый файл. Приложение Verilator используется только для преобразования Verilog в C++ и создания инструкций по сборке для Make. Симулятором является сам тестовый стенд C++.

    Тестовый стенд — это, по сути, приложение на C++, которое собирается и запускается на компьютере. При запуске скомпилированного исполняемого файла имитируется разработка, а GNU Compiler Collection (GCC) является дефолтным выбором для создания исполняемых файлов Verilator.

    Чтобы создать исполняемый файл для моделирования, необходимо заново сгенерировать файлы ```.mk``` и включить тестовый стенд C++ — это делается с помощью ```--exe tb_alu.cpp```:
    >$ verilator -Wall --trace -cc alu.sv --exe tb_alu.cpp
    
    Эта команда преобразует исходный код alu.sv в C++ и генерирует файлы сборки для создания исполняемого файла моделирования. Команда ```-Wall``` используется для отображения всех ошибок C++,```--trace``` для отслеживания сигналов, ```-cc alu.sv``` для преобразования модуля ```alu.sv``` в C++ и ```--exe tb_alu.cpp``` для указания Verilator, какой файл является нашим тестовым стендом на C++.

    >make -C obj_dir -f Valu.mk Valu

    Эта команда позволяет создать исполняемый файл для моделирования на основе тестового стенда и преобразованных исходных кодов. Данная команда указываем Make изменить рабочий каталог на    ```obj_dir```, использовать файл сборки с именем ```Valu.mk``` и создать цель с именем ```Valu```

    >./obj_dir/Valu 
    Эта команда запускает исполняемый файл для моделирования, который имитирует испытательный стенд и генерирует сигналы.

Постоянно растущая сложность проектов FPGA и ASIC приводит к ужесточению требований к верификации. Поэтому возросший спрос на продвинутые тестовые стенды привёл к появлению новых методологий и инструментов, таких как OVM, VVM, UVM, SystemC, а также различных фреймворков на основе Python. И все эти инструменты направлены на достижение одной цели — упрощение создания мощных самопроверяющихся тестовых стендов из многократно используемых компонентов, при этом увеличивая охват кода, сводя к минимуму дублирование кода. 

Один из основных способов, с помощью которых вышеупомянутые инструменты достигают этой цели, заключается в том, что они пораждают тестовые сценарии в транзакционном стиле. Тестовый стенд в транзакционном стиле — это тестовый стенд, который использует транзакции, предоставляющие уровень абстракции, который позволяет напрямую присваивать значения входным контактам и напрямую проверять значения выходных контактов тестируемого устройства (DUT).

В традиционном тестовом стенде, написанном на VHDL, Verilog, SystemVerilog или C++, обычно есть экземпляр тестируемого устройства, а также длинный поведенческий код с циклами и условными операторами, которые последовательно управляют входами тестируемого устройства, чтобы оно переходило из одного состояния в другое. В большинстве случаев такие тестовые стенды проверяют на корректность путём визуального анализа сигналов, но возможно и добавить сомопроверку с помощью утверждений или написать код мониторинга.

В отличие от этого, транзакционный тестовый стенд обеспечивает строгое разделение между различными функциональными блоками, каждый из которых взаимодействует с помощью транзакций. Базовый транзакционный тестовый стенд может состоять из:
- блок, генерирующий входные данные для DUT (генератора транзакций / последовательности);
- блок, который передает вышеупомянутые данные в ИУ (драйвер);
- блок, который отслеживает выходные данные DUT и генерирует пакеты с результатами (монитор);
- блок, который собирает различные пакеты данных, а затем сравнивает их на предмет правильности (табло);
- блок, который собирает различные пакеты данных и вычисляет функциональное покрытие (покрытие).

Важно отметить, что существенным недостатком транзакционных тестовых стендов является их сложность — из-за большого количества отдельных функциональных блоков, которые необходимо создать, запуск базового моделирования происходит гораздо медленнее. Однако в обмен на дополнительные усилия вы получаете беспрецедентную гибкость и возможность повторного использования.

Например, если в вашем испытательном стенде есть драйвер, поддерживающий интерфейс типа A, вы можете повторно использовать тот же самый драйвер с любым другим испытуемым устройством, у которого также есть интерфейс типа A. Единственное, что нужно изменить, — это передаваемые ему данные. Если интерфейс типа A заменяется на интерфейс типа B, вы просто заменяете блок драйвера указанного интерфейса с типа A на тип B, а остальную часть испытательного стенда оставляете без изменений.

**Базовая блок-схема транзакционного тестового стенда**

Ниже приведен пример того, как устроен современный транзакционный тестовый стенд:

![alt text](https://itsembedded.com/static/dhd/verilator_4/basic_tb_transactional.jpg)

*Транзакция и элемент транзакции*

Транзакция — это операция обмена данными высокого уровня, а элемент транзакции — пакет данных, или, другими словами, набор данных или инструкций. Обычно пакеты реализуются в виде класса или структуры и содержат данные, которые отправляются или принимаются устройством.

![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_item.jpg)

*Генератор транзакций* 

Генератор транзакций (его также называют генератором случайных транзакций, генератором стимулов, генератором элементов транзакций или генератором случайных входных данных) — это класс или блок кода, который генерирует (создаёт) элементы транзакций, используемые в качестве инструкций для управления входными интерфейсами тестируемого устройства.

![alt text](https://itsembedded.com/static/dhd/verilator_4/transaction_generator.jpg)

*Драйвер*

Драйвер это набор компонент, которые принимают элементы транзакций и на основе данных, содержащихся в этих элементах, управляют физическими выводами входного интерфейса с помощью 1 и 0, чтобы передавать данные в тестируемое устройство.

![alt text](https://itsembedded.com/static/dhd/verilator_4/driver.jpg)

*Интерфейс* 

Интерфейс — это просто набор или группа контактов, которые используются для выполнения определённой функции. Например, у FIFO обычно есть два интерфейса: вход и выход, а у двухтактовой оперативной памяти их может быть четыре: вход для порта A, выход для порта A, вход для порта B, выход для порта B.

![alt text](https://itsembedded.com/static/dhd/verilator_4/interface.jpg)

*Монитор* 

Это практически полная противоположность драйверу: вместо того, чтобы управлять состоянием физических контактов на интерфейсах, они пассивно наблюдают (мониторят) за тем, что происходит на интерфейсе. Мониторы обычно подключаются к выходному интерфейсу, где они используются для проверки выходных данных тестируемого устройства. Кроме того, их можно подключить к входным интерфейсам, где они могут проверять, что соответствующий драйвер правильно управляет интерфейсом.

То, что они делают с данными, полученными в результате наблюдения за волновыми сигналами, зависит от функционала испытательного стенда. Мониторы могут быть полностью автономными и самопроверяющимися, то есть они могут напрямую выполнять код, который проверяет правильность волновых сигналов по мере возникновения событий на интерфейсе. Однако чаще всего мониторы предназначены для создания новых транзакций на основе наблюдаемых изменений состояния контактов интерфейса. Полученные в результате транзакции отправляются в аналитические порты информационных панелей.

![alt text](https://itsembedded.com/static/dhd/verilator_4/monitor.jpg)

*Табло* 

Структура табло обычно содержит большую часть кода самопроверяющегося тестового стенда. Одно табло имеет один или несколько аналитических (прослушивающих) портов, которые используются для получения элементов транзакций от мониторов. Табло проверяет полученные элементы транзакций, чтобы убедиться, что наблюдаемые входные стимулы приводят к правильным выходным результатам, и определяет, пройден ли тест или нет.

Как правило, в тестовом стенде используется одно табло, но, при необходимости, есть возможность создать несколько экземпляров.

![alt text](https://itsembedded.com/static/dhd/verilator_4/scoreboard.jpg)

#### 2.2.1 Режимы работы АЛУ

Арифметеческий режим

Логический режим

```sv
// f - fixed. Без конструкции generate
module alu_74181f(
    input [3:0]s,
    input Cin, M,
    input [3:0] a, b,
    output reg [3:0] y
);

    reg [3:0] p, g;

    always @(*) begin
        p[0] <= ~(a[0] | (s[0] & b[0]) | (s[1] & ~b[0]));
        p[1] <= ~(a[1] | (s[0] & b[1]) | (s[1] & ~b[1]));
        p[2] <= ~(a[2] | (s[0] & b[2]) | (s[1] & ~b[2]));
        p[3] <= ~(a[3] | (s[0] & b[3]) | (s[1] & ~b[3]));

        g[0] <= ~((a[0] & ~b[0] & s[2]) | (a[0] & b[0] & s[3]));
        g[1] <= ~((a[1] & ~b[1] & s[2]) | (a[1] & b[1] & s[3]));
        g[2] <= ~((a[2] & ~b[2] & s[2]) | (a[2] & b[2] & s[3]));
        g[3] <= ~((a[3] & ~b[3] & s[2]) | (a[3] & b[3] & s[3]));

        y[0] = (p[0] ^ g[0]) ^ ~(~Cin & ~M);
        y[1] = (p[1] ^ g[1]) ^ ~((~Cin & ~M & g[0]) | (~M & p[0]));
        y[2] = (p[2] ^ g[2]) ^ ~((~Cin & ~M & g[0] & g[1]) | (~M & p[1]) | (~M & p[0] & g[1]));
        y[3] = (p[3] ^ g[3]) ^ ~((~Cin & ~M & g[0] & g[1] & g[2]) | (~M & p[2]) | (~M & p[1] & g[2]) | (~M & p[0] & g[1] & g[2]));
    end


endmodule // alu74181
```

Листинг - RTL код четырех разрядного АЛУ 74181

### 2.3 Способы повышения разрядности цифровых операционных устройства
Для увеличения разрядности и скорости работы цифровых операционных устройств применяются схемы с ускоренным переносом (Carry Look-Ahead, CLA). Они позволяют значительно сократить задержку при выполнении операций сложения, особенно при увеличении разрядности.​
#### 2.3.1 Микросхема 4-разрядного ускоренного переноса — 74181

Микросхема 74181 представляет собой 4-разрядное арифметико-логическое устройство (АЛУ), способное выполнять 16 логических и 16 арифметических операций над двумя 4-битными словами. Она поддерживает операции сложения, вычитания, инкремента, декремента, а также логические функции, такие как AND, OR, XOR.

Ключевой особенностью 74181 является использование схемы ускоренного переноса (carry-lookahead), которая позволяет значительно повысить скорость выполнения операций по сравнению с традиционным последовательным переносом. Это достигается за счёт вычисления сигналов генерации (G) и распространения (P) переноса для каждого бита, что позволяет предсказать переносы на более высокие разряды без необходимости ожидания завершения операций в младших разрядах.

Назначение входов/выходов микросхемы: 
- A0-A3 и B0-B3 - четырёхразрядные двоичные суммируемые операнды; 
- S0-S3 - четыре входа выбора позволяют выбрать одну из 16 возможных функций, в зависимости от состояния сигнала на линии M (Mode Control) (M=0 - арифметические операции над прямым кодом операндов А и В при С=1; M=1 - логические операции над прямым кодом операндов); 
- F0-F3 - 4-битный результат выбранной операции; 
- P, G - выходы подключения к блоку ускоренного переноса при каскадировании; 
- (А=В) = бинарный признак равенства операндов в операции сравнения; 
- Cn (Carry In), Cn+4 - входной и выходной признаки переноса. Если операция даёт перенос, то он появляется на выходе Cn+4. Этот перенос можно передавать в следующую микросхему, если нужно работать с числами больше 4 бит.


![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74181.png?raw=true)

Структура CLA

```sv
module cla_74182 (
    input[3:0]  nPB, 
    input[3:0]  nGB,
    input   Cn,
    output	PBo, GBo, Cnx, Cny, Cnz
);
    assign PBo = (  nPB[0]   |   nPB[1]   |   nPB[2]   |   nPB[3]);
    assign GBo = (  (nGB[0]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2]   &   nGB[3]) | 
                    (nPB[2]  &   nGB[2]   &   nGB[3]) | 
                    (nPB[3]  &   nGB[3]));

    assign Cnx = ~( (nPB[0]  &   nGB[0]) | 
                    (nGB[0]  &   ~Cn));
    assign Cny = ~( (nPB[1]  &   nGB[1]) | 
                    (nPB[0]  &   nGB[0]   &   nGB[1])  |
                    (nGB[0]  &   nGB[1]   &   ~Cn));
    assign Cnz = ~( (nPB[2]  &   nGB[2]) | 
                    (nPB[1]  &   nGB[1]   &   nGB[2])  |
                    (nPB[0]  &   nGB[0]   &   nGB[1]   &   nGB[2])  | 
                    (nGB[0]  &   nGB[1]   &   nGB[2]   &   ~Cn));
endmodule

```
Листинг x - 

#### 2.3.2 Микросхема 32-разрядного ускоренного переноса - 74882

Микросхема 74882 — это специализированный блок ускоренного переноса, предназначенный для использования в составе высокоразрядных АЛУ. Она не является самостоятельным АЛУ, как 74181, а служит в качестве расширителя CLA-схемы, обеспечивая обработку переноса между группами по 4 бита, в общей сложности — до 32 разрядов.

Использование 74882 позволяет значительно сократить время выполнения операций сложения и вычитания за счёт параллельной обработки переносов между группами разрядов. Это особенно важно в системах, требующих высокой производительности, таких как процессоры и цифровые сигнальные процессоры.

Назначение входов/выходов микросхемы:
- P0–P7 – входы распространения переноса от восьми 4-битных арифметических блоков (например, от микросхем 74181); указывают, способен ли каждый блок передать перенос дальше при его наличии.
- G0–G7 – входы генерации переноса от тех же восьми 4-битных блоков; сигнализируют о том, что соответствующий блок обязательно создаёт перенос независимо от входного значения переноса.
- Cn – вход переноса в первый (младший) 4-битный блок; используется как начальный перенос в цепи.
- C1–C7 – выходы переноса для последующих 4-битных блоков; формируют сигналы переноса, поступающие на следующий каскад микросхем 74181.

![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/74882.png?raw=true)

Структура CLA

```sv
// Модуль ускоренного переноса с ПОЛОЖИТЕЛЬНЫМ (p) логическим уровнем
module carry32_p74882 (
    input [7:0] P,      // Пропускные сигналы
    input [7:0] G,      // Генерирующие сигналы
    input Cin,          // Входной перенос
    output [3:0] Cout   // Выходные переносы
);

    // Сокращенные записи с использованием generate
    genvar i;
    wire [7:0] PP;      // PP[i] = P[i] & P[i-1]
    wire [7:0] PG;      // PG[i] = P[i] & G[i-1]

    generate
        for (i = 1; i <= 7; i = i + 1) begin : gen_PP_PG
            assign PP[i] = P[i] & P[i-1];
            assign PG[i] = P[i] & G[i-1];
        end
    endgenerate

    assign Cout[0] = ((G[1]) | 
                     ( PG[1]) | 
                     ( PP[1] & Cin));
    assign Cout[1] = ((G[3]) |
                     ( PG[3]) | 
                     ( PP[3] & G[1]) | 
                     ( PP[3] & PG[1]) | 
                     ( PP[3] & PP[1] & ~Cin));

    assign Cout[2] = ((G[5]) |
                     ( PG[5]) | 
                     ( PP[5] & G[3]) | 
                     ( PP[5] & PG[3]) | 
                     ( PP[5] & PP[3] & G[1]) |
                     ( PP[5] & PP[3] & PG[1]) | 
                     ( PP[5] & PP[3] & PP[1] & ~Cin));
    
    assign Cout[3] = ((G[7]) | 
                     ( PG[7])| 
                     ( PP[7] & G[5]) | 
                     ( PP[7] & PG[5])| 
                     ( PP[7] & PP[5] & G[3]) | 
                     ( PP[7] & PP[5] & PG[3])| 
                     ( PP[7] & PP[5] & PP[3] & G[1]) | 
                     ( PP[7] & PP[5] & PP[3] & PG[1])| 
                     ( PP[7] & PP[5] & PP[3] & PP[1] & ~Cin));

endmodule
```

## 3. Симулятор DIGITAL
Digital — это инструмент для проектирования и симуляции цифровых логических схем, разработанный с образовательными целями. Он позволяет пользователям создавать, моделировать и анализировать цифровые схемы, предоставляя визуализацию сигналов и различные инструменты для тестирования и синтеза.
### 3.1 Описание функционала программы
Основные функции:
1. Симуляция работы микросхем в реальном времени:
 - Поддержка комбинационных и последовательностных схем.
- Визуализация изменений сигналов в ходе работы схемы.
- Возможность приостановки и покадрового просмотра работы схем.
2. Моделирование логических элементов и сложных устройств:
- Логические вентили (AND, OR, NOT, XOR и др.).
- Триггеры (D, JK, T, RS).
- Регистрирующие устройства (регистр сдвига, счетчики).
- Память (ROM, RAM).
- Мультиплексоры, дешифраторы, арифметико-логические устройства.
3. Работа с реальными микросхемами:
- Моделирование работы стандартных ИС (например, серии 74xx).
- Возможность загружать схемы и анализировать их сигналы.
- Поддержка пользовательских компонентов для создания сложных цифровых устройств.
4. Графическая визуализация сигналов и измерений:
- Графики изменения сигналов на выводах микросхем.
- Осциллограф для анализа временных диаграмм.
- Логический анализатор для исследования состояний регистров и шин данных.
5. Тестирование и отладка схем:
- Возможность пошагового выполнения схемы.
- Поддержка сценариев тестирования.
- Выявление ошибок в проектировании схем с подсветкой проблемных узлов.
6. Работа с процессорной логикой:
- Симуляция простых процессоров и ALU.
- Создание собственных микропроцессорных архитектур.
- Моделирование работы машинного кода на уровне схем.

### 3.2 Установка DIGITAL
1. Скачайте файл Digital.zip с [GitHub-репозитория](https://github.com/hneemann/Digital).
2. Распакуйте архив в удобное для вас место.
3. Убедитесь, что у вас установлена Java Runtime Environment (JRE) версии 8 или выше. На Windows рекомендуется использовать бинарные файлы от проекта [Eclipse Temurin](https://adoptium.net/).

### 3.3 Сведения о лабораторном оборудовании
#### 3.3.1 Микросхема 4-разрядного ускоренного переноса — 74181
*Цель*

В результате работы со стендом будет получено:

- понимание принципов построения и работы микросхемы АЛУ 74181;

- знание основных арифметических и логических операций на уровне аппаратной логики;

- понимание принципов работы схемы ускоренного переноса и её применения;

- опыт  создания цифровых схем с использованием симуляторов.
  
*Алгоритм работы*
1. В симуляторе Digital откройте или собрите проект стенда с микросхемой 74181.
2. Установите значения операндов A и B, переключив соответствующие входы (A3–A0, B3–B0) в интерфейсе симулятора.
3. Задате код операции, переключив тетраду входов S3–S0 согласно таблице функций и установите вход M для выбора типа операции (M=0 — арифметика, M=1 — логика).
4. Активируйте входной перенос C0 (обычно устанавливается в 1 для операций сложения).
5. Проанализируйте результат на выходах F3–F0, а также сигналы состояния (C4, P, G, A=B).
   
| Код S  | Арифметическая операция (M=0, C0=1) | Арифметическая операция (M=0, C0=0) | Логическая операция (M=1)    |
|--------|-------------------------------------|-------------------------------------|-------------------------------|
| 0000   | A                                   | A + 1                               | NOT A                         |
| 0001   | A OR B                              | NOT (A OR B)                        |                               |
| 0010   | A OR (NOT B)                        | NOT A AND B                         |                               |
| 0011   | 0                                   | 0                                   |                               |
| 0100   | A + (A AND NOT B)                   | NOT (A AND B)                       |                               |
| 0101   | (A AND B) + (A OR B)                | NOT B                               |                               |
| 0110   | A - B - 1                           | A - B                               | A XOR B                       |
| 0111   | (A AND NOT B) - 1                   | A AND NOT B                         |                               |
| 1000   | A + (A AND B)                       | NOT A OR B                          |                               |
| 1001   | A + B                               | A + B + 1                           | NOT (A XOR B)                 |
| 1010   | (A AND B) + (A OR (NOT B))          | B                                   |                               |
| 1011   | (A AND B) - 1                       | A AND B                             |                               |
| 1100   | A + A                               | A + A + 1                           | 1                             |
| 1101   | A + (A OR B)                        | A OR (NOT B)                        |                               |
| 1110   | A + (A OR (NOT B))                  | A OR B                              |                               |
| 1111   | A - 1                               | A                                   | A                             |

*Пример*

Рассмотрим выполнение арифметической операции сложения двух четырёхразрядных чисел. Пусть A = 0101 (5), B = 0011 (3).
На входы микросхемы в симуляторе устанавливаются:

> A3=0, A2=1, A1=0, A0=1

>B3=0, B2=0, B1=1, B0=1

Для операции сложения с учётом переноса выбирается код S3–S0 = 1001 (см. Таблицу функций).

Устанавливается:

>M = 0 (арифметическая операция)

>C0 = 1 (входной перенос)

В результате на выходе:

>F3–F0 = 1001 (9), 

так как 5 + 3 + 1 = 9

>C4 = 0 (переполнения нет).

#### 3.3.2 Микросхема 32-разрядного ускоренного переноса - 74882
*Цель*

В результате работы со стендом будет получено:

- Понимание алгоритма генерации и распространения сигналов переноса;
- Понимание принципа работы ускоренного переноса Carry Lookahead;
- Знание способа построения высокоразрядных АЛУ из каскадированных микросхем;
- Знание методов уменьшения задержек в цифровых вычислениях.

*Алгоритм работы*

1. В симуляторе Digital откройте схему, включающую 4 микросхемы 74181 и одну 74882.
2. Установите значения операндов A и B для каждой микросхемы, переключив соответствующие входы (A3–A0, B3–B0) в интерфейсе симулятора.
3. Получите сигналы G и P с каждой  ALU 74181 и подайте их на 74882.
4. Активируйте входной перенос C0.
5. Проанализируйте выходы C1–C4, которые подаются на следующие по старшинству микросхемы.

Пример микросхемы  32-разрядного ускоренного переноса - 74882.
![alt text](https://github.com/YarosLove91/ALU_discrete_ic/blob/screenshots/screnshots/CLA_74882_ALU-32.png?raw=true)

На русунке:

- PG (Group Propagate) – групповой сигнал распространения переноса; означает, что весь 32-битный блок способен передать входной перенос от начала до конца без генерации своего.

- GG (Group Generate) – групповой сигнал генерации переноса; означает, что весь 32-битный блок сам формирует перенос независимо от входного сигнала Cn.

*Пример*

Устанавливается значения входных сигналов G7–G0 и P7–P0 на основе результатов работы 74181. Ввод C0 = 1 инициирует вычисление всех Cn.Выходы C1–C4 подаются в C0 следующих микросхем.


